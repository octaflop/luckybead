%!PS-Adobe-2.0
%%Creator: dvips(k) 5.98 Copyright 2009 Radical Eye Software
%%Title: businesscard.dvi
%%CreationDate: Mon Sep  5 00:25:01 2011
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 241 156
%%DocumentFonts: CMBX10 CMBX8 CMR8 CMBX7 CMR7
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips businesscard.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2011.09.05:0025
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 90 2009-01-30 10:58:51Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.06, 2009/01/30
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionaray
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
%%-------------- DG begin patch 15 ---------------%%
%/DashLine { dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
%PathLength } ifelse /b ED /x ED /y ED /z y x add def b a .5 sub 2 mul y
%mul sub z Div round z mul a .5 sub 2 mul y mul add b exch Div dup y mul
%/y ED x mul /x ED x 0 gt y 0 gt and { [ y x ] 1 a sub y mul } { [ 1 0 ]
%0 } ifelse setdash stroke } def
/DashLine {
  dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def PathLength } ifelse
  /b ED /x1 ED /y1 ED /x ED /y ED 
  /z y x add y1 add x1 add def
  /Coef b a .5 sub 2 mul y mul sub z Div round 
    z mul a .5 sub 2 mul y mul add b exch Div def 
  /y y Coef mul def 
  /x x Coef mul def 
  /y1 y1 Coef mul def 
  /x1 x1 Coef mul def
  x1 0 gt y1 0 gt or x 0 gt or y 0 gt and 
    { [ y x y1 x1 ] 1 a sub y mul }
    { [ 1 0 ] 0 } ifelse 
  setdash stroke
} def
%%-------------- DG end patch 15 ---------------%%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/PenroseFill {%	 on stack: scaling factor
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def
%
%gsave abs CLW add /a ED a 0 dtransform round exch round exch
%2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
%% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%% DG/SR modification end
%Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
%/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
%% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
%% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
%% def
%a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
%pop pop } def
%% DG/SR modification end
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse 
  /b ED 0 z DS SD b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub moveto } def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
%/NArray { 
%   aload length 2 div dup dup cvi eq not { exch pop } if /n exch
%   cvi def 
%} def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if
  showpoints { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if } def
/Polygon { NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop }
  repeat } { n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1
  ED /x1 ED x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1
  moveto /n n 2 sub def n { Lineto } repeat x1 y1 x0 y0 6 4 roll Lineto
  Lineto pop pop closepath } ifelse } def
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED /c ED /n ED 
  cvi dup 1 lt { pop 1 } if 
  /s ED 
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if
  /dx ED dy div round dy mul 
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 26 2008-06-14 11:50:02Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.01, 2008/01/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.12
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower IsEndingFactor { pop exit } if} loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
end

% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 26 2008-06-14 11:50:02Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2008/04/18
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
  /FontBBox [-571.5 -742.5 571.5 742.5] def
%  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def

end
/PSTricksDotFont exch definefont pop

%% end

%%EndProcSet
%%BeginProcSet: pst-barcode.pro 0 0
%!PS-Adobe-2.0
%%Creator: Terry Burton
%%DocumentPaperSizes: a4
%%EndComments

% Barcode Writer in Pure PostScript - Version 2009-08-12
% http://www.terryburton.co.uk/barcodewriter/
%
% Copyright (c) 2004-2009 Terry Burton
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% Uncomment this next line to allow these procedure definitions to 
% remain resident within a printer's PostScript virtual machine 
% so that the barcode generation capability persists between jobs.

% serverdict begin 0 exitserver 

% --BEGIN TEMPLATE--

% --BEGIN RENDERER renlinear--
/renlinear {

    20 dict begin          % Confine variables to local scope

    /args exch def   % We are given some arguments

    % Default options
    /sbs [] def
    /bhs [] def
    /bbs [] def
    /txt [] def
    /barcolor (unset) def
    /includetext false def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textfont (Courier) def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset 0 def
    /textgaps 0 def
    /alttext () def
    /bordercolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0.15 def
    /width 0 def
    /barratio 1 def
    /spaceratio 1 def
    /showborder false def
    /borderleft 10 def
    /borderright 10 def
    /bordertop 1 def
    /borderbottom 1 def
    /borderwidth 0.5 def
    /guardwhitespace false def
    /guardleftpos 0 def
    /guardleftypos 0 def
    /guardrightpos 0 def
    /guardrightypos 0 def
    /guardwidth 6 def
    /guardheight 7 def
    
    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall 

    /barcolor barcolor cvlit def
    /textcolor textcolor cvlit def
    /textxalign textxalign cvlit def
    /textyalign textyalign cvlit def
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /textgaps textgaps cvr def
    /alttext alttext cvlit def
    /bordercolor bordercolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /width width cvr def
    /barratio barratio cvr def
    /spaceratio spaceratio cvr def
    /borderleft borderleft cvr def
    /borderright borderright cvr def
    /bordertop bordertop cvr def
    /borderbottom borderbottom cvr def
    /borderwidth borderwidth cvr def
    /guardleftpos guardleftpos cvr def
    /guardleftypos guardleftypos cvr def
    /guardrightpos guardrightpos cvr def
    /guardrightypos guardrightypos cvr def
    /guardwidth guardwidth cvr def
    /guardheight guardheight cvr def
    
    % Create bar elements and put them into the bars array
    /bars sbs length 1 add 2 idiv array def
    /x 0.00 def /maxh 0 def
    0 1 sbs length 1 add 2 idiv 2 mul 2 sub {
        /i exch def
        i 2 mod 0 eq {           % i is even
            /d sbs i get barratio mul barratio sub 1 add def  % d=digit*r-r+1 
            /h bhs i 2 idiv get 72 mul def  % Height from bhs
            /c d 2 div x add def            % Centre of the bar = x + d/2
            /y bbs i 2 idiv get 72 mul def  % Baseline from bbs
            /w d inkspread sub def          % bar width = digit - inkspread
            bars i 2 idiv [h c y w] put     % Add the bar entry
            h maxh gt {/maxh h def} if
        } {
            /d sbs i get spaceratio mul spaceratio sub 1 add def  % d=digit*r-r+1 
        } ifelse
        /x x d add def  % x+=d
    } for

    gsave

    currentpoint translate

    % Force symbol to given width
    width 0 ne {
        width 72 mul x div 1 scale
    } if

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Display the border and background
    newpath
    borderleft neg borderbottom neg moveto
    x borderleft add borderright add 0 rlineto
    0 maxh borderbottom add bordertop add rlineto
    x borderleft add borderright add neg 0 rlineto
    0 maxh borderbottom add bordertop add neg rlineto    
    closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if     
    showborder {
        gsave
        bordercolor (unset) ne { bordercolor setanycolor } if
        borderwidth setlinewidth stroke
        grestore
    } if    
   
    % Display the bars for elements in the bars array
    gsave
    0 setlinecap
    barcolor (unset) ne { barcolor setanycolor } if
    bars {
        {} forall
        newpath setlinewidth moveto 0 exch rlineto stroke
    } forall
    grestore
    
    % Display the text for elements in the text array
    textcolor (unset) ne { textcolor setanycolor } if
    includetext {
        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /f () def
            txt {
                {} forall
                2 copy s ne exch f ne or {
                    2 copy /s exch def /f exch def            
                    exch findfont exch scalefont setfont          
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {
            textfont findfont textsize scalefont setfont
            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
            } ifelse

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def
            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def

            /textxpos textxoffset x textwidth sub 2 div add def
            textxalign (left) eq { /textxpos textxoffset def } if
            textxalign (right) eq { /textxpos x textxoffset sub textwidth sub def } if
            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if
            textxalign (offright) eq { /textxpos x textxoffset add def } if
            textxalign (justify) eq textwidth x lt and {
                /textxpos 0 def
                /textgaps x textwidth sub tstr length 1 sub div def
            } if
            /textypos textyoffset textascent add 1 add neg def
            textyalign (above) eq { /textypos textyoffset maxh add 1 add def } if
            textyalign (center) eq { /textypos textyoffset maxh textascent sub 2 div add def } if
            textxpos textypos moveto textgaps 0 tstr ashow
        } ifelse
    } if    

    % Display the guard elements
    guardwhitespace {
        0.75 setlinewidth
        guardleftpos 0 ne {
            newpath
            guardleftpos neg guardwidth add guardleftypos guardwidth 2 div add moveto
            guardwidth neg guardheight -2 div rlineto
            guardwidth guardheight -2 div rlineto
            stroke            
        } if
        guardrightpos 0 ne {
            newpath
            guardrightpos x add guardwidth sub guardrightypos guardheight 2 div add moveto
            guardwidth guardheight -2 div rlineto
            guardwidth neg guardheight -2 div rlineto
            stroke            
        } if
    } if
    
    grestore
    
    end

} bind def
% --END RENDERER renlinear--

% --BEGIN RENDERER renmatrix--
/renmatrix {

    20 dict begin

    /args exch def

    % Default options
    /width 1 def
    /height 1 def
    /color (unset) def
    /backgroundcolor (unset) def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /width width cvr def
    /height height cvr def
    /color color cvlit def
    /backgroundcolor backgroundcolor cvlit def

    % Extend bitmap horizontally to an 8-bit boundary
    /pixx8 pixx 8 div ceiling cvi 8 mul def
    /pixs8 [ pixx8 pixy mul {0} repeat ] def
    0 1 pixy 1 sub {
        /i exch def
        pixs8 pixx8 i mul pixs pixx i mul pixx getinterval putinterval
    } for
    /pixs pixs8 def

    % Convert bitmap into 8-bit sample string
    /imgstr pixs length 8 idiv string def
    0 1 pixs length 1 sub {
        /i exch def
        imgstr i 8 idiv 2 copy get 2 7 i 8 mod sub exp cvi pixs i get mul add put
    } for

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Draw the image
    gsave
    currentpoint translate
    72 width mul 72 height mul scale
    .0001 .0001 moveto .9999 .0001 lineto .9999 .9999 lineto .0001 .9999 lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if 
    color (unset) ne { color setanycolor } if
    pixx pixy true [ pixx 0 0 pixy neg 0 pixy ] {imgstr} imagemask
    grestore

    end

} bind def
% --END RENDERER renmatrix--

% --BEGIN RENDERER renmaximatrix--
/renmaximatrix {

    20 dict begin

    /args exch def   % We are given some arguments

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall
 
    gsave

    currentpoint translate

    2.4945 dup scale  % from 1pt to 1.88mm
    0.5 0.5774 translate

    pixs {
        dup 
        /x exch 30 mod def 
        /y exch 30 idiv def
        y 2 mod 0 eq {x} {x 0.5 add} ifelse
        32 y sub 0.8661 mul
        moveto
        0     0.5774 rmoveto
        -0.5 -0.2887 rlineto
        0    -0.5774 rlineto
        0.5  -0.2887 rlineto
        0.5   0.2887 rlineto
        0     0.5774 rlineto
        -0.5  0.2887 rlineto
        closepath fill
    } forall

    % Plot the locator symbol
    newpath 14 13.8576 0.5774 0 360 arc closepath
    14 13.8576 1.3359 360 0 arcn closepath fill
    newpath 14 13.8576 2.1058 0 360 arc closepath
    14 13.8576 2.8644 360 0 arcn closepath fill
    newpath 14 13.8576 3.6229 0 360 arc closepath
    14 13.8576 4.3814 360 0 arcn closepath fill

    grestore

    end

} bind def
% --END RENDERER renmaximatrix--

% --BEGIN ENCODER ean5--
% --DESC: EAN-5 (5 digit addon)
% --EXAM: 90200
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/ean5 {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def    
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall   
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 10 checksum
    /mirrormaps
    [ (11000) (10100) (10010) (10001) (01100)
      (00110) (00011) (01010) (01001) (00101)
    ] def
    /checksum 0 def
    0 1 4 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar 3 mul checksum add def
        } {
            /checksum barchar 9 mul checksum add def
        } ifelse
    } for
    /checksum checksum 10 mod def
    /mirrormap mirrormaps checksum get def

    /sbs 31 string def
    /txt 5 array def
   
    0 1 4 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [16{height}repeat]
    /bbs [16{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER ean5--

% --BEGIN ENCODER ean2--
% --DESC: EAN-2 (2 digit addon)
% --EXAM: 05
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/ean2 {

    20 dict begin

    /options exch def                   % We are given an options string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 4 checksum
    /mirrormap [(00) (01) (10) (11)] barcode 0 2 getinterval cvi 4 mod get def

    /sbs 13 string def
    /txt 2 array def
    
    0 1 1 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap    
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [12{height}repeat]
    /bbs [12{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER ean2--

% --BEGIN ENCODER ean13--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-13
% --EXAM: 977147396801
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/ean13 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def             % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def

    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Add checksum digit
    /pad 13 string def
    /checksum 0 def
    0 1 11 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 12 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Digits to mirror on left side
    /mirrormaps
    [ (000000) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    /sbs 59 string def
    /txt 13 array def
  
    % Put the start character
    sbs 0 encs 10 get putinterval

    % First digit - determine mirrormap by this and show before guard bars
    /mirrormap mirrormaps barcode 0 get 48 sub get def
    txt 0 [barcode 0 1 getinterval -10 textyoffset textfont textsize] put

    % Left side - performs mirroring
    1 1 6 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {   % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 7 1 sub 4 mul 3 add encs 11 get putinterval

    % Right side
    7 1 12 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        sbs i 1 sub 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 8 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height 12{height .075 sub}repeat height height] def
        /bbs [0 0 12{.075}repeat 0 0 12{.075}repeat 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 95 addongap add
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 
   
    % Return the arguments
    <<
    /ren (renlinear)
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER ean13--

% --BEGIN ENCODER ean8--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-8
% --EXAM: 01335583
% --EXOP: includetext guardwhitespace height=0.5
% --RNDR: renlinear
/ean8 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def
    
    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Add checksum digit
    /pad 8 string def
    /checksum 0 def
    0 1 6 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval      % Add barcode to the start of the pad
    pad 7 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def
 
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 43 string def
    /txt 8 array def
    
    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 3 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 4 add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 4 4 mul 3 add encs 11 get putinterval

    % Right side
    4 1 7 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 8 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 40 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 8{height .075 sub}repeat height height 8{height .075 sub}repeat height height] def
        /bbs [0 0 8{.075}repeat 0 0 8{.075}repeat 0 0] def
    } {
        /bhs [22{height}repeat] def
        /bbs [22{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 67 addongap add
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardleftpos 10
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER ean8--

% --BEGIN ENCODER upca--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-A
% --EXAM: 78858101497
% --EXOP: includetext
% --RNDR: renlinear
/upca {

    20 dict begin

    /options exch def
    /barcode exch def             % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def 
    /addongap 12 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall    

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def
   
    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Add checksum digit to barcode
    /pad 12 string def   % Create pad one bigger than barcode
    /checksum 0 def
    0 1 10 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum checksum barchar add def
        } {
            /checksum checksum barchar 3 mul add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 11 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 59 string def
    /txt 12 array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 5 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        i 0 eq {      % First digit is before the guard bars
            txt 0 [barcode 0 1 getinterval -7 textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 4 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the middle character
    sbs 6 4 mul 3 add encs 11 get putinterval

    % Right side
    6 1 11 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        i 11 eq {       % Last digit is after guard bars
            txt 11 [barcode 11 1 getinterval 96 textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 8 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [4{height}repeat 10{height .075 sub}repeat height height 10{height .075 sub}repeat 4{height}repeat] def
        /bbs [0 0 0 0 10{.075}repeat 0 0 10{.075}repeat 0 0 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 95 addongap add
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER upca--

% --BEGIN ENCODER upce--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-E
% --EXAM: 0123456
% --EXOP: includetext height=0.4
% --RNDR: renlinear
/upce {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def    

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (111111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /mirrormaps
    [ (000111) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    % Derive the equivalent UPC-A for its checksum
    /upcacode (00000000000) 11 string copy def
    barcode 6 get 48 sub 2 le {
        upcacode 1 barcode 1 2 getinterval putinterval
        upcacode 3 barcode 6 1 getinterval putinterval
        upcacode 8 barcode 3 3 getinterval putinterval
    } if
    barcode 6 get 48 sub 3 eq {
        upcacode 1 barcode 1 3 getinterval putinterval
        upcacode 9 barcode 4 2 getinterval putinterval
    } if
    barcode 6 get 48 sub 4 eq {
        upcacode 1 barcode 1 4 getinterval putinterval
        upcacode 10 barcode 5 1 getinterval putinterval
    } if
    barcode 6 get 48 sub 5 ge {
        upcacode 1 barcode 1 5 getinterval putinterval
        upcacode 10 barcode 6 1 getinterval putinterval
    } if
    /checksum 0 def
    0 1 10 {
       /i exch def
       /barchar upcacode i get 48 sub def
       i 2 mod 0 ne {
           /checksum checksum barchar add def
       } {
           /checksum checksum barchar 3 mul add def
       } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    /pad 8 string def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 7 checksum 48 add put       % Put ascii for checksum at end of pad
    /barcode pad def
    /txt 8 array def
    txt 0 [barcode 0 1 getinterval -7 textyoffset textfont textsize 2 sub] put

    % Determine the mirror map based on checksum
    /mirrormap mirrormaps checksum get def

    % Invert the mirrormap if we are using a non-zero number system
    barcode 0 get 48 eq {
        /invt mirrormap length string def
        0 1 mirrormap length 1 sub {
            /i exch def
            mirrormap i get 48 eq {
                invt i 49 put
            } {
                invt i 48 put
            } ifelse
        } for
        /mirrormap invt def
    } if

    /sbs 33 string def

    % Put the start character
    sbs 0 encs 10 get putinterval

    1 1 6 {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {  % Reverse enc if 1 in this position in mirrormap        
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textyoffset textfont textsize] put
    } for

    txt 7 [barcode 7 1 getinterval 6 7 mul 11 add textyoffset textfont textsize 2 sub] put

    % Put the end character
    sbs 27 encs 11 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height height] def
        /bbs [0 0 12{.075}repeat 0 0 0] def
    } {
        /bhs [17{height}repeat] def
        /bbs [17{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 51 addongap add
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER upce--

% --BEGIN ENCODER isbn--
% --REQUIRES ean13--
% --SUGGESTS ean5 ean2--
% --DESC: ISBN
% --EXAM: 978-1-56592-479 54495
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/isbn {

    20 dict begin

    /options exch def      % We are given an options string
    /isbntxt exch def      % We are given the isbn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISBN text
    /isbnfont /Courier def
    /isbnsize 9 def
    /isbnpos (unset) def
    /height 1 def
    /addongap 12 def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /isbnfont isbnfont cvlit def
    /isbnsize isbnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    isbnpos (unset) eq {
        /isbnpos height 72 mul 3 add def
    } {
        /isbnpos isbnpos cvr def
    } ifelse
   
    % Split off the addon
    isbntxt ( ) search {
        /isbntxt exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Read the digits from isbntxt and calculate checksums
    /isbn 13 string def
    /checksum10 0 def
    /checksum13 0 def
    /i 0 def /n 0 def
    { % loop
        /isbnchar isbntxt i get 48 sub def
        isbnchar -3 ne {     % Ignore dashes
            isbn n isbnchar 48 add put
            n 9 lt {
                /checksum10 checksum10 10 n sub isbnchar mul add def
            } if
            n 12 lt {
                n 2 mod 0 eq {
                    /checksum13 isbnchar checksum13 add def
                } {
                    /checksum13 isbnchar 3 mul checksum13 add def
                } ifelse
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i isbntxt length eq {exit} if
    } loop

    % Add the ISBN header to the isbntxt
    n 9 eq n 10 eq or {
        /checksum 11 checksum10 11 mod sub 11 mod def
        /isbn isbn 0 9 getinterval def
        /pad 18 string def
    } {
        /checksum 10 checksum13 10 mod sub 10 mod def
        /isbn isbn 0 12 getinterval def
        /pad 22 string def
    } ifelse
    pad 0 (ISBN ) putinterval
    pad 5 isbntxt putinterval  % Add isbntxt to the pad

    % Add checksum digit
    pad pad length 2 sub 45 put  % Put a dash
    checksum 10 eq {
        pad pad length 1 sub checksum 78 add put  % Check digit for 10 is X
    } {
        pad pad length 1 sub checksum 48 add put  % Put check digit
    } ifelse
    /isbntxt pad def

    % Convert ISBN digits to EAN-13
    /barcode 12 string def
    isbn length 9 eq {        
        barcode 0 (978) putinterval
        barcode 3 isbn putinterval
    } {
        barcode 0 isbn putinterval
    } ifelse

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISBN text
    includetext {
        isbn length 9 eq {
            /isbnxpos -1 def
        } {
            /isbnxpos -12 def
        } ifelse
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [isbntxt isbnxpos isbnpos isbnfont isbnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [isbntxt isbnxpos isbnpos isbnfont isbnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
% --END ENCODER isbn--

% --BEGIN ENCODER code128--
% --DESC: Code 128
% --EXAM: ^104^102Count^0990123456789^101!
% --EXOP: includetext
% --RNDR: renlinear
/code128 {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (2331112)
    ] def

    % Create a string of the available characters for alphabets A and B
    /barchars ( !"#$%&'\(\)*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~) def
    /barlen barcode length def    % Length of the code
    /sbs barlen 6 mul string def  % sbs is 6 times length of barcode
    /txt barlen array def

    /mode -1 def         % A=0, B=1, C=2
    /checksum barcode 1 3 getinterval cvi def  % Initialise the checksum

    /i 0 def /j 0 def
    { % loop
        i barlen eq {exit} if
        barcode i 1 getinterval (^) eq {
            % indx is given by the next three characters
            /indx barcode i 1 add 3 getinterval cvi def
            txt j [( ) j 11 mul textyoffset textfont textsize] put
            /i i 4 add def
        } {
            % indx depends on the mode
            mode 2 eq {
                /indx barcode i 2 getinterval cvi def
                txt j [barcode i 2 getinterval j 11 mul textyoffset textfont textsize] put
                /i i 2 add def
            } {
                barchars barcode i 1 getinterval search
                pop                    % Discard true leaving pre
                length /indx exch def  % indx is the length of pre
                pop pop                % Discard seek and post
                txt j [barchars indx 1 getinterval j 11 mul textyoffset textfont textsize] put
                /i i 1 add def
            } ifelse
        } ifelse
        /enc encs indx get def         % Get the indxth encoding
        sbs j 6 mul enc putinterval    % Put encoded digit into sbs

        % Update the mode
        indx 101 eq indx 103 eq or {/mode 0 def} if
        indx 100 eq indx 104 eq or {/mode 1 def} if
        indx 99 eq indx 105 eq or {/mode 2 def} if

        /checksum indx j mul checksum add def  % checksum+=indx*j
        /j j 1 add def
    } loop

    % Put the checksum character
    /checksum checksum 103 mod def
    sbs j 6 mul encs checksum get putinterval

    % Put the end character
    sbs j 6 mul 6 add encs 106 get putinterval

    % Shrink sbs and txt to fit exactly
    /sbs sbs 0 j 6 mul 13 add getinterval def
    /txt txt 0 j getinterval def

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER code128--

% --BEGIN ENCODER code39--
% --DESC: Code 39
% --EXAM: THIS IS CODE 39
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/code39 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def
    /includecheckintext false def
    /hidestars false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (1113313111) (3113111131) (1133111131) (3133111111) (1113311131)
      (3113311111) (1133311111) (1113113131) (3113113111) (1133113111)
      (3111131131) (1131131131) (3131131111) (1111331131) (3111331111)
      (1131331111) (1111133131) (3111133111) (1131133111) (1111333111)
      (3111111331) (1131111331) (3131111311) (1111311331) (3111311311)
      (1131311311) (1111113331) (3111113311) (1131113311) (1111313311)
      (3311111131) (1331111131) (3331111111) (1311311131) (3311311111)
      (1331311111) (1311113131) (3311113111) (1331113111) (1313131111)
      (1313111311) (1311131311) (1113131311) (1311313111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%*) def

    /barlen barcode length def  % Length of the code

    includecheck {
        /sbs barlen 10 mul 30 add string def
        /txt barlen 3 add array def
    } {
        /sbs barlen 10 mul 20 add string def
        /txt barlen 2 add array def
    } ifelse

    /checksum 0 def

    % Put the start character
    sbs 0 encs 43 get putinterval
    hidestars not {
        txt 0 [(*) 0 textyoffset textfont textsize] put
    } {
        txt 0 [() 0 textyoffset textfont textsize] put
    } ifelse

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /enc encs indx get def               % Get the indxth encoding
        sbs i 10 mul 10 add enc putinterval  % Put encoded digit into sbs
        txt i 1 add [barcode i 1 getinterval i 1 add 16 mul textyoffset textfont textsize] put
        /checksum checksum indx add def
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum checksum 43 mod def
        sbs barlen 10 mul 10 add encs checksum get putinterval
        includecheckintext {
            txt barlen 1 add [barchars checksum 1 getinterval barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
        sbs barlen 10 mul 20 add encs 43 get putinterval
        hidestars not {
            txt barlen 2 add [(*) barlen 2 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 2 add [() barlen 2 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen 10 mul 10 add encs 43 get putinterval
        hidestars not {
            txt barlen 1 add [(*) barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } ifelse
    
    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER code39--

% --BEGIN ENCODER code93--
% --DESC: Code 93
% --EXAM: THIS IS CODE 93
% --EXOP: includetext includecheck
% --RNDR: renlinear
/code93 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /encs
    [ (131112) (111213) (111312) (111411) (121113)
      (121212) (121311) (111114) (131211) (141111)
      (211113) (211212) (211311) (221112) (221211)
      (231111) (112113) (112212) (112311) (122112)
      (132111) (111123) (111222) (111321) (121122)
      (131121) (212112) (212211) (211122) (211221)
      (221121) (222111) (112122) (112221) (122121)
      (123111) (121131) (311112) (311211) (321111)
      (112131) (113121) (211131) (121221) (312111)
      (311121) (122211) (111141) (1111411)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barlen barcode length def  % Length of the code    
    barcode {
        (^) search false eq {pop exit} if
        pop pop /barlen barlen 3 sub def
    } loop

    includecheck {
        /sbs barlen 6 mul 25 add string def
    } {
        /sbs barlen 6 mul 13 add string def
    } ifelse
    /txt barlen array def
    
    % Put the start character
    sbs 0 encs 47 get putinterval
    
    /checksum1 0 def /checksum2 0 def

    /i 0 def /j 0 def
    { % loop
        j barlen eq {exit} if
        barcode i 1 getinterval (^) eq {
            % indx is given by the next three characters
            /indx barcode i 1 add 3 getinterval cvi def
            txt j [( ) j 9 mul 9 add textyoffset textfont textsize] put
            /i i 4 add def
        } {
            barchars barcode i 1 getinterval search
            pop                         % Discard true leaving pre
            length /indx exch def       % indx is the length of pre
            pop pop                     % Discard seek and post
            txt j [barchars indx 1 getinterval j 9 mul 9 add textyoffset textfont textsize] put
            /i i 1 add def
        } ifelse
        /enc encs indx get def             % Get the indxth encoding
        sbs j 6 mul 6 add enc putinterval  % Put encoded digit into sbs
        /checksum1 checksum1 barlen j sub 1 sub 20 mod 1 add indx mul add def
        /checksum2 checksum2 barlen j sub 15 mod 1 add indx mul add def
        /j j 1 add def
    } loop
    
    includecheck {
        % Put the first checksum character
        /checksum1 checksum1 47 mod def
        /checksum2 checksum2 checksum1 add 47 mod def
        sbs j 6 mul 6 add encs checksum1 get putinterval
        sbs j 6 mul 12 add encs checksum2 get putinterval
        % Put the end character
        sbs j 6 mul 18 add encs 48 get putinterval
    } {
        % Put the end character
        sbs j 6 mul 6 add encs 48 get putinterval      
    } ifelse

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER code93--

% --BEGIN ENCODER interleaved2of5--
% --DESC: Interleaved 2 of 5 (ITF)
% --EXAM: 24012345678905
% --EXOP: showborder borderwidth=4 borderleft=15 borderright=15 height=0.5 includecheck includetext includecheckintext textyoffset=-10
% --RNDR: renlinear
/interleaved2of5 {

    20 dict begin         % Confine variables to local scope

    /options exch def               % We are given an option string
    /barcode exch def               % We are given a barcode string

    /dontdraw false def
    /includecheck false def         % Enable/disable checkdigit
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def      % Length of the code

    % Prefix 0 to barcode if length is even and including checkdigit
    % or length is odd and not including checkdigit
    barlen 2 mod 0 eq includecheck and          % even & includecheck
    barlen 2 mod 0 ne includecheck not and or { % odd  & !includecheck
        /pad barlen 1 add string def  % Create pad one bigger than barcode
        pad 0 48 put                  % Put ascii 0 at start of pad
        pad 1 barcode putinterval     % Add barcode to the end of pad
        /barcode pad def              % barcode=pad
        /barlen barlen 1 add def      % barlen++
    } if

    % Add checksum to end of barcode
    includecheck {
        /checksum 0 def
        0 1 barlen 1 sub {
            /i exch def
            i 2 mod 0 eq {
                /checksum checksum barcode i get 48 sub 3 mul add def
            } {
                /checksum checksum barcode i get 48 sub add def
            } ifelse
        } for
        /checksum 10 checksum 10 mod sub 10 mod def
        /pad barlen 1 add string def    % Create pad one bigger than barcode
        pad 0 barcode putinterval       % Add barcode to the start of pad
        pad barlen checksum 48 add put  % Add checksum to end of pad
        /barcode pad def                % barcode=pad
        /barlen barlen 1 add def        % barlen++
    } if

    % Create an array containing the character mappings
    /encs
    [ (11331) (31113) (13113) (33111) (11313)
      (31311) (13311) (11133) (31131) (13131)
      (1111)  (3111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def
    /sbs barlen 5 mul 8 add string def
    /txt barlen array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    0 2 barlen 1 sub {
    /i exch def
        % Lookup the encodings for two consecutive barcode characters
        barcode i 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /enca encs indx get def       % Get the indxth encoding

        barcode i 1 add 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /encb encs indx get def       % Get the indxth encoding

        % Interleave the two character encodings
        /intl enca length 2 mul string def
        0 1 enca length 1 sub {
            /j exch def
            /achar enca j get def
            /bchar encb j get def
            intl j 2 mul achar put
            intl j 2 mul 1 add bchar put
        } for

        sbs i 5 mul 4 add intl putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul 4 add textyoffset textfont textsize] put
        includecheck includecheckintext not and barlen 2 sub i eq and {
            txt i 1 add [( ) i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } {
            txt i 1 add [barcode i 1 add 1 getinterval i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs barlen 5 mul 4 add encs 11 get putinterval

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER interleaved2of5--

% --BEGIN ENCODER rss14--
% --DESC: GS1 DataBar Omnidirectional
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renlinear renmatrix
/rss14 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 33 72 div def
    /linkage false def
    /format (omni) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
  
    format (truncated) eq {/height 13 72 div def} if
    /height height cvr def

    % Strip the AI and optional check digit
    barcode length dup 17 eq exch 18 eq or {
        barcode 0 4 getinterval (\(01\)) eq {
            /binval [ 
                linkage {1} {0} ifelse
                barcode 4 13 getinterval {48 sub} forall
            ] def
        } if
    } if

    % Calculate EAN checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    18 string
    dup 0 barcode 0 17 getinterval putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
     
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
   
    0 1 12 {
        /i exch def
        binval i 1 add 2 copy get binval i get 4537077 mod 10 mul add put
        binval i binval i get 4537077 idiv put
    } for
    /right binval 13 get 4537077 mod def
    binval 13 2 copy get 4537077 idiv put

    /left 0 def
    /i true def
    0 1 13 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /left left 3 -1 roll 10 13 j sub exp cvi mul add def
        } ifelse
    } for
    
    /d1 left 1597 idiv def
    /d2 left 1597 mod def
    /d3 right 1597 idiv def
    /d4 right 1597 mod def

    /tab164 [
        160   0     12 4   8 1  161   1
        960   161   10 6   6 3  80   10
        2014  961   8  8   4 5  31   34
        2714  2015  6  10  3 6  10   70
        2840  2715  4  12  1 8  1    126
    ] def

    /tab154 [
        335   0     5  10  2 7  4   84
        1035  336   7  8   4 5  20  35
        1515  1036  9  6   6 3  48  10
        1596  1516  11 4   8 1  81  1
    ] def

    /i 0 def {
        d1 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d3 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d3te exch def /d3to exch def
            /d3mwe exch def /d3mwo exch def
            /d3ele exch def /d3elo exch def
            /d3gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d4 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d4te exch def /d4to exch def
            /d4mwe exch def /d4mwo exch def
            /d4ele exch def /d4elo exch def
            /d4gs exch def
            exit
        } if
        /i i 8 add def
    } loop
    
    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 4 false getRSSwidths def
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 4 true  getRSSwidths def
    /d2wo d2 d2gs sub d2to mod  d2elo d2mwo 4 true  getRSSwidths def
    /d2we d2 d2gs sub d2to idiv d2ele d2mwe 4 false getRSSwidths def
    /d3wo d3 d3gs sub d3te idiv d3elo d3mwo 4 false getRSSwidths def
    /d3we d3 d3gs sub d3te mod  d3ele d3mwe 4 true  getRSSwidths def
    /d4wo d4 d4gs sub d4to mod  d4elo d4mwo 4 true  getRSSwidths def
    /d4we d4 d4gs sub d4to idiv d4ele d4mwe 4 false getRSSwidths def

    /d1w 8 array def
    0 1 3 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 8 array def
    0 1 3 {
        /i exch def
        d2w 7 i 2 mul sub d2wo i get put
        d2w 6 i 2 mul sub d2we i get put
    } for
    
    /d3w 8 array def
    0 1 3 {
        /i exch def
        d3w 7 i 2 mul sub d3wo i get put
        d3w 6 i 2 mul sub d3we i get put
    } for
    
    /d4w 8 array def
    0 1 3 {
        /i exch def
        d4w i 2 mul d4wo i get put
        d4w i 2 mul 1 add d4we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
        d3w {} forall
        d4w {} forall
    ] def
    
    /checkweights [
        1   3   9   27  2   6   18  54
        58  72  24  8   29  36  12  4
        74  51  17  32  37  65  48  16
        64  34  23  69  49  68  46  59
    ] def

    /checkwidths [
        3 8 2 1 1   3 5 5 1 1   3 3 7 1 1
        3 1 9 1 1   2 7 4 1 1   2 5 6 1 1
        2 3 8 1 1   1 5 7 1 1   1 3 9 1 1
    ] def
    
    /checksum 0 def
    0 1 31 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def 
    } for
    /checksum checksum 79 mod def    
    checksum 8 ge {/checksum checksum 1 add def} if
    checksum 72 ge {/checksum checksum 1 add def} if
    /checklt checkwidths checksum 9 idiv 5 mul 5 getinterval def
    /checkrtrev checkwidths checksum 9 mod 5 mul 5 getinterval def
    /checkrt 5 array def
    0 1 4 {
        /i exch def
        checkrt i checkrtrev 4 i sub get put
    } for

    % Stacked format
    format (omni) eq format (truncated) eq or {  % linear

        /sbs [
            1 d1w {} forall checklt {} forall d2w {} forall 
            d4w {} forall checkrt {} forall d3w {} forall 1 1
        ] def
        
        <<
        /ren (renlinear)
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /txt txt
        /textxalign (center)
        /opt options
        >>
    
        dontdraw not //renlinear if

    } {  % 2D - stacked or stackedomni

        /top [ 1 1 d1w {} forall checklt {} forall d2w {} forall 1 1 0 ] def
        /bot [ 1 1 d4w {} forall checkrt {} forall d3w {} forall 1 1 0 ] def 
        0 2 24 {
            /i exch def
            top i get {0} repeat
            top i 1 add get {1} repeat
        } for
        50 array astore /top exch def 
        0 2 24 {
            /i exch def
            bot i get {1} repeat
            bot i 1 add get {0} repeat
        } for
        50 array astore /bot exch def

        % Stacked
        format (stacked) eq {
            /sep [ 50 {0} repeat ] def
            4 1 45 {
                /i exch def
                top i get bot i get eq {
                    sep i 1 top i get sub put
                } {
                    sep i 1 sep i 1 sub get sub put
                } ifelse
            } for
            /pixs [
                5 {top aload pop} repeat
                sep aload pop
                7 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Stacked omnidirectional
        format (stackedomni) eq {
            /sep1 [ top {1 exch sub} forall ] def
            sep1 0  [ 0 0 0 0 ] putinterval
            sep1 46 [ 0 0 0 0 ] putinterval
            18 1 30 {
                /i exch def
                top i get 0 eq {
                    top i 1 sub get 1 eq {
                        1
                    } {
                        sep1 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep1 exch i exch put
            } for
            /sep2 [ 0 0 0 0 21 { 0 1 } repeat 0 0 0 0 ] def
            /sep3 [ bot {1 exch sub} forall ] def
            sep3 0  [ 0 0 0 0 ] putinterval
            sep3 46 [ 0 0 0 0 ] putinterval
            19 1 31 {
                /i exch def
                bot i get 0 eq {
                    bot i 1 sub get 1 eq {
                        1
                    } {
                        sep3 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep3 exch i exch put
            } for
            checksum 9 mod 3 eq {  % Right shifted module for value 3 finder
                sep3 19 [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
            } if
            /pixs [
                33 {top aload pop} repeat
                sep1 aload pop
                sep2 aload pop
                sep3 aload pop
                33 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Return the arguments
        <<
        /ren (renmatrix)
        /pixs pixs
        /pixx 50
        /pixy pixy
        /height pixy 72 div
        /width 50 72 div
        /opt options
        >>
    
        dontdraw not //renmatrix if
     
    } ifelse
    
    end

} bind def
% --END ENCODER rss14--

% --BEGIN ENCODER rsslimited--
% --DESC: GS1 DataBar Limited
% --EXAM: (01)15012345678907
% --EXOP: height=0.3
% --RNDR: renlinear
/rsslimited {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 10 72 div def
    /linkage false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /height height cvr def

    % Strip the AI and optional check digit
    barcode length dup 17 eq exch 18 eq or {
        barcode 0 5 getinterval dup (\(01\)0) eq exch (\(01\)1) eq or {
            /binval [ 
                barcode 4 13 getinterval {48 sub} forall
            ] def
            linkage {
                /linkval [ 2 0 1 5 1 3 3 5 3 1 0 9 6 ] def
                0 1 binval length 1 sub {
                    /i exch def
                    binval i binval i get linkval i get add put
                } for
            } if 
        } if
    } if

    % Calculate EAN checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    18 string
    dup 0 barcode 0 17 getinterval putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
   
    0 1 11 {
        /i exch def
        binval i 1 add 2 copy get binval i get 2013571 mod 10 mul add put
        binval i binval i get 2013571 idiv put
    } for
    /d2 binval 12 get 2013571 mod def
    binval 12 2 copy get 2013571 idiv put

    /d1 0 def
    /i true def
    0 1 12 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /d1 d1 3 -1 roll 10 12 j sub exp cvi mul add def
        } ifelse
    } for
    
    /tab267 [
        183063   0        17 9   6 3  6538   28
        820063   183064   13 13  5 4  875    728
        1000775  820064   9  17  3 6  28     6454
        1491020  1000776  15 11  5 4  2415   203
        1979844  1491021  11 15  4 5  203    2408
        1996938  1979845  19 7   8 1  17094  1
        2013570  1996939  7  19  1 8  1      16632
    ] def

    /i 0 def {
        d1 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 7 false getRSSwidths def    
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 7 true  getRSSwidths def
    /d2wo d2 d2gs sub d2te idiv d2elo d2mwo 7 false getRSSwidths def    
    /d2we d2 d2gs sub d2te mod  d2ele d2mwe 7 true  getRSSwidths def

    /d1w 14 array def
    0 1 6 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 14 array def
    0 1 6 {
        /i exch def
        d2w i 2 mul d2wo i get put
        d2w i 2 mul 1 add d2we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
    ] def
    
    /checkweights [
        1  3  9  27 81 65 17 51 64 14 42 37 22 66
        20 60 2  6  18 54 73 41 34 13 39 28 84 74
    ] def

    /checkseq [
        0 1 43 {} for
        45 52 57
        63 1 66 {} for
        73 1 79 {} for
        82
        126 1 130 {} for
        132
        141 1 146 {} for
        210 1 217 {} for
        220
        316 1 320 {} for
        322 323
        326 337
    ] def
   
    /checksum 0 def
    0 1 27 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def
    } for
    /checksum checksum 89 mod def
    /seq checkseq checksum get def
    /swidths seq 21 idiv 8 3 6 false getRSSwidths def
    /bwidths seq 21 mod  8 3 6 false getRSSwidths def

    /checkwidths [0 0 0 0 0 0 0 0 0 0 0 0 1 1] def
    0 1 5 {
        /i exch def
        checkwidths i 2 mul swidths i get put
        checkwidths i 2 mul 1 add bwidths i get put
    } for
    
    /sbs [
        1 d1w {} forall checkwidths {} forall d2w {} forall 1 1
    ] def
    
    % Return the arguments
    <<
    /ren (renlinear)
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER rsslimited--

% --BEGIN ENCODER rssexpanded--
% --DESC: GS1 DataBar Expanded
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: segments=4
% --RNDR: renlinear renmatrix
/rssexpanded {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 34 72 div def
    /segments 22 def
    /linkage false def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /segments segments cvi def
    
    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        }  ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop
    
    % Method selection
    {  % common exit
    
        % (01)9...(3103)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3103) eq and { 
                aival (01) get 0 1 getinterval (9) eq aival (3103) get cvi 32767 le and {
                   (0100) false exit 
                } if
            } if
        } if
    
        % (01)9...(3202)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3202) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3202) get cvi 9999 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(3203)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3203) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3203) get cvi 22767 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(310x/320x)...[(11/13/15/17)...]
        ais length dup 2 eq exch 3 eq or {
           /ai310x false 3100 1 3109 {10 4 string cvrs ais 1 get eq or} for def
           /ai320x false 3200 1 3209 {10 4 string cvrs ais 1 get eq or} for def
           ais length 3 eq {
               /aibad true [ (11) (13) (15) (17) ] {ais 2 get ne and} forall def
           } {
               /aibad false def
           } ifelse
           ais 0 get (01) eq ai310x ai320x or and aibad not and {
               ais length 3 eq {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and 
                   aival ais 2 get get cvi 999999 le and {
                       ai310x ais 2 get (11) eq and { (0111000) false exit } if
                       ai320x ais 2 get (11) eq and { (0111001) false exit } if
                       ai310x ais 2 get (13) eq and { (0111010) false exit } if
                       ai320x ais 2 get (13) eq and { (0111011) false exit } if
                       ai310x ais 2 get (15) eq and { (0111100) false exit } if
                       ai320x ais 2 get (15) eq and { (0111101) false exit } if
                       ai310x ais 2 get (17) eq and { (0111110) false exit } if
                       ai320x ais 2 get (17) eq and { (0111111) false exit } if
                   } if
               } {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and {
                       ai310x { (0111000) false exit } if
                       ai320x { (0111001) false exit } if
                   } if
               } ifelse
           } if
        } if
    
        % (01)9...(392x)...
        ais length 2 ge {
            /ai392x false 3920 1 3923 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai392x and {
                aival (01) get 0 1 getinterval (9) eq { (01100) true exit } if
            } if
        } if
    
        % (01)9...(393x)...
        ais length 2 ge {
            /ai393x false 3930 1 3933 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai393x and {
                aival (01) get 0 1 getinterval (9) eq { (01101) true exit } if
            } if
        } if
    
        % (01)...
        ais 0 get (01) eq { (1) true exit } if
    
        % Freeform
        (00) true exit
    
    } loop
    /gpfallow exch def
    /method exch def
   
    /conv12to40 {
        (0000000000000000000000000000000000000000) 40 string copy
        2 copy  0 10 getinterval exch 0 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 10 10 getinterval exch 3 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 20 10 getinterval exch 6 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 30 10 getinterval exch 9 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        exch pop
    } bind def
    
    /conv13to44 {
        (00000000000000000000000000000000000000000000) 44 string copy
        2 copy 0 4 getinterval exch 0 1 getinterval cvi 2 4 string cvrs dup length 4 exch sub exch putinterval
        dup 3 -1 roll 1 12 getinterval conv12to40 4 exch putinterval
    } bind def
    
    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
    } bind def
    
    method (00) eq {
        /cdf [] def
        /gpf [] def
    } if
    
    method (1) eq {
        /cdf aival (01) get 0 13 getinterval conv13to44 def
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais ais 1 ais length 1 sub getinterval def
    } if
    
    method (0100) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 aival (3103) get cvi 15 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (0101) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        ais 1 get (3202) eq {
            aival (3202) get cvi 15 tobin
        } {
            aival (3203) get cvi 10000 add 15 tobin
        } ifelse
        cdf exch 40 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method length 7 eq {
        /cdf 76 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        6 string dup 0 ais 1 get 3 1 getinterval putinterval
        dup aival ais 1 get get 1 5 getinterval 1 exch putinterval cvi 20 tobin
        cdf exch 40 exch putinterval
        ais length 3 eq {
            aival ais 2 get get
            dup 0 2 getinterval cvi 384 mul exch
            dup 2 2 getinterval cvi 1 sub 32 mul exch
            4 2 getinterval cvi add add 
        } {
            38400
        } ifelse
        16 tobin cdf exch 60 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (01100) eq {
        /cdf 42 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    method (01101) eq {
        /cdf 52 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        cdf 42 aival ais 1 get get 0 3 getinterval cvi 10 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get dup length 3 sub 3 exch getinterval {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    % Variable length symbol field
    gpfallow {
        /vlf 2 array def
    } {
        /vlf [] def
    } ifelse
    
    % FNC1 terminated AIs
    % TODO this list seems wrong
    /aifnc1 100 dict def
    [
        10
        21    22
        240   241   242
        250   251   253   254
        30    37
        3900 1 3909 {} for
        3910 1 3919 {} for
        3920 1 3929 {} for
        3930 1 3939 {} for
        400   401   402   403
        420   421   422   423   424   425   426
        7001  7002  7003
        7030 1 7039 {} for
        8001  8002  8003  8004  8005  8006  8007  8008
        8018  8020
        8100  8101  8102
        8110
        90 1 99 {} for
    ] {
        10 4 string cvrs dup aifnc1 3 1 roll put
    } forall
    
    /fnc1 -1 def /lnumeric -2 def /lalpha -3 def /liso646 -4 def
    
    /numeric <<
        0 1 119 {
            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs
            dup length 2 exch sub exch putinterval 
            dup 0 get 65 eq {dup 0 94 put} if 
            dup 1 get 65 eq {dup 1 94 put} if 
            exch 8 add
            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs 
            dup length 7 exch sub exch putinterval
        } for
        lalpha (0000)
    >> def
    
    /alpha <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 33 sub 6 tobin} for
        42 (111010)
        44 1 47 {dup 15 add 6 tobin} for
        lnumeric (000)
        liso646 (00100)
    >> def
    
    /iso646 <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 1 sub 7 tobin} for
        97 1 122 {dup 7 sub 7 tobin} for
        33 (11101000)
        34 (11101001)
        37 1 47 {dup 197 add 8 tobin} for
        58 1 63 {dup 187 add 8 tobin} for
        95 (11111011)
        32 (11111100)
        lnumeric (000)
        lalpha (00100)
    >> def
    
    % Append the remaining AI data
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        gpf length ai length add val length add array
        dup 0 gpf putinterval
        dup gpf length ai [ exch {} forall ] putinterval
        dup gpf length ai length add val [ exch {} forall ] putinterval
        /gpf exch def
        i ais length 1 sub ne aifnc1 ai known and {  % Append FNC1
            gpf length 1 add array
            dup 0 gpf putinterval
            dup gpf length fnc1 put
            /gpf exch def
        } if
    } for
    
    % Calculate the number of bits remaining to the next valid symbol size
    /rembits {
        dup
        12 div ceiling cvi 12 mul            % Round up to multiple of 12 
        48 2 copy lt {exch} if pop           % At least 4 symbols
        dup 12 idiv dup segments mod 1 eq {  % At least 2 symbols on last row of stacked symbol
            1 add 12 mul exch pop
        } {
            pop
        } ifelse 
        exch sub
    } bind def
    
    /encode {
        dup /raw ne {exch get} {pop} ifelse
        [ exch {48 sub} forall ]
        dup length exch
        gpfenc exch j exch putinterval
        /j exch j add def
    } bind def
   
    % Pre-compute alpha and numeric runlengths and position of next ISO646-only characters
    /numericruns [ gpf length {0} repeat 0 -1 ] def
    /alpharuns [ gpf length {0} repeat 0 ] def
    /nextiso646only [ gpf length {0} repeat 9999 ] def
    gpf length 1 sub -1 0 {
        /i exch def
        gpf i get
        (00) 2 string copy
        dup 0 gpf i get dup fnc1 eq {pop 94} if put 
        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if
        numeric exch known {
            numericruns i numericruns i 2 add get 2 add put
        } {
            numericruns i 0 put
        } ifelse
        dup alpha exch known {
            alpharuns i alpharuns i 1 add get 1 add put
        } {
            alpharuns i 0 put
        } ifelse
        dup iso646 exch known exch alpha exch known not and {
            nextiso646only i 0 put
        } {
            nextiso646only i nextiso646only i 1 add get 1 add put
        } ifelse
    } for
   
    % Encode the general purpose field
    /gpfenc 252 array def
    /i 0 def /j 0 def /mode (numeric) def
    {  % loop
        i gpf length eq {exit} if
        {  % not a loop but common exit point
    
            mode (numeric) eq {
                i gpf length 2 sub lt {
                    2 string 
                    dup 0 gpf i get dup fnc1 eq {pop 94} if put
                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put
                    dup numeric exch known {
                        numeric encode
                        /i i 2 add def
                        exit
                    } if
                    pop
                    lalpha numeric encode 
                    /mode (alpha) def
                    exit
                } {
                    gpf i get dup 48 lt exch 57 gt or {
                        lalpha numeric encode
                        /mode (alpha) def
                        exit
                    } if
                    12 1 add method length add vlf length add cdf length add j add rembits 
                    dup 4 ge exch 6 le and {  % C1 + 1 into 4 bits
                        (0000) 4 string copy dup gpf i get 47 sub 2 4 string cvrs
                        dup length 4 exch sub exch putinterval /raw encode
                        /i i 1 add def
                        exit
                    } {  % C1.FNC1
                        2 string dup 0 gpf i get put dup 1 94 put numeric encode 
                        /i i 1 add def
                        exit
                    } ifelse
                } ifelse
            } if
    
            mode (alpha) eq {
                gpf i get fnc1 eq {
                    fnc1 alpha encode
                    /i i 1 add def
                    exit
                } if
                gpf i get dup iso646 exch known exch alpha exch known not and {
                     liso646 alpha encode
                     /mode (iso646) def
                     exit
                } if
                numericruns i get 6 ge {
                    lnumeric alpha encode
                    /mode (numeric) def
                    exit
                } if
                numericruns i get dup 4 ge exch i add gpf length eq and {
                    lnumeric alpha encode
                    /mode (numeric) def
                    exit
                } if
                gpf i get alpha encode
                /i i 1 add def
                exit
            } if
    
            mode (iso646) eq {
                gpf i get fnc1 eq {
                    fnc1 iso646 encode
                    /i i 1 add def
                    exit
                } if
                numericruns i get 4 ge nextiso646only i get 10 ge and {
                    lnumeric iso646 encode
                    /mode (numeric) def
                    exit
                } if
                alpharuns i get 5 ge nextiso646only i get 10 ge and {
                    lalpha iso646 encode
                    /mode (alpha) def
                    exit
                } if
                gpf i get iso646 encode
                /i i 1 add def
                exit
            } if
    
        } loop
    } loop
    /gpf gpfenc 0 j getinterval def
   
    % Complete the variable length field and create pad
    1 12 add method length add vlf length add cdf length add gpf length add 
    dup rembits dup array /pad exch def
    vlf length 0 ne {
        add 12 idiv
        dup 2 mod vlf exch 0 exch put
        14 le {0} {1} ifelse vlf exch 1 exch put
    } {
        pop pop
    } ifelse
    pad length 0 gt {
        0 5 pad length 1 sub {  % Fill with 00100
            /i exch def
            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval 
        } for 
        mode (numeric) eq {  % Prefix shift from numeric to ASCII
            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def
        } if
    } if
   
    % Concatinate fields
    /binval [
        linkage {1} {0} ifelse 
        method {48 sub} forall
        vlf aload pop
        cdf aload pop
        gpf aload pop
        pad aload pop
    ] def
    /datalen binval length 12 idiv def
    
    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def

    /tab174 [
        347   0     12 5   7 2  87  4
        1387  348   10 7   5 4  52  20
        2947  1388  8  9   4 5  30  52
        3987  2948  6  11  3 6  10  104
        4191  3988  4  13  1 8  1   204
    ] def

    /dxw datalen array def
    
    0 1 datalen 1 sub {

        /x exch def

        /d binval x 12 mul 12 getinterval def
        /d 0 0 1 11 {/j exch def 2 11 j sub exp cvi d j get mul add} for def

        /j 0 def {
            d tab174 j get le {
                tab174 j 1 add 7 getinterval {} forall
                /dte exch def /dto exch def
                /dmwe exch def /dmwo exch def
                /dele exch def /delo exch def
                /dgs exch def
                exit
            } if
            /j j 8 add def
        } loop

        /dwo d dgs sub dte idiv delo dmwo 4 true  getRSSwidths def
        /dwe d dgs sub dte mod  dele dmwe 4 false getRSSwidths def

        /dw 8 array def        
        x 2 mod 0 eq {                    
            0 1 3 {
                /j exch def
                dw 7 j 2 mul sub dwo j get put
                dw 6 j 2 mul sub dwe j get put
            } for
        } {           
            0 1 3 {
                /j exch def
                dw j 2 mul dwo j get put
                dw j 2 mul 1 add dwe j get put
            } for
        } ifelse

        dxw x dw put

    } for
    
    /finderwidths [
        1 8 4 1 1    1 1 4 8 1
        3 6 4 1 1    1 1 4 6 3
        3 4 6 1 1    1 1 6 4 3
        3 2 8 1 1    1 1 8 2 3
        2 6 5 1 1    1 1 5 6 2
        2 2 9 1 1    1 1 9 2 2
    ] def

    /finderseq [
        [0 1]
        [0 3 2]
        [0 5 2 7]
        [0 9 2 7 4]
        [0 9 2 7 6 11]
        [0 9 2 7 8 11 10]
        [0 1 2 3 4 5 6 7]
        [0 1 2 3 4 5 6 9 8]
        [0 1 2 3 4 5 6 9 10 11]
        [0 1 2 3 4 7 6 9 8 11 10]
    ] def

    /seq finderseq datalen 2 sub 2 idiv get def
    /fxw seq length array def
    0 1 seq length 1 sub {
        /x exch def
        fxw x finderwidths seq x get 5 mul 5 getinterval put
    } for

    /checkweights [
        -1   -1   -1   -1   -1   -1   -1   -1   % A1L
        77   96   32   81   27   9    3    1    % A1R
        20   60   180  118  143  7    21   63   % A2L
        205  209  140  117  39   13   145  189  % A2R
        193  157  49   147  19   57   171  91   % B1L 
        132  44   85   169  197  136  186  62   % B1R
        185  133  188  142  4    12   36   108  % B2L
        50   87   29   80   97   173  128  113  % B2R
        150  28   84   41   123  158  52   156  % C1L
        166  196  206  139  187  203  138  46   % C1R
        76   17   51   153  37   111  122  155  % C2L
        146  119  110  107  106  176  129  43   % C2R
        16   48   144  10   30   90   59   177  % D1L
        164  125  112  178  200  137  116  109  % D1R
        70   210  208  202  184  130  179  115  % D2L
        190  204  68   93   31   151  191  134  % D2R
        148  22   66   198  172  94   71   2    % E1L
        40   154  192  64   162  54   18   6    % E1R
        120  149  25   75   14   42   126  167  % E2L
        175  199  207  69   23   78   26   79   % E2R
        103  98   83   38   114  131  182  124  % F1L
        159  53   88   170  127  183  61   161  % F1R
        55   165  73   8    24   72   5    15   % F2L
        89   100  174  58   160  194  135  45   % F2R
    ] def

    /checkweightseq [
       seq {16 mul checkweights exch 16 getinterval aload pop} forall
    ] dup length 8 sub 8 exch getinterval def

    /widths [
        dxw {{} forall} forall
    ] def
   
    /checksum 0 def
    0 1 widths length 1 sub {
        /i exch def
        /checksum checksum widths i get checkweightseq i get mul add def 
    } for
    /checksum checksum 211 mod datalen 3 sub 211 mul add def

    /i 0 def {
        checksum tab174 i get le {
            tab174 i 1 add 7 getinterval {} forall
            /cte exch def /cto exch def
            /cmwe exch def /cmwo exch def
            /cele exch def /celo exch def
            /cgs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /cwo checksum cgs sub cte idiv celo cmwo 4 true  getRSSwidths def
    /cwe checksum cgs sub cte mod  cele cmwe 4 false getRSSwidths def

    /cw 8 array def        
    0 1 3 {
        /i exch def
        cw i 2 mul cwo i get put
        cw i 2 mul 1 add cwe i get put
    } for

    22 array dup dup
    0 cw put 1 dxw putinterval 0 datalen 1 add getinterval
    /dxw exch def
    /datalen dxw length def

    % Encode row runlengths
    /rows datalen segments div ceiling cvi array def
    /numrows rows length def
    0 1 numrows 1 sub {
        /r exch def
        mark
        segments 4 mod 0 ne r 2 mod 1 eq and {0} if
        1 1
        0 1 segments 1 sub {
            /pos exch r segments mul add def
            pos datalen lt {
                dxw pos get {} forall                 
                pos 2 mod 0 eq {fxw pos 2 idiv get {} forall} if
            } if
        } for
        1 1
        counttomark array astore rows exch r exch put pop
    } for

    numrows 1 eq {  % Linear

        % Remove leading space
        /sbs rows 0 get dup length 1 sub 1 exch getinterval def

        /sbs [
            1
            0 1 datalen 1 sub {
                /i exch def
                dxw i get {} forall
                i 2 mod 0 eq {fxw i 2 idiv get {} forall} if
            } for
            1 1
        ] def

        <<
        /ren (renlinear)
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /opt options
        >>

        dontdraw not //renlinear if

    } {  % 2D - stacked

        /seps numrows array def
        0 1 numrows 1 sub {

            /r exch def
            /row rows r get def

            % Sample runlengths into bitmap
            mark
            0 2 row length 1 sub {
                /i exch def
                row i get {0} repeat
                i row length 1 sub lt {row i 1 add get {1} repeat} if
            } for
            counttomark array astore /row exch def pop

            % Derive the separator pattern
            /sep [ row {1 exch sub} forall ] def
            sep 0 [ 0 0 0 0 ] putinterval
            sep row length 4 sub [ 0 0 0 0 ] putinterval
            /finderpos [  % Finder pattern module positions
                19 98 row length 13 sub {} for
                68 98 row length 13 sub {} for
            ] def 
            finderpos {
                dup 14 add 1 exch {
                    /i exch def
                    row i get 0 eq {
                        row i 1 sub get 1 eq {
                            1
                        } {
                            sep i 1 sub get 0 eq {1} {0} ifelse
                        } ifelse
                    } {
                        0
                    } ifelse
                    sep exch i exch put
                } for
            } forall

            % For even segment-pair symbols reverse alternate rows
            segments 4 mod 0 eq r 2 mod 1 eq and {
                rows r get length rows 0 get length ne  % Except partial width last row
                finderpos length 2 mod 1 eq and {       % with odd finders
                    /row [ 0 row aload pop ] def
                    /sep [ 0 sep aload pop ] def
                } {
                    row length 1 sub -1 0 {row exch get} for
                    row astore pop
                    sep length 1 sub -1 0 {sep exch get} for
                    sep astore pop
                } ifelse
            } if

            rows r row put
            seps r sep put

        } for

        % Extend last row and separator to fill width of symbol
        /pixx rows 0 get length def
        [ pixx {0} repeat ] dup 0 rows numrows 1 sub get putinterval
        rows exch numrows 1 sub exch put 
        [ pixx {0} repeat ] dup 0 seps numrows 1 sub get putinterval
        seps exch numrows 1 sub exch put 

        % Middle separator pattern
        /sep [ pixx 2 idiv 1 add { 0 1 } repeat ] 0 pixx getinterval def
        sep 0 [0 0 0 0] putinterval
        sep pixx 4 sub [0 0 0 0] putinterval

        % Compose the symbol
        /pixs [
            0 1 numrows 1 sub {
                /r exch def
                r 0 ne {
                    seps r get aload pop
                } if
                34 {rows r get aload pop} repeat
                r numrows 1 sub ne {
                    seps r get aload pop
                    sep aload pop
                } if
            } for
        ] def

        <<
        /ren (renmatrix)
        /pixs pixs
        /pixx pixx
        /pixy pixs length pixx idiv
        /height pixs length pixx idiv 72 div
        /width pixx 72 div
        /opt options
        >>

        dontdraw not //renmatrix if

    } ifelse

    end

} bind def
% --END ENCODER rssexpanded--

% --BEGIN ENCODER pharmacode--
% --DESC: Pharmaceutical Binary Code
% --EXAM: 117480
% --EXOP: showborder
% --RNDR: renlinear
/pharmacode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /height 8 2.835 mul 72 div def
    /nwidth 0.5 2.835 mul def
    /wwidth 1.5 2.835 mul def
    /swidth 1.0 2.835 mul def    

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /nwidth nwidth cvr def
    /wwidth wwidth cvr def
    /swidth swidth cvr def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    % Convert the integer into the paramacode string 
    /barcode barcode cvi 1 add 2 17 string cvrs def
    /barcode barcode 1 barcode length 1 sub getinterval def

    /barlen barcode length def  % Length of the code
    /sbs barlen 2 mul array def

    0 1 barlen 1 sub {
        /i exch def
        /enc barcode i 1 getinterval def
        enc (0) eq {
            sbs i 2 mul nwidth put
        } {
            sbs i 2 mul wwidth put
        } ifelse
        sbs i 2 mul 1 add swidth put
    } for

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER pharmacode--

% --BEGIN ENCODER code2of5--
% --DESC: Code 25
% --EXAM: 01234567
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/code2of5 {

    20 dict begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (1111313111) (3111111131) (1131111131) (3131111111)
      (1111311131) (3111311111) (1131311111) (1111113131)
      (3111113111) (1131113111) (313111) (311131)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def            % Length of the code

    includecheck {
        /sbs barlen 10 mul 22 add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen 10 mul 12 add string def
        /txt barlen array def
    } ifelse
    
    % Put the start character
    sbs 0 encs 10 get putinterval

    /checksum 0 def
    
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i 10 mul 6 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 14 mul 10 add textyoffset textfont textsize] put
        barlen i sub 2 mod 0 eq {
            /checksum checksum indx add def
        } {            
            /checksum checksum indx 3 mul add def
        } ifelse        
    } for
    
    % Put the checksum and end characters
    includecheck {
        /checksum 10 checksum 10 mod sub 10 mod def
        sbs barlen 10 mul 6 add encs checksum get putinterval
        sbs barlen 10 mul 16 add encs 11 get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen 14 mul 10 add textyoffset textfont textsize] put
        } {            
            txt barlen [( ) barlen 14 mul 10 add textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen 10 mul 6 add encs 11 get putinterval
    } ifelse
    
    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER code2of5--

% --BEGIN ENCODER code11--
% --DESC: Code 11
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/code11 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /includetext false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (111131) (311131) (131131) (331111) (113131)
      (313111) (133111) (111331) (311311) (311111)
      (113111) (113311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-) def

    /barlen barcode length def        % Length of the code

    includecheck {
        barlen 10 ge {
            /sbs barlen 6 mul 24 add string def
            /txt barlen 2 add array def
        } {
            /sbs barlen 6 mul 18 add string def
            /txt barlen 1 add array def
        } ifelse
    } {
        /sbs barlen 6 mul 12 add string def
        /txt barlen array def
    } ifelse

    % Put the start character
    sbs 0 encs 11 get putinterval

    /checksum1 0 def /checksum2 0 def
    
    /xpos 8 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 6 mul 6 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 5 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum1 checksum1 barlen i sub 1 sub 10 mod 1 add indx mul add def
        /checksum2 checksum2 barlen i sub 9 mod 1 add indx mul add def
    } for
   
    % Put the checksum and end characters
    includecheck {
        /checksum1 checksum1 11 mod def        
        barlen 10 ge {
            /checksum2 checksum2 checksum1 add 11 mod def
            sbs barlen 6 mul 6 add encs checksum1 get putinterval        
            sbs barlen 6 mul 12 add encs checksum2 get putinterval
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
                /enc encs checksum1 get def   
                0 1 5 {       % xpos+=width of the character
                    /xpos exch enc exch get 48 sub xpos add def
                } for
                txt barlen 1 add [barchars checksum2 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
                txt barlen 1 add [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 18 add encs 11 get putinterval
        } {
            sbs barlen 6 mul 6 add encs checksum1 get putinterval          
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 12 add encs 11 get putinterval
        } ifelse
    } {
        sbs barlen 6 mul 6 add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER code11--

% --BEGIN ENCODER rationalizedCodabar--
% --DESC: Rationalized Codabar
% --EXAM: A0123456789B
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/rationalizedCodabar {

    20 dict begin                    % Confine variables to local scope

    /options exch def          % We are given an option string
    /barcode exch def          % We are given a barcode string

    /dontdraw false def
    /includecheck false def     % Enable/disable checkdigit
    /includetext false def      % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (11111331) (11113311) (11131131) (33111111) (11311311)
      (31111311) (13111131) (13113111) (13311111) (31131111)
      (11133111) (11331111) (31113131) (31311131) (31313111)
      (11313131) (11331311) (13131131) (11131331) (11133311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-$:/.+ABCD) def

    /barlen barcode length def    % Length of the code

    includecheck {
        /sbs barlen 8 mul 8 add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen 8 mul string def
        /txt barlen array def
    } ifelse

    /checksum 0 def
    /xpos 0 def
    0 1 barlen 2 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                          % Discard true leaving pre
        length /indx exch def        % indx is the length of pre
        pop pop                      % Discard seek and post
        /enc encs indx get def       % Get the indxth encoding
        sbs i 8 mul enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 7 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum checksum indx add def
    } for

    % Find index of last character
    barcode barlen 1 sub 1 getinterval barchars exch search
    pop                          % Discard true leaving pre
    length /indx exch def        % indx is the length of pre
    pop pop                      % Discard seek and post

    includecheck {
        % Put the checksum character
        /checksum checksum indx add def
        /checksum 16 checksum 16 mod sub 16 mod def
        sbs barlen 8 mul 8 sub encs checksum get putinterval
        includecheckintext {
            txt barlen 1 sub [barchars checksum 1 getinterval xpos textyoffset textfont textsize] put
        } {
            txt barlen 1 sub [( ) xpos textyoffset textfont textsize] put
        } ifelse
        0 1 7 {       % xpos+=width of the character
            /xpos exch encs checksum get exch get 48 sub xpos add def
        } for
        % Put the end character
        /enc encs indx get def            % Get the indxth encoding
        sbs barlen 8 mul enc putinterval  % Put encoded digit into sbs
        txt barlen [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } {
        % Put the end character
        /enc encs indx get def                  % Get the indxth encoding
        sbs barlen 8 mul 8 sub enc putinterval  % Put encoded digit into sbs
        txt barlen 1 sub [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } ifelse

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER rationalizedCodabar--

% --BEGIN ENCODER onecode--
% --DESC: United States Postal Service OneCode
% --EXAM: 0123456709498765432101234567891
% --EXOP: barcolor=FF0000
% --RNDR: renlinear
/onecode {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /height 0.15 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def

    /barlen barcode length def
 
    % Create the human readable text
    /txtdict <<
        2 dup
        5 dup
        barcode 5 1 getinterval (9) eq {14} {11} ifelse dup
        20 dup
        25 dup
        29 dup
    >> def
    /txt barlen 6 add array def
    /spacecnt 0 def
    0 1 barlen 1 sub {
        /i exch def
        txtdict i known {
            txt i spacecnt add [( ) 0 0 () 0] put
            /spacecnt spacecnt 1 add def
        } if
        txt i spacecnt add [barcode i 1 getinterval 0 0 () 0] put
    } for
    /txt txt 0 barcode length spacecnt add getinterval def

    /normalize {
        /base exch def
        /num exch def
        num length 1 sub -1 1 {
            /i exch def        
            num i 1 sub 2 copy get num i get base idiv add put
            num i num i get base mod put
        } for
        { %loop - extend input as necessary
            num 0 get base lt {exit} if
            /num [0 num {} forall] def        
            num 0 num 0 get num 1 get base idiv add put
            num 1 num 1 get base mod put
        } loop
        % Trim leading zeros
        /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def   
        num length 0 eq {/num [0] def} if
        num
    } bind def

    /bigadd {
        2 copy length exch length
        2 copy sub abs /offset exch def
        lt {exch} if
        /a exch def /b exch def    
        0 1 b length 1 sub {
            dup a exch offset add 2 copy get b 5 -1 roll get add put
        } for
        a
    } bind def

    % Conversion of data fields into binary data
    barlen 20 eq {[0]} if
    barlen 25 eq {[1]} if
    barlen 29 eq {[1 0 0 0 0 1]} if
    barlen 31 eq {[1 0 0 0 1 0 0 0 0 1]} if
    /binval exch [barcode 20 barlen 20 sub getinterval {48 sub} forall] bigadd def
    /binval [binval {} forall barcode 0 get 48 sub] def
    /binval [binval {5 mul} forall] [barcode 1 get 48 sub] bigadd 10 normalize def
    /binval [binval {} forall barcode 2 18 getinterval {48 sub} forall] def

    % Conversion of binary data into byte array
    /bytes 13 array def
    /bintmp [binval {} forall] def
    12 -1 0 {
        /i exch def
        0 1 bintmp length 2 sub {
            /j exch def
            bintmp j 1 add 2 copy get bintmp j get 256 mod 10 mul add put
            bintmp j bintmp j get 256 idiv put
        } for
        bytes i bintmp bintmp length 1 sub get 256 mod put
        bintmp bintmp length 1 sub 2 copy get 256 idiv put    
    } for

    % Generation of 11-bit CRC on byte array
    /fcs 2047 def
    /dat bytes 0 get 5 bitshift def
    6 {
        fcs dat xor 1024 and 0 ne {
            /fcs fcs 1 bitshift 3893 xor def 
        } {
            /fcs fcs 1 bitshift def
        } ifelse
        /fcs fcs 2047 and def
        /dat dat 1 bitshift def
    } repeat
    1 1 12 {
        bytes exch get 3 bitshift /dat exch def    
        8 {        
            fcs dat xor 1024 and 0 ne {
                /fcs fcs 1 bitshift 3893 xor def 
            } {
                /fcs fcs 1 bitshift def
            } ifelse
            /fcs fcs 2047 and def
            /dat dat 1 bitshift def
        } repeat
    } for

    % Conversion from binary data to codewords
    /codewords 10 array def
    9 -1 0 {
        /i exch def
        i 9 eq {
            /b 636 def
        } {
            /b 1365 def
        } ifelse
        0 1 binval length 2 sub {
            /j exch def
            binval j 1 add 2 copy get binval j get b mod 10 mul add put
            binval j binval j get b idiv put
        } for   
        codewords i binval binval length 1 sub get b mod put
        binval binval length 1 sub 2 copy get b idiv put
    } for

    % Inserting additional information into codewords
    codewords 9 codewords 9 get 2 mul put
    fcs 1024 and 0 ne {
        codewords 0 codewords 0 get 659 add put
    } if

    % Conversion from codewords to characters
    /tab513 [
        31 7936   47 7808   55 7552   59 7040   61 6016   62 3968   79 7744   87 
      7488   91 6976   93 5952   94 3904  103 7360  107 6848  109 5824  110 3776 
       115 6592  117 5568  118 3520  121 5056  122 3008  124 1984  143 7712  151 
      7456  155 6944  157 5920  158 3872  167 7328  171 6816  173 5792  174 3744 
       179 6560  181 5536  182 3488  185 5024  186 2976  188 1952  199 7264  203 
      6752  205 5728  206 3680  211 6496  213 5472  214 3424  217 4960  218 2912 
       220 1888  227 6368  229 5344  230 3296  233 4832  234 2784  236 1760  241 
      4576  242 2528  244 1504  248  992  271 7696  279 7440  283 6928  285 5904 
       286 3856  295 7312  299 6800  301 5776  302 3728  307 6544  309 5520  310 
      3472  313 5008  314 2960  316 1936  327 7248  331 6736  333 5712  334 3664 
       339 6480  341 5456  342 3408  345 4944  346 2896  348 1872  355 6352  357 
      5328  358 3280  361 4816  362 2768  364 1744  369 4560  370 2512  372 1488 
       376  976  391 7216  395 6704  397 5680  398 3632  403 6448  405 5424  406 
      3376  409 4912  410 2864  412 1840  419 6320  421 5296  422 3248  425 4784 
       426 2736  428 1712  433 4528  434 2480  436 1456  440  944  451 6256  453 
      5232  454 3184  457 4720  458 2672  460 1648  465 4464  466 2416  468 1392 
       472  880  481 4336  482 2288  484 1264  488  752  527 7688  535 7432  539 
      6920  541 5896  542 3848  551 7304  555 6792  557 5768  558 3720  563 6536 
       565 5512  566 3464  569 5000  570 2952  572 1928  583 7240  587 6728  589 
      5704  590 3656  595 6472  597 5448  598 3400  601 4936  602 2888  604 1864 
       611 6344  613 5320  614 3272  617 4808  618 2760  620 1736  625 4552  626 
      2504  628 1480  632  968  647 7208  651 6696  653 5672  654 3624  659 6440 
       661 5416  662 3368  665 4904  666 2856  668 1832  675 6312  677 5288  678 
      3240  681 4776  682 2728  684 1704  689 4520  690 2472  692 1448  696  936 
       707 6248  709 5224  710 3176  713 4712  714 2664  716 1640  721 4456  722 
      2408  724 1384  728  872  737 4328  738 2280  740 1256  775 7192  779 6680 
       781 5656  782 3608  787 6424  789 5400  790 3352  793 4888  794 2840  796 
      1816  803 6296  805 5272  806 3224  809 4760  810 2712  812 1688  817 4504 
       818 2456  820 1432  824  920  835 6232  837 5208  838 3160  841 4696  842 
      2648  844 1624  849 4440  850 2392  852 1368  865 4312  866 2264  868 1240 
       899 6200  901 5176  902 3128  905 4664  906 2616  908 1592  913 4408  914 
      2360  916 1336  929 4280  930 2232  932 1208  961 4216  962 2168  964 1144 
      1039 7684 1047 7428 1051 6916 1053 5892 1054 3844 1063 7300 1067 6788 1069 
      5764 1070 3716 1075 6532 1077 5508 1078 3460 1081 4996 1082 2948 1084 1924 
      1095 7236 1099 6724 1101 5700 1102 3652 1107 6468 1109 5444 1110 3396 1113 
      4932 1114 2884 1116 1860 1123 6340 1125 5316 1126 3268 1129 4804 1130 2756 
      1132 1732 1137 4548 1138 2500 1140 1476 1159 7204 1163 6692 1165 5668 1166 
      3620 1171 6436 1173 5412 1174 3364 1177 4900 1178 2852 1180 1828 1187 6308 
      1189 5284 1190 3236 1193 4772 1194 2724 1196 1700 1201 4516 1202 2468 1204 
      1444 1219 6244 1221 5220 1222 3172 1225 4708 1226 2660 1228 1636 1233 4452 
      1234 2404 1236 1380 1249 4324 1250 2276 1287 7188 1291 6676 1293 5652 1294 
      3604 1299 6420 1301 5396 1302 3348 1305 4884 1306 2836 1308 1812 1315 6292 
      1317 5268 1318 3220 1321 4756 1322 2708 1324 1684 1329 4500 1330 2452 1332 
      1428 1347 6228 1349 5204 1350 3156 1353 4692 1354 2644 1356 1620 1361 4436 
      1362 2388 1377 4308 1378 2260 1411 6196 1413 5172 1414 3124 1417 4660 1418 
      2612 1420 1588 1425 4404 1426 2356 1441 4276 1442 2228 1473 4212 1474 2164 
      1543 7180 1547 6668 1549 5644 1550 3596 1555 6412 1557 5388 1558 3340 1561 
      4876 1562 2828 1564 1804 1571 6284 1573 5260 1574 3212 1577 4748 1578 2700 
      1580 1676 1585 4492 1586 2444 1603 6220 1605 5196 1606 3148 1609 4684 1610 
      2636 1617 4428 1618 2380 1633 4300 1634 2252 1667 6188 1669 5164 1670 3116 
      1673 4652 1674 2604 1681 4396 1682 2348 1697 4268 1698 2220 1729 4204 1730 
      2156 1795 6172 1797 5148 1798 3100 1801 4636 1802 2588 1809 4380 1810 2332 
      1825 4252 1826 2204 1857 4188 1858 2140 1921 4156 1922 2108 2063 7682 2071 
      7426 2075 6914 2077 5890 2078 3842 2087 7298 2091 6786 2093 5762 2094 3714 
      2099 6530 2101 5506 2102 3458 2105 4994 2106 2946 2119 7234 2123 6722 2125 
      5698 2126 3650 2131 6466 2133 5442 2134 3394 2137 4930 2138 2882 2147 6338 
      2149 5314 2150 3266 2153 4802 2154 2754 2161 4546 2162 2498 2183 7202 2187 
      6690 2189 5666 2190 3618 2195 6434 2197 5410 2198 3362 2201 4898 2202 2850 
      2211 6306 2213 5282 2214 3234 2217 4770 2218 2722 2225 4514 2226 2466 2243 
      6242 2245 5218 2246 3170 2249 4706 2250 2658 2257 4450 2258 2402 2273 4322 
      2311 7186 2315 6674 2317 5650 2318 3602 2323 6418 2325 5394 2326 3346 2329 
      4882 2330 2834 2339 6290 2341 5266 2342 3218 2345 4754 2346 2706 2353 4498 
      2354 2450 2371 6226 2373 5202 2374 3154 2377 4690 2378 2642 2385 4434 2401 
      4306 2435 6194 2437 5170 2438 3122 2441 4658 2442 2610 2449 4402 2465 4274 
      2497 4210 2567 7178 2571 6666 2573 5642 2574 3594 2579 6410 2581 5386 2582 
      3338 2585 4874 2586 2826 2595 6282 2597 5258 2598 3210 2601 4746 2602 2698 
      2609 4490 2627 6218 2629 5194 2630 3146 2633 4682 2641 4426 2657 4298 2691 
      6186 2693 5162 2694 3114 2697 4650 2705 4394 2721 4266 2753 4202 2819 6170 
      2821 5146 2822 3098 2825 4634 2833 4378 2849 4250 2881 4186 2945 4154 3079 
      7174 3083 6662 3085 5638 3086 3590 3091 6406 3093 5382 3094 3334 3097 4870 
      3107 6278 3109 5254 3110 3206 3113 4742 3121 4486 3139 6214 3141 5190 3145 
      4678 3153 4422 3169 4294 3203 6182 3205 5158 3209 4646 3217 4390 3233 4262 
      3265 4198 3331 6166 3333 5142 3337 4630 3345 4374 3361 4246 3393 4182 3457 
      4150 3587 6158 3589 5134 3593 4622 3601 4366 3617 4238 3649 4174 3713 4142 
      3841 4126 4111 7681 4119 7425 4123 6913 4125 5889 4135 7297 4139 6785 4141 
      5761 4147 6529 4149 5505 4153 4993 4167 7233 4171 6721 4173 5697 4179 6465 
      4181 5441 4185 4929 4195 6337 4197 5313 4201 4801 4209 4545 4231 7201 4235 
      6689 4237 5665 4243 6433 4245 5409 4249 4897 4259 6305 4261 5281 4265 4769 
      4273 4513 4291 6241 4293 5217 4297 4705 4305 4449 4359 7185 4363 6673 4365 
      5649 4371 6417 4373 5393 4377 4881 4387 6289 4389 5265 4393 4753 4401 4497 
      4419 6225 4421 5201 4425 4689 4483 6193 4485 5169 4489 4657 4615 7177 4619 
      6665 4621 5641 4627 6409 4629 5385 4633 4873 4643 6281 4645 5257 4649 4745 
      4675 6217 4677 5193 4739 6185 4741 5161 4867 6169 4869 5145 5127 7173 5131 
      6661 5133 5637 5139 6405 5141 5381 5155 6277 5157 5253 5187 6213 5251 6181 
      5379 6165 5635 6157 6151 7171 6155 6659 6163 6403 6179 6275 6211 5189 4681 
      4433 4321 3142 2634 2386 2274 1612 1364 1252  856  744  496 
    ] def

    /tab213 [
         3 6144    5 5120    6 3072    9 4608   10 2560   12 1536   17 4352   18 
      2304   20 1280   24  768   33 4224   34 2176   36 1152   40  640   48  384 
        65 4160   66 2112   68 1088   72  576   80  320   96  192  129 4128  130 
      2080  132 1056  136  544  144  288  257 4112  258 2064  260 1040  264  528 
       513 4104  514 2056  516 1032 1025 4100 1026 2052 2049 4098 4097 2050 1028 
       520  272  160
    ] def

    /chars 10 array def
    0 1 9 {
        /i exch def
        codewords i get dup 1286 le {
            tab513 exch get 
        } {
            tab213 exch 1287 sub get
        } ifelse
        chars i 3 -1 roll put
    } for

    9 -1 0 {
        /i exch def
        2 i exp cvi fcs and 0 ne {
            chars i chars i get 8191 xor put
        } if
    } for

    % Conversion from characters to the OneCode encoding
    /barmap [
        7 2 4 3    1 10 0 0   9 12 2 8   5 5 6 11   8 9 3 1
        0 1 5 12   2 5 1 8    4 4 9 11   6 3 8 10   3 9 7 6
        5 11 1 4   8 5 2 12   9 10 0 2   7 1 6 7    3 6 4 9
        0 3 8 6    6 4 2 7    1 1 9 9    7 10 5 2   4 0 3 8
        6 2 0 4    8 11 1 0   9 8 3 12   2 6 7 7    5 1 4 10
        1 12 6 9   7 3 8 0    5 8 9 7    4 6 2 10   3 4 0 5
        8 4 5 7    7 11 1 9   6 0 9 6    0 6 4 8    2 1 3 2
        5 9 8 12   4 11 6 1   9 5 7 4    3 3 1 2    0 7 2 0
        1 3 4 1    6 10 3 5   8 7 9 4    2 11 5 6   0 8 7 12
        4 2 8 1    5 10 3 0   9 3 0 9    6 5 2 4    7 8 1 7
        5 0 4 5    2 3 0 10   6 12 9 2   3 11 1 6   8 8 7 9
        5 4 0 11   1 5 2 2    9 1 4 12   8 3 6 6    7 0 3 7
        4 7 7 5    0 12 1 11  2 9 9 0    6 8 5 3    3 10 8 2
    ] def

    /bbs 65 array def    
    /bhs 65 array def
    0 1 64 {
        /i exch def
        /dec chars barmap i 4 mul get get 2 barmap i 4 mul 1 add get exp cvi and 0 ne def
        /asc chars barmap i 4 mul 2 add get get 2 barmap i 4 mul 3 add get exp cvi and 0 ne def
        dec not asc not and {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        dec not asc and {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc not and {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc and {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put        
        } if
    } for
    
    % Return the arguments
    <<
    /ren (renlinear)
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    /txt txt
    /textxalign (left)
    /textfont /Helvetica
    /textyoffset 1
    /textxoffset -0.3
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER onecode--

% --BEGIN ENCODER postnet--
% --DESC: United States Postal Service Postnet
% --EXAM: 012345
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/postnet {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.125 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def

    % Create an array containing the character mappings
    /encs
    [ (55222) (22255) (22525) (22552) (25225)
      (25252) (25522) (52225) (52252) (52522)
      (5) (5)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksum checksum indx add def     % checksum+=indx
    } for

    % Put the checksum character
    /checksum 10 checksum 10 mod sub 10 mod def
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    % Return the arguments
    <<
    /ren (renlinear)
    /bhs bhs
    /bbs [bhs length {0} repeat]
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER postnet--

% --BEGIN ENCODER royalmail--
% --DESC: Royal Mail 4 State Customer Code (RM4SCC)
% --EXAM: LE28HS9Z
% --EXOP: includetext includecheckintext barcolor=FF0000
% --RNDR: renlinear
/royalmail {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (3300) (2211) (2301) (2310) (3201) (3210) 
      (1122) (0033) (0123) (0132) (1023) (1032) 
      (1302) (0213) (0303) (0312) (1203) (1212) 
      (1320) (0231) (0321) (0330) (1221) (1230) 
      (3102) (2013) (2103) (2112) (3003) (3012) 
      (3120) (2031) (2121) (2130) (3021) (3030) 
      (2) (3)
    ] def

    % Create a string of the available characters
    /barchars (ZUVWXY501234B6789AHCDEFGNIJKLMTOPQRS) def

    /barlen barcode length def
    /encstr barlen 4 mul 6 add string def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 36 get putinterval
    
    /checksumrow 0 def
    /checksumcol 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul 1 add enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksumrow checksumrow indx 6 idiv add def
        /checksumcol checksumcol indx 6 mod add def 
    } for

    % Put the checksum character
    /checksum checksumrow 6 mod 6 mul checksumcol 6 mod add def
    /enc encs checksum get def
    encstr barlen 4 mul 1 add enc putinterval
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    encstr barlen 4 mul 5 add encs 37 get putinterval  

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren (renlinear)
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER royalmail--

% --BEGIN ENCODER auspost--
% --DESC: AusPost 4 State Customer Code
% --EXAM: 5956439111ABA 9
% --EXOP: includetext custinfoenc=character
% --RNDR: renlinear
/auspost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    /custinfoenc (character) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    /encs
    [ (000) (001) (002) (010) (011) (012) (020) (021)
      (022) (100) (101) (102) (110) (111) (112) (120)
      (121) (122) (200) (201) (202) (210) (211) (212)
      (220) (221) (222) (300) (301) (302) (310) (311)
      (312) (320) (321) (322) (023) (030) (031) (032)
      (033) (103) (113) (123) (130) (131) (132) (133)
      (203) (213) (223) (230) (231) (232) (233) (303)
      (313) (323) (330) (331) (332) (333) (003) (013)
      (00) (01) (02) (10) (11) (12) (20) (21) (22) (30)
      (13) (3)
    ] def

    % Create a string of the available characters
    /barchars (ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz #) def
    
    /barlen barcode length def
    barcode 0 2 getinterval (11) eq {37} if
    barcode 0 2 getinterval (45) eq {37} if
    barcode 0 2 getinterval (59) eq {52} if
    barcode 0 2 getinterval (62) eq {67} if
    /encstr exch string def
    /txt barlen 2 sub array def

    % Put start character
    encstr 0 encs 74 get putinterval

    % Encode the FCC
    0 1 1 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
    } for
    
    % Encode the DPID
    2 1 9 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
        txt i 2 sub [barcode i 1 getinterval i 2 sub 2 mul 6 add 3.312 mul textyoffset textfont textsize] put
    } for
    
    % Encode the customer information   
    custinfoenc (numeric) eq {
        0 1 barlen 11 sub {
            /i exch def
            encs barcode i 10 add 1 getinterval cvi 64 add get
            encstr i 2 mul 22 add 3 2 roll putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 2 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 2 mul def
    } {
        0 1 barlen 11 sub {
            /i exch def           
            barcode i 10 add 1 getinterval barchars exch search
            pop                                
            length /indx exch def           
            pop pop                            
            /enc encs indx get def          
            encstr i 3 mul 22 add enc putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 3 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 3 mul def
    } ifelse

    % Add any filler characters
    22 ciflen add 1 encstr length 14 sub {        
        encstr exch encs 75 get putinterval
    } for
    
    % Create the 64x64 Reed-Solomon table
    /rstable 64 64 mul array def
    rstable 0 [ 64 {0} repeat ] putinterval
    rstable 64 [ 0 1 63 {} for ] putinterval
    /prev 1 def
    64 {       
        /next prev 1 bitshift def
        next 64 and 0 ne {
            /next next 67 xor def
        } if        
        0 1 63 {
            /j exch def
            /nextcell {rstable 64 next mul j add} def
            nextcell rstable 64 prev mul j add get 1 bitshift put
            nextcell get 64 and 0 ne {
                nextcell nextcell get 67 xor put
            } if
        } for
        /prev next def
    } repeat
    
    % Calculate the Reed-Solomon codes for triples
    /rscodes encstr length 16 sub 3 idiv 4 add array def
    rscodes 0 [ 4 {0} repeat ] putinterval
    2 3 encstr length 16 sub {
        /i exch def
        rscodes rscodes length i 2 sub 3 idiv sub 1 sub
        encstr i 1 getinterval cvi 16 mul
        encstr i 1 add 1 getinterval cvi 4 mul add
        encstr i 2 add 1 getinterval cvi add        
        put
    } for    
    rscodes length 5 sub -1 0 {
       /i exch def
       0 1 4 {
           /j exch def
           rscodes i j add rscodes i j add get
           rstable 64 [48 17 29 30 1] j get mul rscodes i 4 add get add get
           xor put
       } for
    } for
    /checkcode (000000000000) 12 string copy def
    0 1 3 {
        /i exch def
        /enc rscodes 3 i sub get 4 3 string cvrs def
        checkcode i 3 mul 3 enc length sub add enc putinterval
    } for
    
    % Put checkcode and end characters
    encstr encstr length 14 sub checkcode putinterval
    encstr encstr length 2 sub encs 74 get putinterval 

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for   
    
    % Return the arguments
    <<
    /ren (renlinear)
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER auspost--

% --BEGIN ENCODER kix--
% --DESC: Royal Dutch TPG Post KIX 4-State Barcode
% --EXAM: 1231FZ13XHS
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/kix {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (0033) (0123) (0132) (1023) (1032) (1122)
      (0213) (0303) (0312) (1203) (1212) (1302) 
      (0231) (0321) (0330) (1221) (1230) (1320)
      (2013) (2103) (2112) (3003) (3012) (3102)
      (2031) (2121) (2130) (3021) (3030) (3120) 
      (2211) (2301) (2310) (3201) (3210) (3300) 
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ) def

    /barlen barcode length def
    /encstr barlen 4 mul string def
    /txt barlen array def
    
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 3.312 mul textyoffset textfont textsize] put
    } for

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren (renlinear)
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER kix--

% --BEGIN ENCODER japanpost--
% --DESC: Japan Post 4 State Customer Code
% --EXAM: 6540123789-A-K-Z
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/japanpost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
  
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    % 0123456789- C1C2C3C4C5C6C7C8 ST EN
    /encs
    [ (300) (330) (312) (132) (321) (303) (123) (231) (213) (033) (030)
      (120) (102) (210) (012) (201) (021) (003) (333) 
      (31) (13)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-ABCDEFGHIJKLMNOPQRSTUVWXYZ) def
    /barlen barcode length def
    
    /encstr 20 1 add 3 mul 4 add string def
    /digits 20 array def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 19 get putinterval

    /checksum 0 def
    /j 0 def /i 0 def
    0 1 barlen 1 sub {
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard match and post
        indx 11 ge indx 37 lt and {          % Insert escape
            j 18 gt {exit} if                % Should fit in 20 chars
                                             % 11-20: C1 (11)
                                             % 21-30: C2 (12)
                                             % 31-36: C3 (13)
            /digit indx 1 sub 10 idiv 10 add def
            encstr j 3 mul 2 add encs digit get putinterval
            /checksum checksum digit add def
            digits j digit put
            /j j 1 add def
        } if
        j 19 gt {exit} if                    % Should fit in 20 chars
        /digit 0 def
        indx 37 eq {
            /digit 14 def                    % space (C14)
        } if
        indx 11 ge indx 37 lt and {
            /digit indx 1 sub 10 mod def
        } if
        indx 11 lt {
            /digit indx def
        } if
        encstr j 3 mul 2 add encs digit get putinterval % space
        /checksum checksum digit add def
        digits j digit put
        txt i [barcode i 1 getinterval j 3 mul 2 add 3.312 mul textyoffset textfont textsize] put
        /j j 1 add def
    } for

    % Fill spaces (c14) at right end
    j 1 20 1 sub {
        /k exch def
        encstr k 3 mul 2 add encs 14 get putinterval
        /checksum checksum 14 add def
        digits k 14 put
    } for

    % Put the checksum character
    /checksum checksum 19 mod 19 exch sub def
    encstr 2 20 3 mul add encs checksum get putinterval

    % Put end character
    encstr 2 21 3 mul add encs 20 get putinterval
    /checkdigit ( ) def
    includecheckintext {
        /checkdigit barchars checksum 1 getinterval def
    } if
    txt i 1 add [ checkdigit 20 3 mul 2 add 3.312 mul textyoffset textfont textsize] put

    % Put end character
    encstr 20 1 add 3 mul 2 add encs 20 get putinterval

    /bbs 21 3 mul 4 add array def
    /bhs bbs length array def
    0 1 bbs length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        /bunit 0 def
        /hunit 0 def
        enc (0) eq {
            /bunit 3 def
            /hunit 2 def
        } if
        enc (1) eq {
            /bunit 0 def
            /hunit 5 def
        } if
        enc (2) eq {
            /bunit 3 def
            /hunit 5 def
        } if
        enc (3) eq {
            /bunit 0 def
            /hunit 8 def
        } if
        bbs i bunit height mul 8 div put
        bhs i hunit height mul 8 div put
    } for

    % Return the arguments
    <<
    /ren (renlinear)
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER japanpost--

% --BEGIN ENCODER msi--
% --DESC: MSI Modified Plessey
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/msi {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (13131313) (13131331) (13133113) (13133131) (13311313)
      (13311331) (13313113) (13313131) (31131313) (31131331)
      (31) (131)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def     % Length of the code

    includecheck {
        /sbs barlen 8 mul 13 add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen 8 mul 5 add string def
        /txt barlen array def
    } ifelse

    % Put start character
    sbs 0 encs 10 get putinterval
    /checksum 0 def

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 2 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 16 mul 4 add textyoffset textfont textsize] put
        barlen i sub 2 mod 0 eq {
            /checksum indx checksum add def
        } {
            /checksum indx 2 mul dup 10 idiv add checksum add def
        } ifelse
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum 10 checksum 10 mod sub 10 mod def
        sbs barlen 8 mul 2 add encs checksum get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen 16 mul 4 add textyoffset textfont textsize] put
        } {
            txt barlen [( ) barlen 16 mul 4 add textyoffset textfont textsize] put
        } ifelse
        sbs barlen 8 mul 10 add encs 11 get putinterval
    } {
        sbs barlen 8 mul 2 add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER msi--

% --BEGIN ENCODER plessey--
% --DESC: Plessey
% --EXAM: 01234ABCD
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/plessey {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (13131313) (31131313) (13311313) (31311313)
      (13133113) (31133113) (13313113) (31313113)
      (13131331) (31131331) (13311331) (31311331)
      (13133131) (31133131) (13313131) (31313131)
      (31311331) (331311313)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEF) def

    /barlen barcode length def     % Length of the code
    /sbs barlen 8 mul 33 add string def
    /txt barlen 2 add array def
    /checkbits barlen 4 mul 8 add array def
    checkbits barlen 4 mul [ 0 0 0 0 0 0 0 0 ] putinterval

    % Put start character
    sbs 0 encs 16 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 16 mul 16 add textyoffset textfont textsize] put
        checkbits i 4 mul [
                indx 1 and
                indx -1 bitshift 1 and
                indx -2 bitshift 1 and
                indx -3 bitshift
        ] putinterval
    } for

    % Checksum is last 8 bits of a CRC using a salt
    /checksalt [ 1 1 1 1 0 1 0 0 1 ] def
    0 1 barlen 4 mul 1 sub {
        /i exch def
        checkbits i get 1 eq {
            0 1 8 {
                /j exch def
                checkbits i j add checkbits i j add get checksalt j get xor put
            } for
        } if
    } for

    % Calculate the value of the checksum digits
    /checkval 0 def
    0 1 7 {
        /i exch def
        /checkval checkval 2 7 i sub exp cvi checkbits barlen 4 mul i add get mul add def
    } for

    % Put the checksum characters
    /checksum1 checkval -4 bitshift def
    /checksum2 checkval 15 and def
    sbs barlen 8 mul 8 add encs checksum1 get putinterval
    sbs barlen 8 mul 16 add encs checksum2 get putinterval
    includecheckintext {
        txt barlen [barchars checksum1 1 getinterval barlen 16 mul 16 add textyoffset textfont textsize] put
        txt barlen 1 add [barchars checksum2 1 getinterval barlen 1 add 16 mul 16 add textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 16 mul 16 add textyoffset textfont textsize] put
        txt barlen 1 add [( ) barlen 1 add 16 mul 16 add textyoffset textfont textsize] put
    } ifelse

    % Put end character
    sbs barlen 8 mul 24 add encs 17 get putinterval

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER plessey--

% --BEGIN ENCODER raw--
% --DESC: Raw bar space succession for custom symbologies 
% --EXAM: 331132131313411122131311333213114131131221323
% --EXOP: height=0.5
% --RNDR: renlinear
/raw {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /sbs exch def        % We are given a barcode string

    /dontdraw false def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Return the arguments
    <<
    /ren (renlinear)
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER raw--

% --BEGIN ENCODER symbol--
% --DESC: Miscellaneous symbols
% --EXAM: fima
% --EXOP: backgroundcolor=DD000011
% --RNDR: renlinear
/symbol {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def

    barcode (fima) eq {
        /sbs [2.25 2.25 2.25 11.25 2.25 11.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0] def
    } if

    barcode (fimb) eq {
        /sbs [2.25 6.75 2.25 2.25 2.25 6.25 2.25 2.25 2.25 6.75 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if

    barcode (fimc) eq {
        /sbs [2.25 2.25 2.25 6.75 2.25 6.75 2.25 6.75 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if
    
    barcode (fimd) eq {
        /sbs [2.25 2.25 2.25 2.25 2.25 6.75 2.25 6.75 2.25 2.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0 0] def
    } if
    
    % Return the arguments
    <<
    /ren (renlinear)
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
% --END ENCODER symbol--

% --BEGIN ENCODER pdf417--
% --DESC: PDF417
% --EXAM: This is PDF417
% --EXOP: columns=2
% --RNDR: renmatrix
/pdf417 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /compact false def
    /eclevel -1 def
    /columns 0 def
    /rows 0 def
    /rowmult 3 def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /eclevel eclevel cvi def
    /columns columns cvi def
    /rows rows cvi def
    /rowmult rowmult cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert input into array of codewords
    raw {
        /datcws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            datcws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } {  % Simple autoencoder from input to codewords using byte mode
        /barlen barcode length def
        barlen 6 mod 0 eq {
            /datcws barlen 6 idiv 5 mul 1 add array def
            datcws 0 924 put
        } {
            /datcws barlen 6 idiv 5 mul barlen 6 mod add 1 add array def
            datcws 0 901 put 
        } ifelse

        % Rebase groups of 6 bytes splitting into 3 byte chunks
        0 1 barlen 6 idiv 1 sub {
            /i exch def
            /msbs [ barcode i 6 mul 3 getinterval {} forall ] def
            /mscs [
                msbs aload pop exch 256 mul add exch 65536 mul add 
                3 {dup 900 mod exch 900 idiv} repeat 
            ] def
            /lsbs [barcode i 6 mul 3 add 3 getinterval {} forall] def
            /lscs [
                lsbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            /cws 5 array def
            lscs 0 get mscs 0 get 316 mul add
            cws 4 2 index 900 mod put
            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add
            cws 3 2 index 900 mod put 
            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add 
            cws 2 2 index 900 mod put
            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add
            cws 1 2 index 900 mod put
            900 idiv mscs 2 get 20 mul add
            cws 0 3 -1 roll 900 mod put
            datcws i 5 mul 1 add cws putinterval 
        } for

        % Add the remaining bytes to the end of the codewords
        /rem barlen 6 mod def
        rem 0 ne {
            datcws datcws length rem sub 
            [ barcode barlen rem sub rem getinterval {} forall ] 
            putinterval
        } if

    } ifelse

    % Determine the error correction level if unspecified
    /m datcws length def
    eclevel -1 eq {
        m 40 le {/eclevel 2 def} if
        m 41 ge m 160 le and {/eclevel 3 def} if
        m 161 ge m 320 le and {/eclevel 4 def} if
        m 321 ge {/eclevel 5 def} if
    } if

    % Reduce the error level so that it does not cause an excessive number of codewords
    /maxeclevel 928 1 sub m sub ln 2 ln div cvi 1 sub def
    eclevel maxeclevel gt {/eclevel maxeclevel def} if
    /k 2 eclevel 1 add exp cvi def

    % To determine size of matrix, number of columns if given by user...
    columns 1 ge columns 30 le and {/c columns def} if

    % ... and rows is greater of those required and that given by user within limits
    /r m k add 1 add columns div ceiling cvi def  % Required
    r rows lt rows 90 le and {/r rows def} if
    r 3 lt {/r 3 def} if

    % Opportunistically raise the error level if a better fit to the matrix is possible
    /maxeclevel c r mul 1 sub m sub ln 2 ln div cvi 1 sub def
    maxeclevel eclevel gt {
      /eclevel maxeclevel def
      /k 2 eclevel 1 add exp cvi def
    } if

    % Create codewords array with one extra working space element and add padding
    /n c r mul k sub def
    /cws c r mul 1 add array def
    cws 0 n put
    cws 1 datcws putinterval
    cws m 1 add [ n m sub 1 sub {900} repeat ] putinterval
    cws n [ k {0} repeat 0 ] putinterval

    % Calculate the log and anti-log tables
    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def
    /rslog 929 array def
    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 928 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 k {0} repeat ] def
    1 1 k {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def
    1 2 coeffs length 1 sub {coeffs exch 2 copy get 929 exch sub put} for

    % Derive the error codewords
    0 1 n 1 sub {
        /t exch cws exch get cws n get add 929 mod def
        0 1 k 1 sub {
            /j exch def
            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put
        } for
    } for
    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for

    % Trim the working space from the end of the codewords
    /cws cws 0 cws length 1 sub getinterval def

    % Base 10 encoding of the bar space successions for the codewords in each cluster
    /clusters [
        [
            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048
            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700
             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520
            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544
             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060
             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200
            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952
             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452
             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776
            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894
             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636
             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472
            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160
            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694
             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440
            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104
            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006
             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440
            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980
             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112
            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712
             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840
            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878
             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030
            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552
            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620
             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920
            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872
            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566
            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960
            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264
            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612
             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028
            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854
             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238
             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542
             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598
            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424
            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790
             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008
             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022
             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992
            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830
            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136
             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462
             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928
            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514
            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698
             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672
             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596
             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536
             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640
            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430
             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600
            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748
            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294
            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080
            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152
             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792
            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338
            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442
            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232
             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910
             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468
            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890
             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098
             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500
             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036
             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056
             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078
             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588
            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808
             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190
            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992
            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936
             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980
            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860
            101940  99858 106100 101938 114420
        ] [
            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262
            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708
            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838
            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632
            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880
            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614
            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206
            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390
            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758
             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980
             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144
            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244
            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844
             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994
            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946
             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962
            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402
            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358
            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694
            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366
            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710
             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788
             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642
            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340
            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736
            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804
            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372
             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156
             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578
            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012
            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856
            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104
            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548
             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064
            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216
            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924
            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972
             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320
            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596
            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252
            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358
             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810
            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500
            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808
            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816
            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956
             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462
            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692
            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338
            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598
             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968
            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468
            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692
            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588
             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890
             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244
            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820
             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394
            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452
            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680
             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446
            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786
            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970
             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798
            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730
            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378
             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042
            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042
             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570
             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178
            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858
             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564
             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372
             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618
             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630
             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478
             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740
             81734  73518  81774  81708  81702
        ] [
            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744
             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772
             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892
            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532
             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640
             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228
             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798
            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588
             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282
            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058
            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500
             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380
             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392
            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096
            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646
             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812
             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820
             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450
            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150
             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768
            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634
            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878
             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480
            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268
             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926
             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636
            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960
            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278
             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514
            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208
            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764
             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948
             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044
             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088
             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238
             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542
             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718
             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318
             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258
            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960
             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480
            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992
            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798
            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776
            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048
             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180
             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446
             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664
            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752
            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460
             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916
             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876
             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022
             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144
             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136
            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966
             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336
            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696
             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934
             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774
            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480
            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646
            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398
            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214
             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326
             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432
            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308
            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164
             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536
            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020
             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482
             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850
             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262
             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246
             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420
            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386
             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306
             67476  69556  67474  69554 116714
        ]
    ] def

    % Return the 17 bits for a codeword in a given cluster
    /cwtobits {
        clusters exch get exch get /v exch def
        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]
        dup length 17 sub 17 getinterval
    } bind def

    % Populate bitmap for the image
    compact {
        /rwid 17 c mul 17 add 17 add 1 add def
    } {
        /rwid 17 c mul 17 add 17 add 17 add 18 add def
    } ifelse
    /pixs rwid r mul array def

   0 1 r 1 sub {
        /i exch def

        i 3 mod 0 eq {
            /lcw i 3 idiv 30 mul r 1 sub 3 idiv add def
            /rcw i 3 idiv 30 mul c add 1 sub def
        } if
        i 3 mod 1 eq {
            /lcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
            /rcw i 3 idiv 30 mul r 1 sub 3 idiv add def
        } if
        i 3 mod 2 eq {
            /lcw i 3 idiv 30 mul c add 1 sub def
            /rcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
        } if

        pixs rwid i mul [
            1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 0 0
            lcw i 3 mod cwtobits {} forall
            cws c i mul c getinterval { i 3 mod cwtobits {} forall } forall
            compact {
                1
            } {
                rcw i 3 mod cwtobits {} forall
                1 1 1 1 1 1 1 0 1 0 0 0 1 0 1 0 0 1
            } ifelse
        ] putinterval

    } for

    % Return the arguments
    <<
    /ren (renmatrix)
    /pixs pixs
    /pixx rwid
    /pixy r
    /height r 72 div rowmult mul
    /width rwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
% --END ENCODER pdf417--

% --BEGIN ENCODER datamatrix--
% --DESC: Data Matrix
% --EXAM: This is Data Matrix!
% --EXOP: rows=32 columns=32
% --RNDR: renmatrix
/datamatrix {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /encoding (byte) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def
    /rows rows cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (byte) eq {
        barlen 250 lt {
            /cws [231 barlen barcode {} forall] def
        } {
            /cws [231 barlen 250 idiv 249 add barlen 250 mod barcode {} forall] def
        } ifelse 
        1 1 cws length 1 sub {
            /i exch def
            i 1 add 149 mul 255 mod 1 add cws i get add
            dup 256 ge {256 sub} if
            cws exch i exch put
        } for
    } if

    encoding (ascii) eq {
        /cws barlen 2 mul array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /char barcode i get def
            char 48 ge char 57 le and i barlen 1 sub lt and {
                barcode i 1 add get dup 48 ge exch 57 le and {  % Digit pair
                    cws j barcode i 2 getinterval cvi 130 add put
                    /i i 2 add def
                    /j j 1 add def
                } {  % Singular digit
                    cws j char 1 add put
                    /i i 1 add def
                    /j j 1 add def
                } ifelse
            } { char 127 le {  % ASCII
                cws j char 1 add put
                /i i 1 add def
                /j j 1 add def
            } {  % Extended ASCII
                cws j 235 put
                cws j 1 add char 127 sub put
                /i i 1 add def
                /j j 2 add def
            } ifelse } ifelse
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (edifact) eq {
        /cws 1558 array def
        /i 0 def /j 1 def /k 0 def
        cws 0 240 put
        { % loop
            i barlen gt {exit} if
            /k 0 def /v 0 def
            { % loop until triplet is full or beyond end of data
                k 4 eq i barlen gt or {exit} if
                /cval (unset) def
                i barlen lt {
                    /char barcode i get def
                    char 32 ge char 94 le and {
                        /cval char 63 and def
                    } if
                } {  % Unlatch at end of data
                    /cval 31 def
                } ifelse
                /v v cval 3 k sub 6 mul bitshift or def
                /k k 1 add def
                /i i 1 add def
            } loop
            cws j [ v -16 bitshift v -8 bitshift 255 and v 255 and ] putinterval
            /j j 3 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (c40) eq encoding (text) eq or encoding (x12) eq or {

        /s1 0 def /s2 1 def /s3 2 def /us 30 def

        encoding (c40) eq {
            /latch 230 def
            /charmap [
                0 1 31  { [ exch s1 exch ]            } for  % 0-31
                          [ 3 ]                              % 32
                0 1 14  { [ exch s2 exch ]            } for  % 33-47
                4 1 13  { [ exch ]                    } for  % 48-57
                15 1 21 { [ exch s2 exch ]            } for  % 58-64
                14 1 39 { [ exch ]                    } for  % 65-90
                22 1 26 { [ exch s2 exch ]            } for  % 91-95
                          [ s3 0 ]                           % 96 
                1 1 26  { [ exch s3 exch ]            } for  % 97-122
                27 1 31 { [ exch s3 exch ]            } for  % 123-127
                0 1 31  { [ s2 us 4 -1 roll s1 exch ] } for  % 128-159
                          [ s2 us 3 ]                        % 160
                0 1 14  { [ s2 us 4 -1 roll s2 exch ] } for  % 161-175
                4 1 13  { [ s2 us 4 -1 roll ]         } for  % 176-185
                15 1 21 { [ s2 us 4 -1 roll s2 exch ] } for  % 186-192
                14 1 39 { [ s2 us 4 -1 roll ]         } for  % 193-218
                22 1 26 { [ s2 us 4 -1 roll s2 exch ] } for  % 219-223
                          [ s2 us s3 0 ]                     % 224
                1 1 26  { [ s2 us 4 -1 roll s3 exch ] } for  % 225-250
                27 1 31 { [ s2 us 4 -1 roll s3 exch ] } for  % 251-255
            ] def
        } if

        encoding (text) eq {
            /latch 239 def
            /charmap [
                0 1 31  { [ exch s1 exch ]            } for  % 0-31
                          [ 3 ]                              % 32
                0 1 14  { [ exch s2 exch ]            } for  % 33-47
                4 1 13  { [ exch ]                    } for  % 48-57
                15 1 21 { [ exch s2 exch ]            } for  % 58-64
                1 1 26  { [ exch s3 exch ]            } for  % 65-90
                22 1 26 { [ exch s2 exch ]            } for  % 91-95
                          [ s3 0 ]                           % 96 
                14 1 39 { [ exch ]                    } for  % 97-122
                27 1 31 { [ exch s3 exch ]            } for  % 123-127
                0 1 31  { [ s2 us 4 -1 roll s1 exch ] } for  % 128-159
                          [ s2 us 3 ]                        % 160
                0 1 14  { [ s2 us 4 -1 roll s2 exch ] } for  % 161-175
                4 1 13  { [ s2 us 4 -1 roll ]         } for  % 176-185
                15 1 21 { [ s2 us 4 -1 roll s2 exch ] } for  % 186-192
                1 1 26  { [ s2 us 4 -1 roll s3 exch ] } for  % 193-218
                22 1 26 { [ s2 us 4 -1 roll s2 exch ] } for  % 219-223
                          [ s2 us s3 0 ]                     % 224
                14 1 39 { [ s2 us 4 -1 roll ]         } for  % 225-250
                27 1 31 { [ s2 us 4 -1 roll s3 exch ] } for  % 251-255
            ] def
         } if

         encoding (x12) eq {
             /latch 238 def
             /charmap [
                 13      { [ () ]   } repeat  % 0-12
                           [ 0 ]              % 13
                 18      { [ () ]   } repeat  % 14-31
                           [ 3 ]              % 32
                 9       { [ () ]   } repeat  % 33-41
                           [ 1 ]              % 42
                 5       { [ () ]   } repeat  % 43-47
                 4 1 13  { [ exch ] } for     % 48-57
                 4       { [ () ]   } repeat  % 58-61
                           [ 2 ]              % 62
                 2       { [ () ]   } repeat  % 63-64
                 14 1 39 { [ exch ] } for     % 65-90
                 165     { [ () ]   } repeat  % 91-255 
             ] def
         } if

         % Derive the encoded character stream
         /encstr barlen 4 mul array def
         /j 0 def
         0 1 barlen 1 sub {
             barcode exch get charmap exch get
             dup encstr exch j exch putinterval
             length j add /j exch def
         } for
         /encstr encstr 0 j getinterval def
         /enclen j def

         % Compress triples into doubles
         /cws 1558 array def
         /i 0 def /j 1 def /k 0 def
         cws 0 latch put
         { % loop
            i enclen ge {exit} if
            /k 0 def /v 1 def
            { % loop until triple is full or end of data
                k 3 eq i enclen ge or {exit} if
                /v v encstr i get 40 2 k sub exp cvi mul add def
                /k k 1 add def
                /i i 1 add def
            } loop
            cws j [ v -8 bitshift v 255 and ] putinterval
            /j j 2 add def
        } loop
        cws j 254 put
        /cws cws 0 j 1 add getinterval def

    } if

    % Basic metrics for the each symbol
    %    rows  cols  regh  regv  rscw  rsbl
    /metrics [
        % Standard square symbols
        [  10    10     1     1     5     1 ]
        [  12    12     1     1     7     1 ]
        [  14    14     1     1    10     1 ]
        [  16    16     1     1    12     1 ]
        [  18    18     1     1    14     1 ]
        [  20    20     1     1    18     1 ] 
        [  22    22     1     1    20     1 ]
        [  24    24     1     1    24     1 ]
        [  26    26     1     1    28     1 ]
        [  32    32     2     2    36     1 ]
        [  36    36     2     2    42     1 ]
        [  40    40     2     2    48     1 ]
        [  44    44     2     2    56     1 ]
        [  48    48     2     2    68     1 ]
        [  52    52     2     2    84     2 ]
        [  64    64     4     4   112     2 ]
        [  72    72     4     4   144     4 ]
        [  80    80     4     4   192     4 ]
        [  88    88     4     4   224     4 ]
        [  96    96     4     4   272     4 ]
        [ 104   104     4     4   336     6 ]
        [ 120   120     6     6   408     6 ]
        [ 132   132     6     6   496     8 ]
        [ 144   144     6     6   620    10 ]
        % Optional rectangular symbols
        [   8    18     1     1     7     1 ]
        [   8    32     1     2    11     1 ]
        [  12    26     1     1    14     1 ]
        [  12    36     1     2    18     1 ]
        [  16    36     1     2    24     1 ]
        [  16    48     1     2    28     1 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /ucols columns def
    /i 0 def
    { % loop
        /m metrics i get def
        /rows m 0 get def                          % Rows in symbol
        /cols m 1 get def                          % Columns in symbol
        /regh m 2 get def                          % Horizontal regions
        /regv m 3 get def                          % Vertical regions
        /rscw m 4 get def                          % Error correction codewords
        /rsbl m 5 get def                          % Error correction blocks
        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix
        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix
        /rrows mrows regh idiv def                 % Rows per region
        /rcols mcols regv idiv def                 % Columns per region
        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords
        /okay true def
        cws length ncws gt           {/okay false def} if
        urows 0 ne urows rows ne and {/okay false def} if
        ucols 0 ne ucols cols ne and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pseudo-randomised pad characters
    cws length ncws lt {
        /datlen cws length def
        /cws [ cws {} forall ncws datlen sub {129} repeat ] def
        datlen 1 add 1 ncws 1 sub {
            /i exch def
            i 1 add 149 mul 253 mod 1 add 129 add
            dup 254 gt {254 sub} if
            cws exch i exch put
        } for
    } if

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        cws length 1558 ne {
            /cwbsize cws length rsbl idiv def
        } {
            i 7 le {/cwbsize 156 def} {/cwbsize 155 def} ifelse
        } ifelse
        /cwb cwbsize array def 
        0 1 cwbsize 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
        ecbs i [ rscw rsbl idiv {0} repeat ] put
    } for

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {301 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 rscw rsbl idiv {0} repeat ] def
    1 1 rscw rsbl idiv {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Calculate the error correction codewords for each block
    0 1 cwbs length 1 sub {
        /i exch def
        /cwb cwbs i get def
        /ecb ecbs i get def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def 
            ecb length 1 sub -1 0 {
                /j exch def
                /p ecb length j sub 1 sub def
                ecb p t coeffs j get rsprod put
                j 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for 
        } for
    } for

    % Strange fixup for 144x144 symbols
    ncws 1558 eq {
        /ecbs [ ecbs 8 2 getinterval {} forall ecbs 0 8 getinterval {} forall ] def
    } if

    % Extend codewords with the interleaved error correction codes
    /cws [ cws {} forall rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws ncws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Place the codewords into the matrix
    /module {
        % cw row col shape
        4 -1 roll 
        (00000000) 8 string copy dup 3 -1 roll 2 8 string cvrs 
        dup length 8 exch sub exch putinterval 
        7 -1 0 {1 index exch get 48 sub exch} for pop
        11 -3 roll
        % 1 2 4 8 16 32 64 128 row col shape
        {  % Place each bit of the codeword in the shape, MSB first
            exec
            1 index 0 lt {
                exch mrows add exch
                4 mrows 4 add 8 mod sub add
            } if
            dup 0 lt {
                mcols add exch
                4 mcols 4 add 8 mod sub add exch
            } if
            exch mcols mul add
            mmat exch 5 -1 roll put
        } forall
    } bind def

    % Placement patterns
    /dmn [
        { 2 copy 2 sub exch 2 sub exch } bind  { 2 copy 1 sub exch 2 sub exch } bind
        { 2 copy 2 sub exch 1 sub exch } bind  { 2 copy 1 sub exch 1 sub exch } bind
        { 2 copy exch 1 sub exch } bind        { 2 copy 2 sub } bind
        { 2 copy 1 sub } bind                  { 2 copy } bind
    ] def
    
    /dmc1 [
        { mrows 1 sub 0 } bind  { mrows 1 sub 1 } bind
        { mrows 1 sub 2 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc2 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 4 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
    ] def
    
    /dmc3 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc4 [
        { mrows 1 sub 0 } bind  { mrows 1 sub mcols 1 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 3 sub } bind
        { 1 mcols 2 sub } bind  { 1 mcols 1 sub } bind
    ] def

    /mmat [ mrows mcols mul {-1} repeat ] def
    cws length 1 sub -1 0 {cws exch get} for  % Reverse cws onto stack
    4 0  % Starting row and column
    { % loop
        2 copy 0 eq exch mrows eq and {
            dmc1 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 4 mod 0 ne and {
            dmc2 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 8 mod 4 eq and {
            dmc3 module
        } if
        2 copy 2 eq exch mrows 4 add eq and mcols 8 mod 0 eq and {
            dmc4 module
        } if

        { % loop for sweeping upwards
            2 copy 0 ge exch mrows lt and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 add exch 2 sub exch
            2 copy mcols lt exch 0 ge and not {exit} if
        } loop
        3 add exch 1 add exch

        { % loop for sweeping downwards
            2 copy mcols lt exch 0 ge and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 sub exch 2 add exch
            2 copy 0 ge exch mrows lt and not {exit} if
        } loop
        1 add exch 3 add exch

        2 copy mcols lt exch mrows lt or not {pop pop exit} if

    } loop

    % Set checker pattern if required
    mmat mrows mcols mul 1 sub get -1 eq {
        mmat mrows mcols 1 sub mul 2 sub [1 0] putinterval
        mmat mrows mcols mul 2 sub [0 1] putinterval
    } if

    % Place the modules onto a pixel map between alignment patterns
    /pixs rows cols mul array def
    /cwpos 0 def
    0 1 rows 1 sub {
        /i exch def
        i rrows 2 add mod 0 eq { pixs i cols mul [ cols 2 idiv {1 0} repeat ] putinterval } if  
        i rrows 2 add mod rrows 1 add eq { pixs i cols mul [ cols {1} repeat ] putinterval } if 
        i rrows 2 add mod 0 ne i rrows 2 add mod rrows 1 add ne and {
            0 1 cols 1 sub {
                /j exch def
                j rcols 2 add mod 0 eq { pixs i cols mul j add 1 put } if
                j rcols 2 add mod rcols 1 add eq { pixs i cols mul j add i 2 mod put } if
                j rcols 2 add mod 0 ne j rcols 2 add mod rcols 1 add ne and {
                    pixs i cols mul j add mmat cwpos get put
                    /cwpos cwpos 1 add def
                } if
            } for
        } if 
    } for

    % Return the arguments
    <<
    /ren (renmatrix)
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 72 div 1.5 mul
    /width cols 72 div 1.5 mul
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
% --END ENCODER datamatrix--

% --BEGIN ENCODER qrcode--
% --DESC: QR Code
% --EXAM: http://www.terryburton.co.uk/barcodewriter/
% --EXOP: eclevel=M
% --RNDR: renmatrix
/qrcode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (full) def     % full or micro
    /version (unset) def
    /eclevel (unset) def   % L, M, Q or H
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert from input into message bitstream
    raw {
        /msgbits barcode def 
    } {  % Simple autoencoder from input to bitstream using byte mode only for full format symbols

        /barlen barcode length def
        eclevel (unset) eq {/eclevel (M) def} if

        % Determine smallest symbol version to hold given amount of byte-encoded data
        version (unset) eq {
            /caps [
                [
                      17    32    53    78   106   134   154   192   230   271   % 1-L  - 10-L
                     321   367   425   458   520   586   644   718   792   858   % 11-L - 20-L
                     929  1003  1091  1171  1273  1367  1465  1528  1628  1732   % 21-L - 30-L
                    1840  1952  2068  2188  2303  2431  2563  2699  2809  2953   % 31-L - 40-L
                ] [
                      14    26    42    62    84   106   122   152   180   213   % 1-M  - 10-M
                     251   287   331   362   412   450   504   560   624   666   % 11-M - 20-M
                     711   779   857   911   997  1059  1125  1190  1264  1370   % 21-M - 30-M
                    1452  1538  1628  1722  1809  1911  1989  2099  2213  2331   % 31-M - 40-M
                ] [
                      11    20    32    46    60    74    86   108   130   151   % 1-Q  - 10-Q
                     177   203   241   258   292   322   364   394   442   482   % 11-Q - 20-Q
                     509   565   611   661   715   751   805   868   908   982   % 21-Q - 30-Q
                    1030  1112  1168  1228  1283  1351  1423  1499  1579  1663   % 31-Q - 40-Q
                ] [
                       7    14    24    34    44    58    64    84    98   119   % 1-H  - 10-H
                     137   155   177   194   220   250   280   310   338   382   % 11-H - 20-H
                     403   439   461   511   535   593   625   658   698   742   % 21-H - 30-H
                     790   842   898   958   983  1051  1093  1139  1219  1273   % 31-H - 40-H
                ]
            ] def
            /caps caps (LMQH) eclevel search pop length exch pop exch pop get def
            /i 1 def
            {
                barlen caps i 1 sub get le {exit} if 
                /i i 1 add def
            } loop
            /version i 10 2 string cvrs def
        } if

        % Set the control character data for the version
        /mid (0100) def /term (0000) def /cclen 8 def
        version 0 1 getinterval (M) ne {  % Version 10 and above
            version cvi 10 ge {/cclen 16 def} if
        } if
        /midlen mid length def
        /termlen term length def

        % Create the bitstream as byte_mode_id character_count data_bytes term
        /msgbits midlen cclen add barlen 8 mul add termlen add string def
        msgbits 0 mid putinterval
        (0000000000000000) 0 cclen getinterval cclen string copy 
        dup barlen cvi 2 cclen string cvrs dup length cclen exch sub exch putinterval 
        /cc exch def
        msgbits midlen cc putinterval
        0 1 barlen 1 sub {
            /i exch def
            (00000000) 8 string copy dup barcode i get cvi 2 8 string cvrs dup length 8 exch sub exch putinterval 
            msgbits midlen cclen add i 8 mul add 3 -1 roll putinterval
        } for
        msgbits midlen cclen add barlen 8 mul add term putinterval

    } ifelse

    % Lookup the most appropriate symbol specification
    /metrics [
        % format   vers  size align modules    error codewords        error correction blocks 
        %                                      L    M    Q    H       L1 L2 M1 M2 Q1 Q2 H1 H2
        [ (micro)  (M1)   11  98 99     36  [   2   99   99   99 ]  [  1  0 -1 -1 -1 -1 -1 -1 ] ]
        [ (micro)  (M2)   13  98 99     80  [   5    6   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M3)   15  98 99    132  [   6    8   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M4)   17  98 99    192  [   8   10   14   99 ]  [  1  0  1  0  1  0 -1 -1 ] ]
        [ (full)   (1)    21  98 99    208  [   7   10   13   17 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (2)    25  18 99    359  [  10   16   22   28 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (3)    29  22 99    567  [  15   26   36   44 ]  [  1  0  1  0  2  0  2  0 ] ]
        [ (full)   (4)    33  26 99    807  [  20   36   52   64 ]  [  1  0  2  0  2  0  4  0 ] ]
        [ (full)   (5)    37  30 99   1079  [  26   48   72   88 ]  [  1  0  2  0  2  2  2  2 ] ]
        [ (full)   (6)    41  34 99   1383  [  36   64   96  112 ]  [  2  0  4  0  4  0  4  0 ] ]
        [ (full)   (7)    45  22 38   1568  [  40   72  108  130 ]  [  2  0  4  0  2  4  4  1 ] ]
        [ (full)   (8)    49  24 42   1936  [  48   88  132  156 ]  [  2  0  2  2  4  2  4  2 ] ]
        [ (full)   (9)    53  26 46   2336  [  60  110  160  192 ]  [  2  0  3  2  4  4  4  4 ] ]
        [ (full)   (10)   57  28 50   2768  [  72  130  192  224 ]  [  2  2  4  1  6  2  6  2 ] ]
        [ (full)   (11)   61  30 54   3232  [  80  150  224  264 ]  [  4  0  1  4  4  4  3  8 ] ]
        [ (full)   (12)   65  32 58   3728  [  96  176  260  308 ]  [  2  2  6  2  4  6  7  4 ] ]
        [ (full)   (13)   69  34 62   4256  [ 104  198  288  352 ]  [  4  0  8  1  8  4 12  4 ] ]
        [ (full)   (14)   73  26 46   4651  [ 120  216  320  384 ]  [  3  1  4  5 11  5 11  5 ] ]
        [ (full)   (15)   77  26 48   5243  [ 132  240  360  432 ]  [  5  1  5  5  5  7 11  7 ] ]
        [ (full)   (16)   81  26 50   5867  [ 144  280  408  480 ]  [  5  1  7  3 15  2  3 13 ] ]
        [ (full)   (17)   85  30 54   6523  [ 168  308  448  532 ]  [  1  5 10  1  1 15  2 17 ] ]
        [ (full)   (18)   89  30 56   7211  [ 180  338  504  588 ]  [  5  1  9  4 17  1  2 19 ] ]
        [ (full)   (19)   93  30 58   7931  [ 196  364  546  650 ]  [  3  4  3 11 17  4  9 16 ] ]
        [ (full)   (20)   97  34 62   8683  [ 224  416  600  700 ]  [  3  5  3 13 15  5 15 10 ] ]
        [ (full)   (21)  101  28 50   9252  [ 224  442  644  750 ]  [  4  4 17  0 17  6 19  6 ] ]
        [ (full)   (22)  105  26 50  10068  [ 252  476  690  816 ]  [  2  7 17  0  7 16 34  0 ] ]
        [ (full)   (23)  109  30 54  10916  [ 270  504  750  900 ]  [  4  5  4 14 11 14 16 14 ] ]
        [ (full)   (24)  113  28 54  11796  [ 300  560  810  960 ]  [  6  4  6 14 11 16 30  2 ] ]
        [ (full)   (25)  117  32 58  12708  [ 312  588  870 1050 ]  [  8  4  8 13  7 22 22 13 ] ]
        [ (full)   (26)  121  30 58  13652  [ 336  644  952 1110 ]  [ 10  2 19  4 28  6 33  4 ] ]
        [ (full)   (27)  125  34 62  14628  [ 360  700 1020 1200 ]  [  8  4 22  3  8 26 12 28 ] ]
        [ (full)   (28)  129  26 50  15371  [ 390  728 1050 1260 ]  [  3 10  3 23  4 31 11 31 ] ]
        [ (full)   (29)  133  30 54  16411  [ 420  784 1140 1350 ]  [  7  7 21  7  1 37 19 26 ] ]
        [ (full)   (30)  137  26 52  17483  [ 450  812 1200 1440 ]  [  5 10 19 10 15 25 23 25 ] ]
        [ (full)   (31)  141  30 56  18587  [ 480  868 1290 1530 ]  [ 13  3  2 29 42  1 23 28 ] ]
        [ (full)   (32)  145  34 60  19723  [ 510  924 1350 1620 ]  [ 17  0 10 23 10 35 19 35 ] ]
        [ (full)   (33)  149  30 58  20891  [ 540  980 1440 1710 ]  [ 17  1 14 21 29 19 11 46 ] ]
        [ (full)   (34)  153  34 62  22091  [ 570 1036 1530 1800 ]  [ 13  6 14 23 44  7 59  1 ] ]
        [ (full)   (35)  157  30 54  23008  [ 570 1064 1590 1890 ]  [ 12  7 12 26 39 14 22 41 ] ]
        [ (full)   (36)  161  24 50  24272  [ 600 1120 1680 1980 ]  [  6 14  6 34 46 10  2 64 ] ]
        [ (full)   (37)  165  28 54  25568  [ 630 1204 1770 2100 ]  [ 17  4 29 14 49 10 24 46 ] ]
        [ (full)   (38)  169  32 58  26896  [ 660 1260 1860 2220 ]  [  4 18 13 32 48 14 42 32 ] ]
        [ (full)   (39)  173  26 54  28256  [ 720 1316 1950 2310 ]  [ 20  4 40  7 43 22 10 67 ] ]
        [ (full)   (40)  177  30 58  29648  [ 750 1372 2040 2430 ]  [ 19  6 18 31 34 34 20 61 ] ]
    ] def
    /eclval (LMQH) eclevel search pop length exch pop exch pop def
    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                             % Format of the symbol
        /vers m 1 get def                             % Version of symbol
        /size m 2 get def                             % Length of side
        /asp2 m 3 get def                             % Position of second alignment symbol
        /asp3 m 4 get def                             % Position of third alignment symbol
        /nmod m 5 get def                             % Number of modules
        /ncws nmod 8 idiv def                         % Total number of codewords
        /rbit nmod 8 mod def                          % Number of remainder bits
        /lc4b false def                               % Last data codeword is 4 bits long
        size 11 eq size 15 eq or {                    % Adjustments for M1 and M3 symbols
            /ncws ncws 1 add def
            /rbit 0 def
            /lc4b true def
        } if
        /ecws m 6 get eclval get def                  % Number of error correction codewords
        /dcws ncws ecws sub def                       % Number of data codewords
        /dmod dcws 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules
        /ecb1 m 7 get eclval 2 mul get def            % First error correction blocks
        /ecb2 m 7 get eclval 2 mul 1 add get def      % Second error correction blocks
        /okay true def
        version vers ne {/okay false def} if          % The version must match that supplied
        msgbits length dmod gt {/okay false def} if   % Bitstream must fit into data modules
        ecb1 -1 eq ecb2 -1 eq or {/okay false def} if % Error correction level must be valid
        okay {exit} if
        /i i 1 add def
    } loop
    /format frmt def
    /version vers def
    /dcpb dcws ecb1 ecb2 add idiv def                 % Base data codewords per block
    /ecpb ncws ecb1 ecb2 add idiv dcpb sub def        % Error correction codewords per block

    % Expand the message bits by adding padding as necessary
    /pad dmod string def
    0 4 dmod 1 sub {pad exch (0000) putinterval} for
    pad 0 msgbits putinterval
    /padstrs [ (11101100) (00010001) ] def
    /padnum 0 def
    msgbits length 8 div ceiling 8 mul cvi 8 dmod lc4b {5} {1} ifelse sub {
        pad exch padstrs padnum get putinterval 
        /padnum padnum 1 add 2 mod def
    } for

    % Evaluate the padded message into codewords
    /cws dcws array def 
    0 1 cws length 1 sub {
        /c exch def
        /bpcw 8 def
        lc4b c cws length 1 sub eq and {/bpcw 4 def} if
        /cwb pad c 8 mul bpcw getinterval def
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for 
        cws c cw put
    } for 

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {285 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    /rscodes {
        /rscws exch def
        /rsnd rscws length def
        /rscws [ rscws {} forall ecpb {0} repeat ] def
        0 1 rsnd 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        rscws rsnd ecpb getinterval
    } bind def

    % Divide codewords into two groups of blocks and calculate the error correction codewords
    /dcwsb ecb1 ecb2 add array def
    /ecwsb ecb1 ecb2 add array def
    0 1 ecb1 1 sub {  % First group of blocks has smaller number of data codewords
        /i exch def
        dcwsb i cws i dcpb mul dcpb getinterval put
        ecwsb i dcwsb i get rscodes put
    } for
    0 1 ecb2 1 sub {  % Second group of blocks has larger number of data codewords
        /i exch def
        dcwsb ecb1 i add cws ecb1 dcpb mul i dcpb 1 add mul add dcpb 1 add getinterval put
        ecwsb ecb1 i add dcwsb ecb1 i add get rscodes put
    } for
    
    % Reassemble the codewords
    /cws ncws array def
    /cw 0 def
    0 1 dcpb {  % Interleave the data codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            i dcwsb j get length lt {  % Ignore the end of short blocks
                cws cw dcwsb j get i get put
                /cw cw 1 add def
            } if
        } for
    } for
    0 1 ecpb 1 sub {  % Interleave the error codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            cws cw ecwsb j get i get put
            /cw cw 1 add def
        } for
    } for
    
    % Extend codewords by one if there are remainder bits
    rbit 0 gt {
        /pad cws length 1 add array def
        pad 0 cws putinterval
        pad pad length 1 sub 0 put
        /cws pad def
    } if
 
    % Fixups for the short final data byte in M1 and M3 symbols
    lc4b {
        dcws 1 sub 1 ncws 2 sub {
            /i exch def
            cws i cws i get 15 and 4 bitshift put
            cws i cws i 1 add get -4 bitshift 15 and cws i get or put
        } for
        cws ncws 1 sub cws ncws 1 sub get 15 and 4 bitshift put
    } if

    % Create the bitmap
    /pixs [ size size mul {-1} repeat ] def
    /qmv {size mul add} bind def
    
    % Finder patterns
    /fpat [
        [ 1 1 1 1 1 1 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 1 1 1 1 1 1 0 ]
        [ 0 0 0 0 0 0 0 0 ]
    ] def
    0 1 fpat length 1 sub {
      /y exch def
      0 1 fpat 0 get length 1 sub {
        /x exch def
        /fpb fpat y get x get def
        pixs x y qmv fpb put
        format (full) eq {
            pixs size x sub 1 sub y qmv fpb put
            pixs x size y sub 1 sub qmv fpb put
        } if
      } for
    } for
    
    % Alignment patterns
    /algnpat [
        [ 1 1 1 1 1 ]
        [ 1 0 0 0 1 ]
        [ 1 0 1 0 1 ]
        [ 1 0 0 0 1 ]
        [ 1 1 1 1 1 ]
    ] def
    /putalgnpat {
        /py exch def
        /px exch def
        0 1 4 {
            /pb exch def
            0 1 4 {
                /pa exch def
                pixs px pa add py pb add qmv algnpat pb get pa get put
            } for
        } for
    } bind def
    asp2 2 sub asp3 asp2 sub size 13 sub {
        /i exch def
        i 4 putalgnpat
        4 i putalgnpat
    } for
    asp2 2 sub asp3 asp2 sub size 9 sub { 
        /x exch def
        asp2 2 sub asp3 asp2 sub size 9 sub {
            /y exch def
            x y putalgnpat
        } for
    } for
    
    % Timing patterns
    format (full) eq {
        8 1 size 9 sub {
            /i exch def
            pixs i 6 qmv i 1 add 2 mod put
            pixs 6 i qmv i 1 add 2 mod put
        } for
    } {
        8 1 size 1 sub {
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs 0 i qmv i 1 add 2 mod put
        } for
    } ifelse
    
    % Format information modules
    format (full) eq {
        /formatmap [
            [ [ 0 8 ] [ 8 size 1 sub ] ]  [ [ 1 8 ] [ 8 size 2 sub ] ]  [ [ 2 8 ] [ 8 size 3 sub ] ]
            [ [ 3 8 ] [ 8 size 4 sub ] ]  [ [ 4 8 ] [ 8 size 5 sub ] ]  [ [ 5 8 ] [ 8 size 6 sub ] ]
            [ [ 7 8 ] [ 8 size 7 sub ] ]  [ [ 8 8 ] [ size 8 sub 8 ] ]  [ [ 8 7 ] [ size 7 sub 8 ] ]
            [ [ 8 5 ] [ size 6 sub 8 ] ]  [ [ 8 4 ] [ size 5 sub 8 ] ]  [ [ 8 3 ] [ size 4 sub 8 ] ]
            [ [ 8 2 ] [ size 3 sub 8 ] ]  [ [ 8 1 ] [ size 2 sub 8 ] ]  [ [ 8 0 ] [ size 1 sub 8 ] ]
        ] def
    } {
        /formatmap [
            [ [ 1 8 ] ]  [ [ 2 8 ] ]  [ [ 3 8 ] ]  [ [ 4 8 ] ]  [ [ 5 8 ] ]
            [ [ 6 8 ] ]  [ [ 7 8 ] ]  [ [ 8 8 ] ]  [ [ 8 7 ] ]  [ [ 8 6 ] ]
            [ [ 8 5 ] ]  [ [ 8 4 ] ]  [ [ 8 3 ] ]  [ [ 8 2 ] ]  [ [ 8 1 ] ]
        ] def
    } ifelse
    formatmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Version information modules
    size 45 ge {
        /versionmap [
            [ [ size  9 sub 5 ] [ 5 size  9 sub ] ]  [ [ size 10 sub 5 ] [ 5 size 10 sub ] ]
            [ [ size 11 sub 5 ] [ 5 size 11 sub ] ]  [ [ size  9 sub 4 ] [ 4 size  9 sub ] ]
            [ [ size 10 sub 4 ] [ 4 size 10 sub ] ]  [ [ size 11 sub 4 ] [ 4 size 11 sub ] ]
            [ [ size  9 sub 3 ] [ 3 size  9 sub ] ]  [ [ size 10 sub 3 ] [ 3 size 10 sub ] ]
            [ [ size 11 sub 3 ] [ 3 size 11 sub ] ]  [ [ size  9 sub 2 ] [ 2 size  9 sub ] ]
            [ [ size 10 sub 2 ] [ 2 size 10 sub ] ]  [ [ size 11 sub 2 ] [ 2 size 11 sub ] ]
            [ [ size  9 sub 1 ] [ 1 size  9 sub ] ]  [ [ size 10 sub 1 ] [ 1 size 10 sub ] ]
            [ [ size 11 sub 1 ] [ 1 size 11 sub ] ]  [ [ size  9 sub 0 ] [ 0 size  9 sub ] ]
            [ [ size 10 sub 0 ] [ 0 size 10 sub ] ]  [ [ size 11 sub 0 ] [ 0 size 11 sub ] ]
        ] def
    } {
        /versionmap [] def
    } ifelse
    versionmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Solitary dark module in full symbols
    format (full) eq {
        pixs 8 size 8 sub qmv 1 put
    } if
    
    % Calculate the mask patterns
    format (full) eq {
        /maskfuncs [ 
            {add 2 mod} bind
            {exch pop 2 mod} bind
            {pop 3 mod} bind
            {add 3 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } {
        /maskfuncs [ 
            {exch pop 2 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } ifelse
    /masks maskfuncs length array def
    0 1 masks length 1 sub {
        /m exch def
        /mask size size mul array def
        0 1 size 1 sub {
            /j exch def
            0 1 size 1 sub {
                /i exch def
                i j maskfuncs m get exec 0 eq 
                pixs i j qmv get -1 eq and {1} {0} ifelse
                mask i j qmv 3 -1 roll put
            } for
        } for
        masks m mask put
    } for
    
    % Walk the symbol placing the bitstream
    /posx size 1 sub def
    /posy size 1 sub def
    /dir -1 def  % -1 is upwards, 1 is downwards
    /col 1 def   % 0 is left bit, 1 is right bit
    /num 0 def
    { % loop
        posx 0 lt {exit} if
        pixs posx posy qmv get -1 eq {
            cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and
            pixs posx posy qmv 3 -1 roll put
            /num num 1 add def
        } if
        col 1 eq {
            /col 0 def
            /posx posx 1 sub def
        } {
            /col 1 def
            /posx posx 1 add def 
            /posy posy dir add def
            posy 0 lt posy size ge or {  % Turn around at top and bottom
                /dir dir -1 mul def
                /posy posy dir add def
                /posx posx 2 sub def
                % Hop over the timing pattern in full size symbols
                format (full) eq posx 6 eq and {/posx posx 1 sub def} if
            } if
        } ifelse
    } loop

    % Evaluate runlength encoded rows or columns in full symbols
    /evalfulln1n3 {
        /scrle exch def
        % Detect runs of 5 or more like modules
        /scr1 0 scrle { dup 5 ge {add 2 sub dup} if pop } forall def
        % Detect 1:1:3:1:1 ratio next to 4 modules of whitespace
        /scr3 0 def
        3 2 scrle length 3 sub {  % Scan odd (dark) runs within bounds
            /j exch def
            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules
                /fact scrle j get 3 idiv def
                scrle j 2 sub 5 getinterval {fact eq} forall and exch pop and and {
                    j 3 eq j 4 add scrle length ge or {  % At either extent of run
                        /scr3 scr3 40 add def
                    } {  % Bounded by dark modules
                        scrle j 3 sub get 4 ge scrle j 3 add get 4 ge or {
                            /scr3 scr3 40 add def
                        } if
                    } ifelse
                } if
            } if
        } for
        scr1 scr3
    } bind def
    
    % Evaluation algorithm for full symbols
    /evalfull {
        /sym exch def

        /n1 0 def /n2 0 def /n3 0 def
        /rle size array def
        /lastpairs size array def
        /thispairs size array def
        /sizeadd1 size 1 add def
        0 1 size 1 sub {  
            /i exch def

            % Runlength encode (light, dark, light, ...) and evaluate each column
            mark 0 0
            i size dup dup mul 1 sub {
                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } for
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Runlength encode (light, dark, light, ...) and evaluate each row
            /symrow sym i size mul size getinterval def
            mark 0 0 
            symrow { 
                exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } forall 
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Count and score same coloured blocks
            /lastpairs thispairs /thispairs lastpairs def def
            symrow 0 get 1 eq {0} {1} ifelse
            symrow {exch 1 index add exch} forall
            pop
            thispairs astore pop
            i 0 gt {
                mark
                lastpairs aload pop thispairs aload pop
                n2 size { exch sizeadd1 index add 3 and 0 eq {3 add} if } repeat
                /n2 exch def
                cleartomark
            } if

        } for
 
        % Score dark/light imbalance 
        /dark 0 sym {add} forall def
        /n4 dark 100 mul size dup mul div 50 sub abs 5 div cvi 10 mul def

        n1 n2 add n3 add n4 add
    } bind def
 
    % Evaluation algorithm for micro symbols
    /evalmicro {
        /sym exch def
        /dkrhs 0 def /dkbot 0 def
        1 1 size 1 sub {
            /i exch def
            /dkrhs dkrhs sym size 1 sub i qmv get add def
            /dkbot dkbot sym i size 1 sub qmv get add def
        } for
        dkrhs dkbot le {
            dkrhs 16 mul dkbot add neg
        } {
            dkbot 16 mul dkrhs add neg
        } ifelse
    } bind def
    
    % Evaluate the masked symbols to find the most suitable
    /bestscore 999999999 def
    0 1 masks length 1 sub {
        /m exch def
        /masksym size size mul array def
        0 1 size size mul 1 sub {
            /i exch def
            masksym i pixs i get masks m get i get xor put
        } for
        format (full) eq {
            masksym evalfull /score exch def
        } {
            masksym evalmicro /score exch def
        } ifelse
        score bestscore lt { 
            /bestsym masksym def
            /bestmaskval m def
            /bestscore score def
        } if    
    } for
    /pixs bestsym def
    
    % Add the format information
    format (full) eq {
        /fmtvals [
            16#5412 16#5125 16#5e7c 16#5b4b 16#45f9 16#40ce 16#4f97 16#4aa0 
            16#77c4 16#72f3 16#7daa 16#789d 16#662f 16#6318 16#6c41 16#6976
            16#1689 16#13be 16#1ce7 16#19d0 16#0762 16#0255 16#0d0c 16#083b 
            16#355f 16#3068 16#3f31 16#3a06 16#24b4 16#2183 16#2eda 16#2bed
        ] def
        /ecid (MLHQ) eclevel search pop length exch pop exch pop def
        /fmtval fmtvals ecid 3 bitshift bestmaskval add get def
    } {
        /fmtvals [
            16#4445 16#4172 16#4e2b 16#4b1c 16#55ae 16#5099 16#5fc0 16#5af7
            16#6793 16#62a4 16#6dfd 16#68ca 16#7678 16#734f 16#7c16 16#7921
            16#06de 16#03e9 16#0cb0 16#0987 16#1735 16#1202 16#1d5b 16#186c
            16#2508 16#203f 16#2f66 16#2a51 16#34e3 16#31d4 16#3e8d 16#3bba
        ] def
        /symid [ [0] [1 2] [3 4] [5 6 7] ] size 11 sub 2 idiv get eclval get def
        /fmtval fmtvals symid 2 bitshift bestmaskval add get def
    } ifelse
    0 1 formatmap length 1 sub {
        /i exch def
        formatmap i get {
            pixs exch {} forall qmv fmtval 14 i sub neg bitshift 1 and put
        } forall
    } for
    
    % Add the version information
    size 45 ge {
        /vervals [
            16#07c94 16#085bc 16#09a99 16#0a4d3 16#0bbf6 16#0c762 16#0d847 
            16#0e60d 16#0f928 16#10b78 16#1145d 16#12a17 16#13532 16#149a6 
            16#15683 16#168c9 16#177ec 16#18ec4 16#191e1 16#1afab 16#1b08e 
            16#1cc1a 16#1d33f 16#1ed75 16#1f250 16#209d5 16#216fd 16#228ba 
            16#2379f 16#24b0b 16#2542e 16#26a64 16#27541 16#28c69
        ] def
        /verval vervals size 17 sub 4 idiv 7 sub get def
        0 1 versionmap length 1 sub {
            /i exch def
            versionmap i get {
                pixs exch {} forall qmv verval 17 i sub neg bitshift 1 and put
            } forall
        } for
    } if

    % Return the arguments
    <<
    /ren (renmatrix)
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
% --END ENCODER qrcode--

% --BEGIN ENCODER maxicode--
% --DESC: MaxiCode
% --EXAM: [\)>^03001^02996152382802^029840^029001^0291Z00004951^029UPSN^02906X610^029159^0291234567^0291/1^029^029Y^029634 ALPHA DR^029PITTSBURGH^029PA^029^004
% --EXOP: mode=2 parse
% --RNDR: renmaximatrix
/maxicode {

    20 dict begin

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /mode -1 def
    /sam -1 def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /sam sam cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if
    
    /msg barcode def
    /msglen msg length def

    % Special message handling for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Normalise messages that begin with a field identifier [)>RS01GSyy
        msg 0 7 getinterval <5b293e1e30311d> eq {
            /fid msg 0 9 getinterval def
            /msg msg 9 msglen 9 sub getinterval def 
        } {
            /fid () def
        } ifelse

        % Read the postcode, country code and service code fields seperated by GS
        msg <1d> search pop /pcode exch def
        pop <1d> search pop /ccode exch def
        pop <1d> search pop /scode exch def
        pop /msg exch def

        % Prepend the field identifier
        msg length fid length add string dup
        0 fid putinterval dup 
        fid length msg putinterval
        /msg exch def
        /msglen msg length def

    } if

    % Special function characters
    /eci -1 def  /pad -2 def  /ns -3 def
    /la  -4 def  /lb  -5 def
    /sa  -6 def  /sb  -7 def  /sc -8 def  /sd -9 def  /se -10 def
    /sa2 -11 def /sa3 -12 def  
    /lkc -13 def /lkd -14 def /lke -15 def
    /pd2 -16 def /pd3 -17 def 
    
    % Character maps for each state
    /charmaps [
        %  A    B    C    D    E
        [  13  (`)  192  224    0 ]  % 0
        [ (A)  (a)  193  225    1 ]  % 1
        [ (B)  (b)  194  226    2 ]  % 2
        [ (C)  (c)  195  227    3 ]  % 3
        [ (D)  (d)  196  228    4 ]  % 4
        [ (E)  (e)  197  229    5 ]  % 5
        [ (F)  (f)  198  230    6 ]  % 6
        [ (G)  (g)  199  231    7 ]  % 7
        [ (H)  (h)  200  232    8 ]  % 8
        [ (I)  (i)  201  233    9 ]  % 9 
        [ (J)  (j)  202  234   10 ]  % 10
        [ (K)  (k)  203  235   11 ]  % 11
        [ (L)  (l)  204  236   12 ]  % 12
        [ (M)  (m)  205  237   13 ]  % 13
        [ (N)  (n)  206  238   14 ]  % 14
        [ (O)  (o)  207  239   15 ]  % 15
        [ (P)  (p)  208  240   16 ]  % 16
        [ (Q)  (q)  209  241   17 ]  % 17
        [ (R)  (r)  210  242   18 ]  % 18
        [ (S)  (s)  211  243   19 ]  % 19
        [ (T)  (t)  212  244   20 ]  % 20
        [ (U)  (u)  213  245   21 ]  % 21
        [ (V)  (v)  214  246   22 ]  % 22
        [ (W)  (w)  215  247   23 ]  % 23
        [ (X)  (x)  216  248   24 ]  % 24
        [ (Y)  (y)  217  249   25 ]  % 25
        [ (Z)  (z)  218  250   26 ]  % 26
        [ eci  eci  eci  eci  eci ]  % 27
        [  28   28   28   28  pad ]  % 28
        [  29   29   29   29  pad ]  % 29
        [  30   30   30   30   27 ]  % 30
        [  ns   ns   ns   ns   ns ]  % 31
        [ ( )  ({)  219  251   28 ]  % 32
        [ pad  pad  220  252   29 ]  % 33
        [ (")  (})  221  253   30 ]  % 34
        [ (#)  (~)  222  254   31 ]  % 35
        [ ($)  127  223  255  159 ]  % 36
        [ (%)  (;)  170  161  160 ]  % 37
        [ (&)  (<)  172  168  162 ]  % 38
        [ (')  (=)  177  171  163 ]  % 39
        [  40  (>)  178  175  164 ]  % 40
        [  41  (?)  179  176  165 ]  % 41
        [ (*)  ([)  181  180  166 ]  % 42
        [ (+)   92  185  183  167 ]  % 43
        [ (,)  (])  186  184  169 ]  % 44
        [ (-)  (^)  188  187  173 ]  % 45
        [ (.)  (_)  189  191  174 ]  % 46
        [ (/)  ( )  190  138  182 ]  % 47
        [ (0)  (,)  128  139  149 ]  % 48
        [ (1)  (.)  129  140  150 ]  % 49
        [ (2)  (/)  130  141  151 ]  % 50
        [ (3)  (:)  131  142  152 ]  % 51
        [ (4)  (@)  132  143  153 ]  % 52
        [ (5)  (!)  133  144  154 ]  % 53
        [ (6)  (|)  134  145  155 ]  % 54
        [ (7)  pd2  135  146  156 ]  % 55
        [ (8)  sa2  136  147  157 ]  % 56
        [ (9)  sa3  137  148  158 ]  % 57
        [ (:)  pd3   la   la   la ]  % 58
        [  sb   sa  ( )  ( )  ( ) ]  % 59
        [  sc   sc  lkc   sc   sc ]  % 60
        [  sd   sd   sd  lkd   sd ]  % 61
        [  se   se   se   se  lke ]  % 62
        [  lb   la   lb   lb   lb ]  % 63
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 64 dict 64 dict 64 dict 64 dict 64 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 4 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
    /setd charvals 3 get def
    /sete charvals 4 get def

    % Compute numeric runlengths
    /nseq [ msglen 1 add {0} repeat ] def
    msglen 1 sub -1 0 {
        /i exch def
        msg i get dup 48 ge exch 57 le and {
            nseq i nseq i 1 add get 1 add put
        } {
            nseq i 0 put
        } ifelse
    } for
    /nseq nseq 0 msglen getinterval def

    % Encode the message from ASCII to codewords 
    /prefixinset {
        0 {
            2 copy exch length ge {exit} if 
            2 copy get 3 index exch known {1 add} {exit} ifelse
        } loop
        exch pop exch pop
    } bind def
    
    /enc {
        exch get out exch j exch put
        /j j 1 add def
    } bind def

    /out 144 array def
    /i 0 def /j 0 def /cset (seta) def
    { % loop
        % Exit when no characters remain latching back to A if necessary
        i msglen eq {
            cset (seta) ne cset (setb) ne and {
                la cset load enc
                /cset (seta) def
            } if
            exit
        } if
        { % not a loop but common exit point
    
            % If 9 numerals available then use NS
            nseq i get 9 ge {
                msg i 9 getinterval cvi 4 { dup 63 and exch -6 bitshift } repeat cset load ns get
                0 2 10 {index} for 6 array astore 7 1 roll 6 {pop} repeat
                out exch j exch putinterval
                /i i 9 add def
                /j j 6 add def
                exit
            } if
    
            % Read next three characters
            /char1 msg i get def
            /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def
            /char3 i 2 add msglen lt {msg i 2 add get} {-99} ifelse def
    
            % If current mode is sufficient then directly encode
            cset load char1 known { 
                char1 cset load enc
                /i i 1 add def
                exit
            } if
    
            % For switching from A to B
            cset (seta) eq setb char1 known and {
                setb char2 known {
                    lb seta enc
                    /cset (setb) def
                } {
                    sb seta enc
                    char1 setb enc
                    /i i 1 add def
                } ifelse
                exit
            } if
    
            % For switching from B to A encode according to length of prefix
            cset (setb) eq seta char1 known and {
                /p seta msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
                p 1 eq {
                    sa setb enc
                    char1 seta enc
                    /i i 1 add def
                } if
                p 2 eq {
                    sa2 setb enc
                    char1 seta enc
                    char2 seta enc
                    /i i 2 add def 
                } if
                p 3 eq {
                    sa3 setb enc
                    char1 seta enc
                    char2 seta enc
                    char3 seta enc
                    /i i 3 add def 
                } if
                p 4 ge {
                    la setb enc
                    /cset (seta) def
                } if
                exit
            } if
    
            % If character is in A or B then directly latch
            seta char1 known {
                la cset load enc
                /cset (seta) def
                exit
            } if      
            setb char1 known {
                lb cset load enc
                /cset (setb) def
                exit
            } if      
     
            % Determine which one of sets C, D or E the character is in
            setc char1 known {/setx (setc) def /sx sc def /lkx lkc def} if
            setd char1 known {/setx (setd) def /sx sd def /lkx lkd def} if
            sete char1 known {/setx (sete) def /sx se def /lkx lke def} if
    
            % Encode according to the length of the prefix
            /p setx load msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
            p 1 eq {
                sx cset load enc
                char1 setx load enc
                /i i 1 add def
            } if
            p 2 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                /i i 2 add def
            } if
            p 3 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                sx cset load enc
                char3 setx load enc
                /i i 3 add def
            } if
            p 4 ge {
                sx cset load enc
                lkx setx load enc
                /cset setx def 
            } if
    
            exit
        } loop  % out
    } loop
    /encmsg out 0 j getinterval def
    /padval cset load pad get def 

    % Prefix the encoded message with the structured append insert
    /sami [] def
    sam -1 ne {
        /sami 2 array def
        sami 0 seta pad get put 
        sami 1 sam 10 idiv 1 sub 8 mul sam 10 mod 1 sub add put
    } if
    /encmsg [ sami aload pop encmsg aload pop ] def

    % Derive the primary and secondary codewords for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Calculate the fixed-width binary values for the mode, postcode, country code and service
        /mdb (0000) 4 string copy dup mode cvi 2 4 string cvrs dup length 4 exch sub exch putinterval def
        /ccb (0000000000) 10 string copy dup ccode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /scb (0000000000) 10 string copy dup scode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /pcb (000000000000000000000000000000000000) 36 string copy def
        mode 2 eq {
            % For numeric postcode, first six bits represent length and remaining 30 bits the value
            pcb pcode length 2 6 string cvrs dup length 6 exch sub exch putinterval
            pcb pcode cvi 2 30 string cvrs dup length 36 exch sub exch putinterval
        } {  % mode=3
            % For alphanumeric postcode, trim or pad with spaces to 6 chars and encode to binary
            /pccw [ 
                (      ) 6 string copy dup 0 pcode length 6 gt {pcode 0 6 getinterval} {pcode} ifelse putinterval 
                {seta exch get} forall
            ] def
            0 1 5 {
                /i exch def
                pcb pccw i get 2 6 string cvrs dup length 6 i mul 6 add exch sub exch putinterval
            } for
        } ifelse

        % Convolute the binary values into the structured carrier message
        /scm 60 string def
        scm 2  mdb putinterval
        scm 38 pcb 0  4 getinterval putinterval
        scm 30 pcb 4  6 getinterval putinterval
        scm 24 pcb 10 6 getinterval putinterval
        scm 18 pcb 16 6 getinterval putinterval
        scm 12 pcb 22 6 getinterval putinterval
        scm 6  pcb 28 6 getinterval putinterval
        scm 0  pcb 34 2 getinterval putinterval
        scm 52 ccb 0  2 getinterval putinterval
        scm 42 ccb 2  6 getinterval putinterval
        scm 36 ccb 8  2 getinterval putinterval
        scm 54 scb 0  6 getinterval putinterval
        scm 48 scb 6  4 getinterval putinterval

        % Evaluate the structured carrier message as codewords
        /pri [ 0 0 0 0 0 0 0 0 0 0 ] def
        0 1 59 { 
            /i exch def
            /ps i 6 idiv def
            /ep 2 5 i 6 mod sub exp cvi scm i get 48 sub mul def
            pri ps pri ps get ep add put
        } for

        % Pad the encoded message into the secondary component
        /sec [ 84 {padval} repeat ] def
        sec 0 encmsg putinterval

    } if

    % Derive the primary and secondary codewords for modes 4, 5 and 6
    mode 4 eq mode 5 eq or mode 6 eq or mode -1 eq or {

        % If mode isn't specified then use EEC if message fits, otherwise SEC
        mode -1 eq {
            /mode encmsg length 77 le {5} {4} ifelse def
        } if

        % First symbol is the mode and the remainder are the padded message
        /cws [ mode 5 eq {78} {94} ifelse {padval} repeat ] def
        cws 0 mode put
        cws 1 encmsg putinterval

        % Fit the message into the primary and secondary components
        /pri cws 0 10 getinterval def
        /sec cws 10 cws length 10 sub getinterval def

    } if

    % Create the 64x64 Reed-Solomon table
    /rstable 64 64 mul array def
    rstable 0 [ 64 {0} repeat ] putinterval
    rstable 64 [ 0 1 63 {} for ] putinterval
    /prev 1 def
    64 {       
        /next prev 1 bitshift def
        next 64 and 0 ne {
            /next next 67 xor def
        } if        
        0 1 63 {
            /j exch def
            /nextcell {rstable 64 next mul j add} def
            nextcell rstable 64 prev mul j add get 1 bitshift put
            nextcell get 64 and 0 ne {
                nextcell nextcell get 67 xor put
            } if
        } for
        /prev next def
    } repeat

    % Calculate the parity codewords for primary codewords 
    /pgen [46 44 49 3 2 57 42 39 28 31 1] def
    /rscodes [ 10 {0} repeat 9 -1 0 { pri exch get } for ] def
    rscodes length 11 sub -1 0 {
        /i exch def
        0 1 10 {
            /j exch def
            rscodes i j add rscodes i j add get
            rstable 64 pgen j get mul rscodes i 10 add get add get
            xor put
        } for
    } for
    /prichk [ 9 -1 0 { rscodes exch get } for ] def

    % Split secondary codeword into odd and even elements
    /seco [ 0 2 sec length 1 sub { sec exch get } for ] def
    /sece [ 1 2 sec length 1 sub { sec exch get } for ] def

    % Calculate the parity codewords for secondary codeword parts based on mode
    sec length 84 eq {  % SEC mode
        /sgen [ 59 23 19 31 33 38 17 22 48 15 36 57 37 22 8 27 33 11 44 23 1 ] def
    } {  % EEC mode
        /sgen [ 28 11 20 7 43 9 41 34 49 46 37 40 55 34 45 61 13 23 29 22 10 35 55 41 10 53 45 22 1 ] def
    } ifelse
    /scodes sgen length 1 sub def
    /rscodes [ scodes {0} repeat seco length 1 sub -1 0 { seco exch get } for ] def
    rscodes length scodes sub 1 sub -1 0 {
        /i exch def
        0 1 scodes {
            /j exch def
            rscodes i j add rscodes i j add get
            rstable 64 sgen j get mul rscodes i scodes add get add get
            xor put
        } for
    } for
    /secochk [ scodes 1 sub -1 0 { rscodes exch get } for ] def
    /rscodes [ scodes {0} repeat sece length 1 sub -1 0 { sece exch get } for ] def
    rscodes length scodes sub 1 sub -1 0 {
        /i exch def
        0 1 scodes {
            /j exch def
            rscodes i j add rscodes i j add get
            rstable 64 sgen j get mul rscodes i scodes add get add get
            xor put
        } for
    } for
    /secechk [ scodes 1 sub -1 0 { rscodes exch get } for ] def

    % Recompose the secondary parity codewords
    /secchk [ 0 1 scodes 1 sub { dup secochk exch get exch secechk exch get } for ] def

    % Concatinate the data into final codewords
    /codewords [
        pri {} forall 
        prichk {} forall
        sec {} forall 
        secchk {} forall
    ] def

    % Convert the codewords into module bits
    /mods [ 864 {0} repeat ] def
    0 1 143 {
        /i exch def
        /cw [ codewords i get 2 6 string cvrs {48 sub} forall ] def
        mods 6 i mul 6 cw length sub add cw putinterval
    } for

    % Maps modules to pixels in the grid
    /modmap [
        469 529 286 316 347 346 673 672 703 702 647 676 283 282 313 312 370 610 618 379 
        378 409 408 439 705 704 559 589 588 619 458 518 640 701 675 674 285 284 315 314 
        310 340 531 289 288 319 349 348 456 486 517 516 471 470 369 368 399 398 429 428 
        549 548 579 578 609 608 649 648 679 678 709 708 639 638 669 668 699 698 279 278 
        309 308 339 338 381 380 411 410 441 440 561 560 591 590 621 620 547 546 577 576 
        607 606 367 366 397 396 427 426 291 290 321 320 351 350 651 650 681 680 711 710 
        1   0   31  30  61  60  3   2   33  32  63  62  5   4   35  34  65  64  7   6   
        37  36  67  66  9   8   39  38  69  68  11  10  41  40  71  70  13  12  43  42  
        73  72  15  14  45  44  75  74  17  16  47  46  77  76  19  18  49  48  79  78  
        21  20  51  50  81  80  23  22  53  52  83  82  25  24  55  54  85  84  27  26  
        57  56  87  86  117 116 147 146 177 176 115 114 145 144 175 174 113 112 143 142 
        173 172 111 110 141 140 171 170 109 108 139 138 169 168 107 106 137 136 167 166 
        105 104 135 134 165 164 103 102 133 132 163 162 101 100 131 130 161 160 99  98  
        129 128 159 158 97  96  127 126 157 156 95  94  125 124 155 154 93  92  123 122 
        153 152 91  90  121 120 151 150 181 180 211 210 241 240 183 182 213 212 243 242 
        185 184 215 214 245 244 187 186 217 216 247 246 189 188 219 218 249 248 191 190 
        221 220 251 250 193 192 223 222 253 252 195 194 225 224 255 254 197 196 227 226 
        257 256 199 198 229 228 259 258 201 200 231 230 261 260 203 202 233 232 263 262 
        205 204 235 234 265 264 207 206 237 236 267 266 297 296 327 326 357 356 295 294 
        325 324 355 354 293 292 323 322 353 352 277 276 307 306 337 336 275 274 305 304 
        335 334 273 272 303 302 333 332 271 270 301 300 331 330 361 360 391 390 421 420 
        363 362 393 392 423 422 365 364 395 394 425 424 383 382 413 412 443 442 385 384 
        415 414 445 444 387 386 417 416 447 446 477 476 507 506 537 536 475 474 505 504 
        535 534 473 472 503 502 533 532 455 454 485 484 515 514 453 452 483 482 513 512 
        451 450 481 480 511 510 541 540 571 570 601 600 543 542 573 572 603 602 545 544 
        575 574 605 604 563 562 593 592 623 622 565 564 595 594 625 624 567 566 597 596 
        627 626 657 656 687 686 717 716 655 654 685 684 715 714 653 652 683 682 713 712 
        637 636 667 666 697 696 635 634 665 664 695 694 633 632 663 662 693 692 631 630 
        661 660 691 690 721 720 751 750 781 780 723 722 753 752 783 782 725 724 755 754 
        785 784 727 726 757 756 787 786 729 728 759 758 789 788 731 730 761 760 791 790 
        733 732 763 762 793 792 735 734 765 764 795 794 737 736 767 766 797 796 739 738 
        769 768 799 798 741 740 771 770 801 800 743 742 773 772 803 802 745 744 775 774 
        805 804 747 746 777 776 807 806 837 836 867 866 897 896 835 834 865 864 895 894 
        833 832 863 862 893 892 831 830 861 860 891 890 829 828 859 858 889 888 827 826 
        857 856 887 886 825 824 855 854 885 884 823 822 853 852 883 882 821 820 851 850 
        881 880 819 818 849 848 879 878 817 816 847 846 877 876 815 814 845 844 875 874 
        813 812 843 842 873 872 811 810 841 840 871 870 901 900 931 930 961 960 903 902 
        933 932 963 962 905 904 935 934 965 964 907 906 937 936 967 966 909 908 939 938 
        969 968 911 910 941 940 971 970 913 912 943 942 973 972 915 914 945 944 975 974 
        917 916 947 946 977 976 919 918 949 948 979 978 921 920 951 950 981 980 923 922 
        953 952 983 982 925 924 955 954 985 984 927 926 957 956 987 986 58  89  88  118 
        149 148 178 209 208 238 269 268 298 329 328 358 389 388 418 449 448 478 509 508 
        538 569 568 598 629 628 658 689 688 718 749 748 778 809 808 838 869 868 898 929 
        928 958 989 988
    ] def

    % Lookup pixels for enabled modules from modmap
    /pixs 864 array def
    /j 0 def
    0 1 mods length 1 sub {
        /i exch def
        mods i get 1 eq {
            pixs j modmap i get put
            /j j 1 add def
        } if
    } for
    /pixs [ pixs 0 j getinterval {} forall 28 29 280 281 311 457 488 500 530 670 700 677 707 ] def

    % Return the arguments
    <<
    /ren (renmaximatrix)
    /pixs pixs
    /opt options
    >>

    dontdraw not //renmaximatrix if

    end

} bind def
% --END ENCODER maxicode--

% --BEGIN ENCODER azteccode--
% --DESC: Aztec Code
% --EXAM: This is Aztec Code
% --EXOP: format=full
% --RNDR: renmatrix
/azteccode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (unset) def    % full, compact or rune
    /readerinit false def
    /layers -1 def
    /eclevel 23 def
    /ecaddchars 3 def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /layers layers cvi def
    /eclevel eclevel cvr def
    /ecaddchars ecaddchars cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert from input into message bitstream
    /msgbits () def 
    format (rune) ne raw and {/msgbits barcode def} if 
    format (rune) ne raw not and {  % Simple autoencoder from input to bitstream using byte mode only

        % Determine the character count
        /barlen barcode length def
        barlen 31 le {
            (00000) 5 string copy dup barlen 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            /cc exch def
        } {
            (0000000000000000) 16 string copy dup barlen 31 sub 2 16 string cvrs
            dup length 16 exch sub exch putinterval
            /cc exch def
        } ifelse
        /cclen cc length def

        % Create the bitstream as byte_mode_id character_count data_bytes
        /msgbits 5 cclen add barlen 8 mul add string def
        msgbits 0 (11111) putinterval
        msgbits 5 cc putinterval
        0 1 barlen 1 sub {
            /i exch def
            (00000000) 8 string copy dup barcode i get cvi 2 8 string cvrs dup length 8 exch sub exch putinterval 
            msgbits 5 cclen add i 8 mul add 3 -1 roll putinterval
        } for

    } if

    % Lookup the most appropriate symbol specification 
    /metrics [
        [ (rune)     0 0    0  6 ]  % Special metric for rune symbols
        [ (compact)  1 1   17  6 ] [ (full)     1 1   21  6 ] [ (compact)  2 0   40  6 ]
        [ (full)     2 1   48  6 ] [ (compact)  3 0   51  8 ] [ (full)     3 1   60  8 ]
        [ (compact)  4 0   76  8 ] [ (full)     4 1   88  8 ] [ (full)     5 1  120  8 ]
        [ (full)     6 1  156  8 ] [ (full)     7 1  196  8 ] [ (full)     8 1  240  8 ]
        [ (full)     9 1  230 10 ] [ (full)    10 1  272 10 ] [ (full)    11 1  316 10 ]
        [ (full)    12 1  364 10 ] [ (full)    13 1  416 10 ] [ (full)    14 1  470 10 ]
        [ (full)    15 1  528 10 ] [ (full)    16 1  588 10 ] [ (full)    17 1  652 10 ]
        [ (full)    18 1  720 10 ] [ (full)    19 1  790 10 ] [ (full)    20 1  864 10 ]
        [ (full)    21 1  940 10 ] [ (full)    22 1 1020 10 ] [ (full)    23 0  920 12 ]
        [ (full)    24 0  992 12 ] [ (full)    25 0 1066 12 ] [ (full)    26 0 1144 12 ]
        [ (full)    27 0 1224 12 ] [ (full)    28 0 1306 12 ] [ (full)    29 0 1392 12 ]
        [ (full)    30 0 1480 12 ] [ (full)    31 0 1570 12 ] [ (full)    32 0 1664 12 ]
    ] def

    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                          % Format of the symbol
        /mlyr m 1 get def                          % Data layers
        /icap m 2 get def                          % Reader initialisation capable
        /ncws m 3 get def                          % Total of codewords
        /bpcw m 4 get def                          % Bits per codeword
        /numecw ncws eclevel mul 100 div ecaddchars add ceiling cvi def
        msgbits length 0 eq {/numecw 0 def} if     % Error correction codewords 
        /numdcw ncws numecw sub def                % Data codewords
        /okay true def
        format (unset) ne format frmt ne and {/okay false def} if
        readerinit icap 1 ne and {/okay false def} if
        layers -1 ne layers mlyr ne and {/okay false def} if 
        msgbits length bpcw div ceiling cvi numdcw gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop
    /layers mlyr def
    /format frmt def

    % Expand message bits into codewords avoiding codewords with all zeros or all ones
    /allzero {dup length (000000000000) 0 3 -1 roll getinterval eq} bind def
    /allones {dup length (111111111111) 0 3 -1 roll getinterval eq} bind def
    /cws ncws array def
    /m 0 def /c 0 def
    {
        msgbits length m le {exit} if
        msgbits length m sub bpcw ge {
            /cwb msgbits m bpcw 1 sub getinterval def        % All but last bit
            /cwf msgbits m bpcw add 1 sub 1 getinterval def  % Last bit
            cwb allzero {/cwf (1) def /m m 1 sub def} if     % Flip last bit to avoid zeros
            cwb allones {/cwf (0) def /m m 1 sub def} if     % Flip last bit to avoid ones
            % Concatinate the bits 
            12 string dup 0 cwb putinterval 
            dup bpcw 1 sub cwf putinterval
            0 bpcw getinterval
            /cwb exch def
        } {  %  Final codeword
            /cwb msgbits m msgbits length m sub getinterval def
            /cwb (111111111111) 12 string copy dup 0 cwb putinterval 0 bpcw getinterval def
            cwb allones {cwb cwb length 1 sub (0) putinterval} if  % Prevent all ones
        } ifelse
        % Conversion of binary data into byte array
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for
        cws c cw put
        /m m bpcw add def 
        /c c 1 add def
    } loop    
    /cws cws 0 c getinterval def

    % Reed-Solomon algorithm
    /rscodes {

        /rspm exch def
        /rsgf exch def
        /rsnc exch def
        /rscws exch def

        % Calculate the log and anti-log tables
        /rsalog [ 1 rsgf 1 sub { dup 2 mul dup rsgf ge {rspm xor} if } repeat ] def
        /rslog rsgf array def
        1 1 rsgf 1 sub {dup rsalog exch get exch rslog 3 1 roll put} for

        % Function to calculate the product in the field
        /rsprod {
            2 copy 0 ne exch 0 ne and {
                rslog exch get exch rslog exch get add rsgf 1 sub mod rsalog exch get
            } {
                pop pop 0
            } ifelse
        } bind def

        % Generate the coefficients
        /coeffs [ 1 rsnc {0} repeat ] def
        1 1 rsnc {
            /i exch def 
            coeffs i coeffs i 1 sub get put
            i 1 sub -1 1 {
                /j exch def
                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
            } for 
            coeffs 0 coeffs 0 get rsalog i get rsprod put
        } for

        % Extend the input with the error correction values
        /nd rscws length def
        /rscws [ rscws {} forall rsnc {0} repeat 0 ] def
        0 1 nd 1 sub {
            /k exch rscws exch get rscws nd get xor def 
            0 1 rsnc 1 sub {
                /j exch def 
                rscws nd j add rscws nd j add 1 add get k coeffs rsnc j sub 1 sub get rsprod xor put
            } for 
        } for

        % Return all but the last codeword
        rscws 0 rscws length 1 sub getinterval

    } bind def

    % Create the codewords and bit string for the mode
    format (full) eq {
        /mode layers 1 sub 11 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#1000000000000000 or def} if
        /mode [
            mode 2#1111000000000000 and -12 bitshift
            mode 2#0000111100000000 and -8 bitshift
            mode 2#0000000011110000 and -4 bitshift
            mode 2#0000000000001111 and
        ] def
        /mode mode 6 16 19 rscodes def 
    } if
    format (compact) eq {
        /mode layers 1 sub 6 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#10000000 or def} if 
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
    } if
    format (rune) eq {
        /mode barcode cvi def
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
        /mode [mode {2#1010 xor} forall] def  % Invert alternate bits
    } if
    /modebits mode length 4 mul string def
    0 1 modebits length 1 sub {modebits exch (0) putinterval} for
    0 1 mode length 1 sub {
        /i exch def
        modebits mode i get 2 4 string cvrs dup length 4 exch sub 4 i mul add exch putinterval 
    } for

    % Extend the data codewords with error correction codewords to create the bit string for the data
    /rsparams [
        [] [] [] [] [] [] 
        [ 64 67 ]      % 6-bit codewords 
        []
        [ 256 301 ]    % 8-bit codewords
        [] 
        [ 1024 1033 ]  % 10-bit codewords
        []
        [ 4096 4201 ]  % 12-bit codewords
    ] def
    /cws cws ncws cws length sub rsparams bpcw get {} forall rscodes def
    format (full) eq {
        /databits layers layers mul 16 mul layers 112 mul add string def 
    } {
        /databits layers layers mul 16 mul layers 88 mul add string def 
    } ifelse
    0 1 databits length 1 sub {databits exch (0) putinterval} for
    0 1 ncws 1 sub { 
        /i exch def
        databits cws i get 2 bpcw string cvrs 
        dup length bpcw exch sub bpcw i mul add databits length ncws bpcw mul sub add 
        exch putinterval 
    } for

    % Move to a point in the cartesian plane centered on the bullseye
    /cmv {size mul sub mid add} bind def

    % Move to a bit position within a layer
    /lmv {
        /lbit exch def
        /llyr exch def
        /lwid fw llyr 4 mul add def
        /ldir lbit 2 idiv lwid idiv def
        ldir 0 eq {  % Top
            lwid 1 sub 2 idiv neg 1 add lbit 2 idiv lwid mod add 
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add
            cmv
        } if
        ldir 1 eq {  % Right
            fw 2 idiv llyr 2 mul add lbit 2 mod add
            lwid 1 sub 2 idiv 1 sub lbit 2 idiv lwid mod sub
            cmv
        } if
        ldir 2 eq {  % Bottom
            lwid 2 idiv neg 1 add lbit 2 idiv lwid mod add neg
            fw 2 idiv llyr 2 mul add lbit 2 mod add neg
            cmv
        } if
        ldir 3 eq {  % Left
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add neg
            lwid 2 idiv 1 sub lbit 2 idiv lwid mod sub neg
            cmv
        } if
    } bind def

    % Create the pixel map
    % For full symbols we disregard the reference grid at this stage
    format (full) eq {/fw 12 def} {/fw 9 def} ifelse
    /size fw layers 4 mul add 2 add def 
    /pixs [size size mul {-1} repeat] def
    /mid size 1 sub 2 idiv size mul size 1 sub 2 idiv add def

    % Data layers
    /i 0 def
    1 1 layers {
        /layer exch def
        0 1 fw layer 4 mul add 8 mul 1 sub {
            /pos exch def
            pixs layer pos lmv databits databits length i sub 1 sub get 48 sub put
            /i i 1 add def
        } for
    } for

    % For full symbols expand the pixel map by inserting the reference grid
    format (full) eq {
        /fw 13 def
        /size fw layers 4 mul add 2 add layers 10.5 add 7.5 div 1 sub cvi 2 mul add def
        /mid size size mul 2 idiv def
        /npixs [size size mul {-2} repeat] def
        0 16 size 2 idiv {
            /i exch def
            0 1 size 1 sub {
                /j exch def
                npixs size 2 idiv neg j add i cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs size 2 idiv neg j add i neg cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i size 2 idiv neg j add cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i neg size 2 idiv neg j add cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
            } for
        } for 
        /j 0 def
        0 1 npixs length 1 sub {
            /i exch def
            npixs i get -2 eq {
                npixs i pixs j get put
                /j j 1 add def
            } if
        } for
        /pixs npixs def
    } if

    % Finder pattern
    /fw fw 2 idiv def
    fw neg 1 fw {
        /i exch def
        fw neg 1 fw {
            /j exch def
            pixs i j cmv
            i abs j abs gt {i abs} {j abs} ifelse 1 add 2 mod
            put
        } for
    } for

    % Orientation bits
    [ [ fw 1 add neg   fw             1 ] [ fw 1 add neg   fw 1 add       1 ]
      [ fw neg         fw 1 add       1 ] [ fw 1 add       fw 1 add       1 ]
      [ fw 1 add       fw             1 ] [ fw 1 add       fw neg         1 ]
      [ fw             fw 1 add       0 ] [ fw 1 add       fw 1 add neg   0 ]
      [ fw             fw 1 add neg   0 ] [ fw neg         fw 1 add neg   0 ]
      [ fw 1 add neg   fw 1 add neg   0 ] [ fw 1 add neg   fw neg         0 ]
    ] {pixs exch {} forall 3 1 roll cmv exch put} forall

    % Mode ring
    format (full) eq {
        /modemap [ 
            [-5  7] [-4  7] [-3  7] [-2  7] [-1  7] [ 1  7] [ 2  7] [ 3  7] [ 4  7] [ 5  7]
            [ 7  5] [ 7  4] [ 7  3] [ 7  2] [ 7  1] [ 7 -1] [ 7 -2] [ 7 -3] [ 7 -4] [ 7 -5]
            [ 5 -7] [ 4 -7] [ 3 -7] [ 2 -7] [ 1 -7] [-1 -7] [-2 -7] [-3 -7] [-4 -7] [-5 -7]
            [-7 -5] [-7 -4] [-7 -3] [-7 -2] [-7 -1] [-7  1] [-7  2] [-7  3] [-7  4] [-7  5]
        ] def
    } {
        /modemap [
            [-3  5] [-2  5] [-1  5] [ 0  5] [ 1  5] [ 2  5] [ 3  5]
            [ 5  3] [ 5  2] [ 5  1] [ 5  0] [ 5 -1] [ 5 -2] [ 5 -3]
            [ 3 -5] [ 2 -5] [ 1 -5] [ 0 -5] [-1 -5] [-2 -5] [-3 -5]
            [-5 -3] [-5 -2] [-5 -1] [-5  0] [-5  1] [-5  2] [-5  3]
        ] def
    } ifelse
    0 1 modemap length 1 sub {
        /i exch def
        pixs modemap i get {} forall cmv modebits i get 48 sub put
    } for

    <<
    /ren (renmatrix)
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
% --END ENCODER azteccode--

% --END TEMPLATE--

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: CMR7
%!PS-AdobeFont-1.0: CMR7 003.002
%%Title: CMR7
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMR7.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMR7 known{/CMR7 findfont dup/UniqueID known{dup
/UniqueID get 5000790 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMR7 def
/FontBBox {-27 -250 1122 750 }readonly def
/UniqueID 5000790 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR7.) readonly def
/FullName (CMR7) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 46 /period put
dup 47 /slash put
dup 58 /colon put
dup 97 /a put
dup 98 /b put
dup 99 /c put
dup 100 /d put
dup 101 /e put
dup 102 /f put
dup 104 /h put
dup 105 /i put
dup 107 /k put
dup 108 /l put
dup 109 /m put
dup 111 /o put
dup 112 /p put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 117 /u put
dup 121 /y put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2DB981ABA2ACC9A23A5
3E152596AF52983541F86D859FC064A0E3D5FC6647C3CAB83AD4F31DDA35019C
CDB9E3DD3FEBD4C2B36BA3CF6E6C7DA85E25D8A31A9BAD39BDF31FD0D1790707
9DE6A078E8A409D8295F642DF492AC4F86AC84383B0F4C6BAA7C22AD5A898A71
D6CB34D2CD12266C486B75E75A69C14819DD9BB8159088E04D4717E576B8482D
BDA52110AC8B8A80E4E9D58F470EEBD3CF44A1E1EE8DA318FFF3611B02534FC9
F4018C7C57E80570D2F634D98BE5D5EC6D95051157F0EA94A3D12BE0B4B79939
F82F8D73136D3337C44E314B0B16CB030D9A12E01FB667105F334C3EE965E5A3
D410D2F1531547A4497C355AEEB295CD3C5334BEE5232992960B757594B89F3E
52095042DBE6B4DA3C3AD50CA95EA9EBADA10630B500CF1FCCA7D60306743681
7E428D33B7F7C40B425CD58E4CD8AB474BCE6A307BC6C6EBC15A8A96E0E2977E
A33389154536F5C5D8CF036D07F24094E779E5ACBE5502C92892F10F4C6DB627
C7EC4C7BF20B39418A8A85D7FD9B0EAAFD871DDD41F93BDE5FE619AFB8711824
DE890E62C1969A6FE28DD3578AF43D58A728FAFF0B9FAA640962C8F35A26F76C
67F3548D6DB54A25CEB368B47F97EA2B0C4D7C0E7894A4F0C823C6C1922CF9DC
10E05600556F1C7C9AFB33A2DB6F8730F70D6BF94B1FB0887451F2FFEEF3584F
DFADCFA9A2D4846B8F0E51620E1327D994CDF973B837D10C90FF76DE22B47CD5
EE3183898D156861AB4DFAD34A1E3FA260B8164E6680BF58413A553E88F6100B
C4F4E8E972C81A5F88A7DBCDC308B4C3581BCDE13877B976B1F84330839FE5CF
C78551620EB803DF94A5C921F8EE24F7EF8FC4C3E1653514212631F54F90E3DC
E9EAF96E998F340C4F729ECF7AB430FDB7C0BE3DF2C0D23015820E28B743CAD7
7F0AE95413C3EEABBC69E852F53EE1DC260D7F1E712BECEF2F18437DB23D8E74
2902AAFBC733AC5BAA452DD6F3671859AD836C8564E99CDC4183D8495AFD99D6
1F0D65B6588CE7546717911E25BDCA6C2649E3A7466A3E2DA7C7994A30AB4449
672EFD00632EFA8629C1AFB7D53D801028F77C864869FE636213A69173003EA6
BE1ABA95EB07B13D1594BEFCC95ECB0A9CFA9892EE0677D6B6C250855762B7A7
8E4E022640F93169DFA0303A0D5E73BF3E0F4D4AAD10FD7E4EB20532BA30371F
E9F480F9513432946F9828AFB5D4AEAFA5829B2CB544E5EB634C4537EF7DF08A
A1CFD94A52DCF0E7CE4C5EFFB01E6D50558B75DB4C8D5512B06080F27BE62E01
2EEA6A0357441401458C842D3DD4C35B8F561D816B336216CE0C14BF77648AF5
E33912CF95872A1E1AB9A18980A0B29A881D13397C15E1CBA5D3E0B27943EBE2
F3003D15EB446BCFC1C231832475D5B7AA19E4CFDE119D6CD62D053C6D29C333
5F729791D17B3F7108074EEF4D1BD101CB33E01004532CB0D716D2E54D169C6E
80163E70C0E9081F31A1ECBAE079D2A518B790B0CB2CD03DFD034A0F4788E800
B0CD2DC1FAFDD487C2F381EBAB2A2F3F3AF82021B211DC9CD2FBA6A1BB3D4AEA
4C7F3D9A5C21DFF284CCB827D205A69638E98D5DD8E36AFC1A4481B5CB2A2E8F
D6C838DA6F81990F5ED928DC7457501B5C979FF4CD20A830896A460C5DB13D56
A3B2B5D9B292374A9BF392894DD99FCD6A1E655AB395E839F074D1596488700C
4E2891C8AEEF66568E82A8B826F9A28FF84D4D9BDA21F638EAF96880B4EBE0D8
081982F34831A03BEE81FC177700C2360D2A48915EC40D5FE85B400E175D5AF1
067FA0097904FB647757BB44B4042D30D1557BD0F7922D731142FD682139CEB7
58CA4C8C240A0B86B1888CACC507E24E04020BF1882BD9B4CAECFA97DB24D7F5
AD64C69454027F198BA35881B94EE9159A2D73E450C3BDAED66B886D6DEBC84B
653E165176228F88993F12A170775A8D7038BDF2FE8DC1F7B98BDC02D1E6686E
9B834F6C0AD90780B17DFE25F0A4E470CBA84E73F2D22BEE09A040F14CFA2C14
0FDA5A5149B5FAFFE49F55EEFC43831BC43A8326FEE9C7F469C0FC3B000884FA
41DA7318EB57262CB96FC4EC7F16CA07FE1C3BE8C2DBC8A8135953D6DDF20BDF
75A2B6D26074FCE752BD32FB9F5CA797775E8DB9BB9786B469A3CD65A0D9DDDA
C2A166E454A94860EEF5B5C12172DDFC576A03F6E6F8A735FF21A3E9CCB4CAA1
3064893487697986A42CB5888B2B0A79FA3C74E8187BDDF7BEAB884B70B8D4AA
AC6615745AEB906E08BF831CFDE222F58D02B428D55E9D5A3CDE74E42D8A2CB7
E1A3A9439B678AD438793ABBEB72B21C58981DAF3EDCE4BB93D95F4A1E943BBC
B3A012DE92FED4F232A3A7D60CE60B605151F9C7C18A5C653E5D6D15E5B49A63
73E7A339504D0ACC74B8B116EA88C3EBA2CC631AAB29F761E5F062966AD2FD28
7FFE52FA8A115DBE23E471094FFB3CBAFBDF11B7E9058313F2D069B2CE98A962
64645738F02A31E2F2AC11628724034ADBCEE012721EBF0A567893411F950410
B20754A7510D041FFA6144AC9CC46D846B82581F20BBD001D34D9764010824BE
61C30D05E5C5D100A24F1917F01799CF5BC4E50FCECFEA732CB50196825F0E08
8A1EC868C6D4357857EE2957E081A0E4372E31A8ABEF23C3F2EA0FEE57DE4D08
61C570175C41AA0C7A3A579ADF593F18B4AE3782D2552E4E0759C32E059EE741
2D8191E381731769F6648B3581CAF11DAE46471896666F18F02918B0860BDA3C
BD5DE777672447C23C62ACFC2611ED5239D6A266FDA6031EBC5A530C1A2FF7A6
B4380B9A4C877267854AD1F1677CB5433F28894ADF93D39EAB94541A8D232E08
22D082D0951A60F62B87DC028714EC74133A4D65F7D0D1296C0E189C4A42AA98
28E8AE7ECBB9FC8DFABCC6EEB1E9FB06227F90808EF31331CCC5D4C9A6182181
047902DC9FD0444FB94B60FC74F3B677758088CE6A159D940C5CF682335E756A
8BACF06AD7225D49B0002392C889B0FE2C71311D2596F4903D12FA20BA2FFE25
A0804B4BC282929BE31E0F46B34532CB5795A65218CFAE21F390792DA67775C7
B91A2BF4C16DE4F6551DAE3A5827F616BE9040EE6B1008DA2F99A01EF66D697A
6CD1A44E0A15D1F39EA8025E886A68A1E9C334327C7703EE721E497CA924AC90
7723106D913C5ED4BA4FC743CEA8D0F5172526107DA65775C0B1B77179D336C2
9B09B608D80B1A1E87CA1A84A833A00D980D919BFF56F6390E9D5B45E9935CF5
E69D003564462F750F7DCE02DC23CC215A0696B74D8BD3156A392A94F557655E
00BFAA035647568ED66157FACC585E411F7F428569C147DC43F6E4FDE693D0F3
9917BEFEDF61FB980B85515FF6424824E2D995B05CA1E5D3E8BD8D3281DB7CE4
E54923E84058FFC0A8A2C491327D0F87CE4C352B724167CEE224DABA3B95757E
4A419594BE4F92E78BA6D35D4C93D31ECC3134B24A45DC32445725BB044F09A3
AA8C31EFC0A2944ACE2F2CE054CF24DB350FB3C71115518C24BDC0F7E54250AF
9D3378D38480E1CB9029F31570C619A28F065CA4FED5665EDB96712ABEB33B9B
4232C00C1B0215F08D53F7E430887035AC25BEAF06942FD1B6C442253C887AB7
D694C1A6115C8990B4CAF1E81DD1FDDD6B03C00055BE956BE7FD8A4E1049AE69
EDA8593CBA8C4A41E046C689FBBF9F1B64E5856A7FB1C61EC815A56DE2A8ED33
41F370B8203D4E5B19C63AE9E6E0D26F4F3814B5AF48AD30EC9B8402C941FDD9
722FCAFC638FBB835F83DC77F93D367266FA7DFFFCB567EF82B1695AB4D94D09
B18AC041811027229DF431F5CB2BBF6ACCE9D500C8F075A74590641C1A607C56
D2B8624797BCD9C91C3177818691FBB4744EDB6056464A0B95B8D63F7C22309B
82D6126E2057BCC9FE5566D96B7A9B201A09B0D3252A5494C8CA2C8BA8A13C29
37EF2A882D61DA708C279F663D88A8E2999A0F3B6F98C49901A7631BF7708B67
54D0B4C52BF4BE0DA0439E6763A7C9D639AD4092E77B13D3510DAE1475C978AC
796F9B2AAD3BFF35C5A3E19B5E2BF704B3BBDF68CE48BA4FA2496D60E58888EA
28AE12D00E9F0816FAC190590A865BB58569A91BF0345D01230ABA361442006D
BA2C90EC2036BBAB79EBAFC3F217DBD5854C519235F9627A1C3C71D21ED38AEF
0BB40F3B86BB9F09A3F309473D8757AB7E638DC1C59A7F9BCD49DE4107A2E54F
422767FB94048987847205584309397F554744690ACFFDF5902FE5DB355930B8
71863217830DD7A563B0B3A4025ACE75B0E777B4414B62A13B50C54E0E6D47E9
D43BF769B9411B74E1069BF71BA873B4B8973EC9BA492A5DEA58D267872BB246
10AA67B143D0E2223FFB4991E583E629413CC894C3FA4869B72D19CE1A0CEC8C
0FF5E5A3EC1FCB7D3C4289813F0D249A11B55104BD60B2A89BEF44CC77CCDA9A
065B8B83B4F4253AA1D535290DCFAA4773452D110D2B3370F9E2FE5432B54A9E
644EB3BA9BFF62347F376839024CD5EF3C5DFD30F412DD5474B7933E6A1AB63B
4B12F2417C72D0543C26A263AEA53E5BAEBD67E23553A72E949DEC556BEB5D09
C4D7A89B14FE4EC68D0E3E9D65A64B285E53590F418EDA8175113CA375A29930
DDCF4C71ABB26CEB800C2C2B253AC1F53651C88A56ABE5A74F3B54CB4FFDDB92
60AD7272BA25EC2F6FB759AA6E1E7964FB55AD09F4EB25DE45FD01833947BD05
6266AA8ABB7DD792941C7A070FCF3A4636FBF8921C70298D42FE92F079DBA2AD
6149D9CF9EF7264DE6DFCD4429949B15EA90B596340713BD61926DDB2BB23BE8
F9DE38A31620A817420A245946E551463960A8C5C7295E3B3D6A59BCDF5E472A
40B7A2CDDAA43CD8AAFC411D037142579D11054A903E102DF0D0C7B5BB854DBA
F3F086AF991F7F5D5C730F8F9AF213F25786F3EC0E54530FF912F4876FDE16B6
A07D0DC4FC46EC6363BCB68B83ACC448B801EC43FDD2F8BE0E93D809FF81E38E
176AE17C67C85FEA58EC95435434C49A950AA955D8B20989C550AB1F1C31B7FF
99422E1F48FB7D6F327C6DBC4695A03903DB275B94CB39386E46579271870A25
21823E75C377E9D5B46655E8CD8F986372CF8BA846423E26582315A9D19E0BF5
305C32B2A0EAC3ECB275B1D8BE11A37ADF524944219D94EA2C5DBDA768828B6D
775DA8CDB09E0570E4ADDF462EFD8D3FA3F86B1DEECDFFB699AF6507257C1879
16FC615868C2D51F03CD57BA38D42995D9164B257441210084DC409B6EE4C119
0B2E17B0A8D5326DD0010E4A325D5F77BF935693BC90A00A28C7B5F74817DA39
F47A41E32F4F92AA04D30D810F7B1484EB53AD8CFC8CE8928B570314E0F713F8
AF127227190F9C16BB73D2A217FF801C391A29095DA5E4974D137A0CAA7DE702
E20DD4755B1D78739756A5E7EC3542B96AD6844199FFA2F5F2E9C64E2DA4FB2A
ED79869F745C59D235438251BC2E6D26112AAED20E06021D1AB896EE1F1DD2EB
437FBD4A25E42245C5A647493FCC9922E6DD7AF57D5D482921D1CBD6F0F02949
C27777144751C1E72F4EE2BC343D4AE7A8A8758123B54FB1A026144C643651EF
0907A376945E19A8FC7F98A034832A5820A481B0823F980F59623E0511593FEA
BDE6EFBCC0383242CBD4954027B075B21F10472059A480D6E5ED01C3B07461CE
9810251A5C5643EC7403130C2246E8616CEA25EAC7A0076731FEA8CC43BCE3BE
933FCE61067F5FD402E67E2B9DAD954AA77C5BC86BC5E4BCE2ED676D8D8EC7D0
ABC5C86D82180B9D5D7451C71B5149B6B67883578DE9909317928C0A92E3205E
F23015400A1763A6FBF67FDE3318AD2696685A1832FC31CF38589EBC7CA1C818
60D2B2211E04EFCCEA88D9A9082E82951EEB123924A267CB03C48889032F2892
4227E217FA28F87E01CBF27BF1EA60641A4238258CB7AA355908FE36D90F5CAD
FE992D03A33E47CA9AEBEFDA57793F39DC6A9E85D5B289F6B862B35DBCF82E43
5CD6A862F6FFAC36478C384C3BDB0148CB1FEDF55969C776E77917635B5A65EB
F2AD351D21CD3822D43289FE8EB0FED58182997097C7E9F4373553AE1CA92083
EDE3BBE6C3BC7009D15AB5FEC6A59E9FD1BCC7B2099CA15FEF083B9CBF7B890E
CDDDE6BA0AFF306C76500C945DC91BD533FF9A585CEEDEF79238C54E6168001E
26FEB29E523EE501BFA4F60B782B1499B07084C35A2434B4D29D3D8E2C8F945F
A9922443B68D07DF7EAA1F4CDEFFC438B597D8943E231B5216808A85F30EDC81
9DF5DD22F54A45335B4C2203887475F39D247F0E7347BACFEAF220ED82F9263A
6488E73C1910023E505FDEB143006C1A351D441AC57F9D52D2C6D63D78C75605
999885676BBBAD56074298E0BFDACBA1830BA58E87F436CC670EE8EB1870154D
72DDBBF3794F8CAAA3F1E11DE29752DD99EAC695838A19BB67A1FA3829B6E0BC
5301610A0351AAA749F456AE31ADD87D6ABADCDD1FB3CE81C3713F48780DF407
530CB284B2AC709F52EE7AD647DEF9FA4D2A867CCEF728F3D40CF34C28D21527
10160B3DAFB5FE16AFC9D36C6EC4021FC189005862082BEA60AC72B63AD27D72
FAF3C2D89DA2648FC4C65104A069212D87144E8533CD86A6D73DC7CD9DBA25CE
7DA53B000266F3871B24663C77723703315C5E4A89DFCDBAB384AE7EB2F455AE
AB191FED406F7F6EC9E5B8276EF5C4CBA041AC7E8BCEC7CAE840154BDCA3232F
15711ABD1E867A434E9787CA0A6D1F197597DA27ED2402CB2D84ED082E8D3A39
81E6EB270DCA4E7A90E2BEBD3CBB3A2BE3CAB926192D7292CC16845B6399A543
BCFD224BB52F21352732DB5154FA3442733066CDC3E186D8AA97CD801DFBE43A
116C86889BE198DA88CA978B8C40ACB67E8F7BA499DE68A6FF0DC72C3D00BA1A
B378B39610F15CA026F95ED8155CE3FFFFA2E2FEB352DBE14CEE1669F2387B70
55B91185FBBED764266215D518716EDA3DFC9E5DB6B148A553E75AE5E38E1CFC
6EF47B314D54CF24BC13856F4F7C976BB91D143DE32FF49BFFC87E17885A1893
BA1B8E441B08EFC04F7D103C1FFBB665194B3D0920473740C55FB1C50EBCF717
A2359B687FCEAD65616EE89A68F8D91AFACAA0B238EE4AF0279AF5BE5294C3DE
A7E1F5E6248C0210E7D40683F04B12A933C746ECB517CF94BBCC6E4CF49AC715
D8005AFECBDFB7A6B417DB8A28F8E9EAF39CEC1CA64DF37A5E66A76C26F721F8
A63B003A040A62F87DCF61B298F960D510BEFA453F118E59E7DE8CA3DD002EF0
127EAF733D5C61B5132348D280F84D159809CC71A3C6F7373BBFD8D6EF715D34
0016DEFF14AA5F960BF1BB9AC304A1823722843547BB4CA5EA4C41C6C2701C8F
7BDC810443F9DF34BA469A3260009B799871BAF8523C8763544DCD0B382D44C5
F75046AFF85F0B5A3188C2EE786CEEE5496A5AF4BCB0B429CAFC403FB983EFE3
61FD9F52ADFC38E07A0FD7BACBA530D2E4DAB2592AA9564843E7E2305047F060
C5FE4243FA8FDF1B5D4F61ACA7850A604FBC6D6970959752695C90F78961B4E2
C8CFA41082B1A37405AABCEE5BA3DC2B9EA76F486117B84728EC6D8AE6379CCB
402C2AA89078EC992C00D53151E9D82C65643F549A572A20F05107A41BE5AC57
8BA47FB90F68FE91BA3C6AD5D1A9B05E7092710495D7A302396299160FBC1AD6
77589988C88917F450648A58ED623975A4130B81E97C2A1B17B259D234B85CF6
1DE04C9E9801650FAF7F415B3CCDE72A7983FDB22A4443EECCAF1E56E74991BB
B734596379A991607836C6EA74BBC359E9757442444B13B230A951284C09101C
02EF689C8A8FCE588E1E18810BCB001AFB8F065FCBF8EF6BE145D3B0D70C6EA4
83FF99290E13574EB802422BDE10A913779C7DACB01E8E1587D9C2843A426FD7
3C0A565A6313C91B57365C9E293CD84D7FCD0058330B4EE55C975CF75029C5EE
A309C7949989491D82ED2038CF6194AF036EB3090451311D2E0315E7E13A0759
80B63AC736D73305BE7C76A6D637A543047CB1F51EAAB2F0BAC298957E4172F1
01A12BC5F2734A2EAE5B882DF746F9505BB13D08E34AE233023A69E02451222D
68E2F8F0544CE29F3929A98A589D9CEE75E5231C022E09F2A0667A4E0B5DCE18
56FA76185E043780F28F34A69D8EB0906DA30F444C44D23C2CE93E4B4CB8CC00
82A3E8FEC51624B4985803C555DB335C862C5FFBF5259174B7C713DAA31E268B
F4F188EFDE95404913076437F8D1E152C8508D33C8AA921216F5F8224E627A6C
75C6019A73F23ABD6E93F7B7FFC135F6F3E64BC20C82A49199DD9B31AD10B883
4DFB1EA3A574AB546C0F63F532F109B4E9209DE21B799A34660A4F48F0B49017
AB578C7CC48E49DEE5671489FA4BA775CDCC2A47E3E502781B7351F4AEC4ED13
630D7B8F86195166465B77004EA68A55687F6F201C451B87FF736360082D40EA
A2D85621DA7ED5B3310D90A6308DBF11290A1517ECD857A86D0F48A8B6855192
598857DDFD81C21DA87F119153715067EB8FC378E35EB2C644DAB026162A80BB
0D31346053DC2B0313815CE934743DD4F2ECA8D70A0F819C66CF84A8365EAD7C
F2BD83936EC95CE0868D63D4A4323354FB7190BC08126CB9848EB1C792575AE4
B424FAEDD9F74258E68EBE143B2A59260EE86885327993AB304322A03DC89D0A
95F0C6DA2570A1E5780F69B9310603F4E794409868221BA6A0B43F7386C792E8
4A28FD1D7230291DFF4A38A815C42074168FD9656BC9246AE2974E050F16CFFD
DE9C3B93E9B984CE543AEBFAA469F5F62BF91B8630B8601D9BB5936C518995D0
72BAE92D18FA8618494A36597967A899EF21828B2581657464EBD30B41C49F9D
7DBCFB0DED2955BC96BCCC1EEE8C1AC9185EABFEB68470A481E554AE830C1230
C24A3000371B3976774A03E71F49A829B8F0AA3EEFD4DD11F33FA1D3FD53B8A2
B7AE9DA31A86CF2FF257557CF0E2B81D0C341A232ED4AD6574F20161A512ADE5
B21584D4AB863FE0DC853F461717870912BC6BF62922CA440D6BF85C10066FC2
C3B6371F2BA6D2F1D375FF7AF0876B8004746056AD2776151B6D0F9EC915CB45
A6C87CE1A2680E7B33707C9D24A6E235BC9FFEC56F9D9B76B543F159E9508CDF
9C9D46374BC114F6BEE39EC7F3420FBE28D6D2FC969A3E58E1B1F94B263E2C7A
3D9DB057E2B724C18DA78FAD0017C2141E3A7BF828A0119CA10CCA6CBCD2F266
1BF38C08D659178DEFE18209DAF57C0A42C28D7872F9383B07861FE2C803F7BB
B8D8836B1101E7300A9FDE5A646EF50906B13DD7060174DF38735D376D6885B0
8CC3E6D1BD1E41CD16A16CA6B624D64D8F869A9D2F9BB543C2EB5D791E861BC6
EB84A63BB3A9353FD073ECC1A63FC651CC3DDD876D397F009E6211108052B456
31D802DAA645B98F6DF8654F67A5E2D29C70F0387245CF51F98B8F1DB95957AB
4F57A79AF0FF39D642FD55BE24D6FD26F423618492552787092B36DBC185490B
03BDA185A63610D6F8F5D66F0A95070EAF52CFFFF5D691DBB31A76003FF1F261
C0F08D6330D4447962E5FFE9851F7722789EA9D5B3F2FE0BDF1B9308D7B7B6E0
580904A27F03629A106BC03A122FE70051496ABDC41453A4ACA30B059EEA3180
B7AACABA9A7FE2B77B713D7749C34C64B75A26EAC5CC637AD8FF203F084845AA
AB9539DDBCFCD72E8C2E58A690D4326B6743113386BB674EB96EFFFCBCB83599
E3373AAAFC5FF0740DD8EA1DC349B2850BB5C463C1F5F937A52D2380611BC4CC
CF2FD83EAB84257B577AF947EB9B90DE185950F32F480B1F39FEA2FFFE828A80
636F709C8ED0F6C15FEEAFBDA650DEC3260E8B49252475E2AB69BFE2CEAE69DB
5391700D3B5A5B8AC75DBCE5368C533BC10C2C4017E99556960FE0EBEC3A3017
6B1433DC7417058A0BC23744019FA84C7E7997B5B0A0F4BD5687849ACE6AB5BA
0DD9D3C75048D7A5F65E3F9AC33CD652871362C808D812812E96B5053D5CF083
CCC86828A4160485BB022EA24998747BFDFA7907C0F8217FA4670C7138111A6D
FD8981F1D09FD5E0011BAF0C92BDABFD3956D0EA3D339A3AA375C79E20C1C077
27D9525665647CBC06DB48E8FE2D074BF9EC9C8F9FB6F07B26F837DAAE542768
9ED5592356ABFD5933DF5801EAACD89A5F05F7203F042F690C4B5EF0FCC3AEB4
A900E6277E047C775E628FD5D725FBAEA7469E4C773574AE36DC9EB4DACB9142
DC7C2EA4CFB60DF01F7B98481388F0FF30AEF6C6F9088E71A53CD8F5A17F5095
BD695CF6D816444A192B9D643AF5F3569A756CAD087DE9EAFA53140355DAF610
E1DCFDFC888E749359325197F08B2ED6DA47722E42215A34793AF846AB0ECEBE
F5BBD42BB130066BA697BA9A3CBD47827808D598A29735B82E9F82935CD1B090
5DFDFE36817DEF5BF741E4D8F0CE950801AE2D1DB381A528F63E8AB56B0A2DB8
A670866A8C942085241E8982D6D57E8DB91D2790A5554578C5B7255EB12503CF
9AECE2488303B3A63BABE7743BC14C0FF5D56F49C6831C237438F61BC6F31CD9
B0378DF8488150D10416289C0210C83D11F5A415DC7515E9410F1398D065F548
F03F22F9FA73FE5E640E98D77119C61877BE93F57C3F8FB123E6685188AD6F68
120DFA4EAAE5AFCE1B8F4FD135FF7E00C0DB6CF15F8ECCD495B542B5D35133FA
0EF73AE8CEAF1C809B7BB8639F23889A402DADAAC3C0C63CFC3BB2F462DB29AA
C4A79FB2C3B3D32C4663A755A0AEE14B51D03B024EDED004C3693A17DD331C94
88832BBDB71F5ED3BE32C63473B9489A2FEB2BEBF1C600A1A12435AA38B11A0F
98BFF07DCBA81C194D53E9C50825744B967494C6CE539BC7F67F1AFD390CFC36
A2A7E71D9C2DBC66C59370022B80A72057FC0C8AA536F73B786FCD7407FF2982
01C0047A48A5A3E641DAEDD194EB1AE5AE82A5C0CB2EF8F44E0F482D2806E3EA
27904EFB57A92FC079F2079E575F9A6BACF99723DABC91B065BE88DDE7A547A8
0269A308FA6E8F6761D7CE21C043849DA3F357880E35AC7CD2B71D950D586560
F3D398D3D4F043CA209C18440ABBE728A448389B078518AE5B492F6C4C182CA6
A4F656BD9BB779738D9E0F4A4F4F172E77DD4180C0917D524C73183399D551CC
E3B6F1AF3AC7B47B5F6A68B2876B238BD81C8F3B88D333FEA2914CB506ADA7EC
222B6D47FE0E7305691FF8F67321A13DDB741EE269522152D8E2EC2F06637BA2
8928B1DA6A29B9BD2DA62D4D9187BED9FD19DC5C0BA9E8502A88FFF143F7DE10
51923284637C2A8E8EFBF374CC611EAE1563E3ED4C99546B44C9AD91C26E8E7F
700601825E12016FB99C8C39336D688555006929D6A3F958E45E3C9EE106A228
CC5D66F18FF033BB90D40BC6BA67739BF1A6D6187979B6CC4D48EC4FD3DBDF9D
68734D7D4D5C795EAAEE18D555B019E4E9BA34BA59E804FB3D0173A9DD125F15
097AA1AC0B1F1FD7675A6B9244A945D612DF78B0A3803EAD6F518231408E19CD
1E6C6EAE4EC4E26626561FBF3F66F308841E205DA92682215543C6FE29421044
1A8DA0EC9D72B78F6BABC9EE4889ED5532170E5FC13EE451B4B62535A2C40645
B4AA5B943373D04BDC4EF0A552D0D255F7E0E2CF93DF44D144B81B78B09D69A4
D25D5838BD95CED6B155CA0C8B5EA7D09D722132AD12D49536CBBB2CE391DA87
3F391BC280BB7DFC42A0F2AA6A9CD21222B46CEEB509977BD02237B91D98E63B
12F7071FF5DED3E4BF158B139618F846A805E5115DC5BCB71A3973F5116F4B10
0BC72A15FF32CF381407BCE7E81C0288F2BBC90F15D8BB7E3DC0C150EC2D4011
5508B787F94444C475BEE5C43ECAF7F34622E21EB6F662B0AD37F62D1F136590
C33CFC70365E84D36827E3B5F8CC770AD29D1993CA93200566116ADC2DE00D0D
7E393505172740E6D74D56E80EF8776505F51AD5A435E4A9D369AA76C0475D35
4F08CA359916BFF4D94D382F584A2DCBCB181501155EB666623281E87F9E8A68
1AC8234C40350A9BB60BFDBE7C133AC537472A1F68B6B20E572B1F8D7C987075
35A754DBE9550780793077E17C2BDF9166517C8D1BA99E8F7DE31E6A7514CA1A
6F9DF712B2D140B58BAE5B8B501534E3FDC76AB7A2C1797FCFB99504C458283F
0A717B4BCA114789204EDD84C71C18BE24DA9CEA5EAF1B30DCDA322E61CDBF4E
31B39EC7BBB6A4493EE32861B496EFE9251DA03E94036F22DC5958C9FFDB95C5
E9D339D12FC5281EE8C1C3A4C9F519E7F5835FC995C483E93DAC0C9ED548BF07
BF8BA09D7602A6E045637BFF5EAEB1857A0E3EB1222304A082DCC89F6E85037A
AA8D00BC20DBC89EC7E6537DD34D17B6C9EC9BA75A363764CA081390F38A752E
9BBD211A732CED4F64D6EC64230A8AAD263602357ED174D102387C3F85A397B1
6F49313141B7B339584ED4CA1F52BC0DD9B7F8A56B45FE24AD930FFCF18D69D1
34F3BB744922DEE5DA1B693E98A696DB3DD65241885C5D14EEFBDA1AB5EA8A8C
30795EFF16957A912881E55CAFB66AA699E8B824EC05F250AD72C618687BAFD8
29244AF2BC8B29219D5E02C933743BC226C9E8E3AAC8A97B8E8E885302D9B2C7
D35A0B987FFF984DDBE8C1B083E63A429F92339F0C12292B27918BD2F721F24A
B13AD81D6668C8E867590129A72EF07767625266AC50B5210AA6AE0CF571E345
8F31392C25C28FD192BE8E847DACB372E2DE07252D9DCC91402C918F6AA9BAE6
FBAC65A1AF32BB065055102A74B52FB5B08B83FD46846B74D15A99AF455D3B48
9FC410BD315DA70CD76CC7458E3DA70A6D46863E345047B95783B2B1DC62F557
8E941DF19A971C320AFE86263B91934B49380E1824C545A2C980D0C8602FD460
8C7EB15945F9066BC4064C278A9205A7EF74B389159C5AAE10EBC481F161D2AA
0247A4AFDAA2C651C344C645D8E3CF48413F99F7D4392250913AFBFC6DE6A12F
2EFD83E4BE698770BEDC4F435DA44BE9AF2309987F35765674FED2D52AF00B04
090CA2
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMBX7
%!PS-AdobeFont-1.0: CMBX7 003.002
%%Title: CMBX7
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMBX7.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMBX7 known{/CMBX7 findfont dup/UniqueID known{dup
/UniqueID get 5000765 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMBX7 def
/FontBBox {-55 -250 1289 751 }readonly def
/UniqueID 5000765 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMBX7.) readonly def
/FullName (CMBX7) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 58 /colon put
dup 97 /a put
dup 98 /b put
dup 101 /e put
dup 105 /i put
dup 108 /l put
dup 109 /m put
dup 119 /w put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2D436DBDD5E3DA259BF
5063CC6156E2C2A4E1D07FBFC23D148DDA0199AA319E8BE46D2D7247A74E3477
82008F1A3AF6EBEB9516970E4048276BA75EC1E829945A7BB4F1AFE8CFEF2158
674DDBEC84C9E0597B166C1B53AB7B62BC74E3DC25ACBE3C29ED5D6A2BA1B8AD
90764BDE2872EDECCA6D05F7DCF5FF313DDDE00BD818F647EC5C31EF7F7E63D3
2C73A2B195AD4856572A42E6974EFE602B4F3D31A419C8E7E8A558D60E1A1713
F37870B9342BE57CFA1AB37F9B185DBA1EB353BC3CB43502D1E1B7F2B7E846A6
5A61A30966F86310FC64EB247F157DD6C4F2E31659A3434EB58B01ED8EA895E0
951AF5AE7B31A57D309BCF180A89553B1F283CDFC41791587C6E44BB8B50D5BE
1DFAFAF1559AE26B2F0DD78CF503F63F711A4ED79A1511CCCF07A61330CA999C
3C5B7782E767EF7E0086B436CBE0C57ACC81AD29D8F05A937FFBA72CA6C3C0D5
E8A44BCB9CD6E63DC2CAE425DA719E8AB1C2A2D81A324654E96F4D76CF1ABBB0
147C5F56C3AEFA0353EC7853604F6DEB71D7FA5803FE61C0315797CA0357ECFB
91B02A84499F9209CE5989021F4D27B2B20D4793F6C81591CFECBCC22005F89B
CD1A089C36E659BF3BB92558E769314FCC68398AADFD2A38BC09E26E63BB4F3B
61C9CA955E70F4BC3D4DAB6837B48AEB5ACA064B681E478711620AC237214EA3
426994109C42EE1854A84CFD5EE4CA590E8B9C40478F84A19F8F5AC3A75F916B
9997A071F6F75236CCEBC01F8744E8D294B574AF710C26EF4062FF2D2FFA8F4E
3684C403E4D9986D1216542D0969FAE0DF1BBC8B1F666C93E2CB175DDED77EA9
1141B726915C25CBED68EDAB7158844A1AEB62734BC085D705DECF3F909C77E2
66FF93CDB538BE4A2C3A1640067A4E79DD89198E1EAB85977449E60B6A34B551
B2A7B75E2D5C3A2B7E9A93166FE9BDE0DC80488983F4DD432A4BE12F77BECD6C
88EF63012552EB8BCFA44CD4A1F4907EA36FEAE3DDFB06973CBF633AD9D22957
1E11F00B5E267F8F64661B935CF35E515682CA911C1B6C18317277ACBA335FC2
4C3E26AC62D547755D49AEDE8F2FF924947364E93BB7550D5216AA57E6466095
80ED8612F31208FDC4255D5A2832ADCD986C2C6544E878775FE1276AC6D57B81
DE28BB1D7930C729C1F3DA4F972D3A9E6405570E4E832E1DA4435F3689BD44B1
C4DEF95F19A3A0FC8B0FAD70E3BE368786043C04915DAADDF2863955575BF75F
F087C4CE3922099FC716556C705FB16BA28A9F3818A54143AD5996FB624ADAD8
AB688DFE5F71FC7BEBDBCD15CDBCFC13D1C5E3B8C74A1F4D9C11C9F08FFEB259
1B755FC4C50C28354A8699F74FDAF0BC622B6A0334B6A36E15AECC2517398C47
F94137CF043414300A797E722A03CC2A47FA2D4AB88B870E7429DC7535A9C8CB
3C88FF3ACC8F8A909ACE3574800E5029E9895EF44242B7690DD231E88A03EAB6
23CBEAE5C7473EF61E638FAC3FAF61F88E1BC25A100056CF282C8DC315F83207
F6085B92DDFBD8921784044B5305FDD91EB8DE1E5A555E6F05FEC65487BCDF1E
80BE21F43C3619D66164B82C698918B6FD807885CDB45E3D87E9FF9CABC08AF0
335E667BAC4A62B7C104DF625891533637D5CB93D8B97A9D78C40E257B49CAB7
E7E38BC9A7B21893F96AB10B053402A2CCD1903812F3BF9689C2D5A8C6A4CE8C
9EBB762EB7C7CDD76B8C85F6D4203B086D74F0306537248CBC71BF3C06888180
5ED19BA5F433FF6B862DC96EF23FA1FA880907F92B15B3DC9586C21B006A2CDD
080494AC14E9DF9C3EA5EC5AD5F23864D39B83069DF5AC7FE1FC522FDF88B3A4
B62B4A8E6F97A4627F8CB3966E87D33346FF567A32868DBA129650FB29D0CB99
CB2146440C12635F7FDD2CECF373EA6DF1D0135AE0C95A76CD17B80E5A1BBF10
10ECB9826B6E3533F961B1365E6B380223D0DFD3A9E1026EBFF8B60F10BD7B30
6ABCA33C0420FD910AD8ECE3AE60F771B65DD2EE0571CE54AE96CACF3F737497
7EB4762C5ADD08C8BB20FAAAAB325F1F9BEFBAAF7546DEAEB12C1CB931EA38AD
7AB938A1B39196835447A7278AA3ED696A9DC642869F6EF6536D754DFE1432E6
A6332292975A81B4FDF5BAAD895D06C2FE120B9EC9F39B42C0DDE3D1F1026F6E
694338884718FC33BA07EACCE71515FE4FC8F2758F8FE40327F0F48CFC3ED47F
D9CEEF14CEB946C7160A5105E3C4A48AA7950ACA1CF74DE90F9A3186E0ED717F
3CF64CC744D3D4E84A26C23FA022A79A0D83D65A6D7EC11EEE915D020DB32CA9
8C411414AD846E37244B1A8AC0F0075D87464EBFE7F0F2DFDED9EC1C2D7EE984
7D698CE43875F5BEAC2A8098DCC22BB0F39CC9EECF3DA61DDA5DF5380AC025FF
25EDD31FE9E411127C44A07AB23E3649D2C20C6A0F46C4D2085723106E1542B8
E06303835FA1C87C8E6205341D3E3E67121E77D3D5087874DC72047A99F971D8
67F25B1F8C204AE489F264C60120BD3CA53472806776C6DA50C7E22A92ED2C5C
65576FA300A7F093732E46AA63B0366C04238A89E222F67B4840533D7A48400F
EF5A383F7EDE6F38CAEA0C2CD3D5EA038AF0CB05006B0A3449B83E310C8A19B9
7B06732FBA67AA72882EA80FDB20EFE2B566B5F2046DEE5AB92A2B834ADF3C93
E3BAF6D944BB2342DE57745C6D0082801926526D416A325F956FC37362935746
A66857352FF1ADCDFF7AE265116822DDE4FDB1F4BBA4DCFE499202446105E4C5
95B6F26C3F93F65F0A5E7636D798DA7476D4417CB56D7F70F3AB2776AD672445
3204C0391B8CFB40542310650E22AD6B6F4F2BE27FF4AB10FF3D38B4C2DDEE7B
42FEAAB6F91F21FEF35B54D0D131A9E1F6AA5A9D72E8819ABA5467C33B876397
E816FB952B7D674BE398437B147A7EB801C178695FFE658B203D51B1F35CE144
A31F9100E11835CBD8095AF8A71FE4CB829F474377DE8AAA5CB483A8AE341C6C
85631492F67AA423418552B14220DC11A574C60E32ADF96ACC64B0A8029B3611
3F01B3078431C63AF806F90C3D60ECE9F27D22E9A1474054A561B515DEAF0790
908EF8664BEACF69097D93DAD19BF3F13A8364E0D511238E413521DFC02A05BC
52864AAAB0A4FAE9378DBB482CF3A5886BA635BAEB00551EB095B47D6A924D14
F4E51ED1E98078E30F83852EFF4D5061DB5A8C727486473C8BFFE8B03700D098
F5249F22EC63772F5B283F837249378D569D537B3A1CD3325DB8F09D9C8FC30E
A52ED42724617443F49F4AC9BDA9CDF47D34EE29037C5F70E0E689C686672869
41EA89BAA613D5470C7A25C07C489956D4F4C03DA33758B33100CB08770D6EC3
052EE52240A08107737F9ECBEC53AFD5EBA7B493D6EB61796AD765DBA79F807E
FCE53F29333CFFEE991698F3D56E2F0EA8C5DF6A649DA42C431AAFB88B959077
F3F4C7C9E9052146A52EB2CC1C1D74AA2E8A7E7E82F1DC16A2E9C6789519A64D
958919A92FB5CC51688E115CFEC3B74C877E52315AFB5B413D76801E9F1947D4
A425A95682AED5BFF249530EF3ED4002CD143C66FF89EAB658368C20C54E6DAA
E9648F60B61E5493900304DE22F53C19366ED95583068F425E030300A4E7F89F
9444155DF1F1B6A67B4532C9ED9B0A0B8DFE0716D005A13A8FD7E4C017B16D4A
41946238D41BB88E3438803D483C3AD84E3D8B745612E9D103C9DCFBE7523E55
931579444ABE23F24232FEE409CFA77394D0EF74980FDABBFA28BEC8579AB691
4C562E28AEA4FB2ACB4D6C7971E1255307C22B4186D29CD488800A840A462E4F
58051C162909FBBD16CBB7BDEC559DAFCF7B92AE26BB392E5C1A2D299B29D32E
34C915B4CDCC0EA767CE1AB3B8D7D6A73FEDC47BA1F316B1BA62D433A7013985
8D2BF6178CEF1B6DE89464246753D8DE5F1C7A7D56844FF5201D6FFD604F6023
59E032A8151F49E52544DB9DB472EAB10A629FF3D76781F0C101B815B7E87ED4
25C2C31F80A0C48E0210CA9DB261809702EA781955CD13BBB7914D3BE71E0C8A
95F8DA3724972A0C1F3C6372253ADD295BDA8F8230D4D94FECE4E93185E88D01
6CD6A74C23E04267DD0CEC1D4052176AF0C95761F854B90BC1D4CE1FAB88599A
FBE6658134C77CAC023076F43DE5330431A22F4A34787BD2E60AB4309F238BE7
32E1958E3EABF58F54D5D58814B68D81D5B309B7473BC6A7B0FC00B245B0D78F
7E1EA74A91A737094A9996F76CF9C309E6A3FEE8CF6A94F3E436DCB50ACBB48D
ABC08507251213BDA9AD93B1D48950416069DE9032BA1DBDD83391F92C041B42
DB24EF5D2130D301E07E62E793BE170377AFF7CF65381925A713D4C06B64A0D0
D187E630287B404B514901E44C104CC3520E413A95058D7C3860FF9F8F6FD8C7
BD419ABEA91904E0BBFB61AE6784B1E60508930689B8F096E06A919E1337FAB9
F56DB6BC3BB0CF674D226FC6DED6ACBAB0A2ED007384CD10BDB568BAD39AA1B3
ADAD4952935AD31FFE2467766B282361731F3ACB073E8F8E82415336D40767C3
E2B11190EF67DCBFCC928921B2708563EA48115CECA006703CD64600E564CA03
F8EAD42BF3F30C93B800BD395257A29CD84CCE5CD62CEFEBB3A06E03DB2C67FE
5ECB622D076F4AD406F97446E433F56A5B29E4B47949F946DDC61F933743E862
527BD7B9DF3A2AAECFD0C1ACBD3235B68DFDF82324A9C0A992004BA92403964B
2EB57EFE4667FAE876AD2388AF886335E5B4B3D16F5405E6750F5C62DD68A620
90915BFA64302F8B06A0BB25AA5CA490D0097208EA1CC75179071A1524546F19
F9E0CE1BB397614A5CA4F64400781E7B21A3FD21871CF3ABC04BF19A163785C9
A7985518DF3A4C7BE3955358A00D78A52D6B8D56F057C0A3E7E4DB3ADC77A834
3F060A3BFDC6D402762324D10EC1048D65DE85891459B2E439CC020CF6F03EC5
4DD6EEA54AB4CCCD0F49D71112A49212F4DA5D78853D9507942C1E7474F40DAF
94A1015851AACA3E027FD60634CD04B9E85B46AB9418053CFEB232FC8902FEA7
1D468751BF01DAB073410DF99E72CE4E3B9D38DE77582653DC81B52BF1A9DA0D
2CE3DB3AE828E4BEA767CE81A10443B76F5081EED71627B58984E2F0E6FDE6F8
89F66B9FC73259FABFB0E72623B3964EC0B7582AE85D2EDBA59F5E6F78AB4204
7A852863BAEB8449E2D91204F867160B13B6B58F03F182D4F25320B43C42E966
394C72945D8C9B9220797F23AD3F57DE1D490CCD12E96C3A2B82C3C670F3561D
A2A82EDFCED0B2581EAF82CC78B12D0DB6439235ABB83FAE0EEF5D8E3E16318D
2A9A8DC539D05CAAA101F5CD5D89B536D9518917B7ED99C42DC27DFDACA35094
027043AF20E96A87F5AB0DCE8B80036A88159943A4AB715E6BEDB2DC2E76C530
84510D3F5D62F8E23727FC2BFF4A9DB585E0BF64B106F196E2B04123AC9F69A7
1A6F701F43ECB5DF1DBFB6DF06F366E3B5216E565666BAC8A6885EB4401C9A87
781E69DE0C45CB999958FC084211A62A32ACE7EC0EF0F1EBD3556E9F2F8C30DB
7A718BA9FC4D3C695B8E1A6D8753C561D3232780704FC769CD70C2ACD394C3E1
505B9C9AFD9B9B3EACABD5C71C0BE34C5230708A8234A4A7D439083AC984493F
0F329BBF233FB506401078F28F26D4BA9D392393AA190889B971E674BEC2B608
C98DCEA193012C1A22E8AC11D7B62888E509CC93AA1C4BF44CEBE511212C3B5C
174610B75BAA75D00B73FE4987964D9E3437ED627C69F5B29F8AE809F7CD9369
0B2469ED90A23A85CFE47C45EA502D7686A7AE0307E9067C4982DB37F159A70D
4E9486AC607B27AB6794968165886146409AF33F5B3562B655B29AB506FE5FB6
E881BC149A25835C518F1DBD010C6DDA3659ECCA9526F0621567152211E52AF1
17505A2DAB2E2D7B84C6264BAA3BD7488640B649734ABBE72819807CE2E6A813
B0648D58E8526ABFCC7DDC7CB6D01562C4DE039129CD2B53E182C02EEFD33E7C
2EAC23D891F3035299B8FDC0BBF5E2FF053D6B32BA4762A8F65A435568DC8C2D
D26E1257BDD7358027E2329F992D4AF7DD7F140C2F0F7AB20A28D33346CC06D9
3C51BF48CF2427EF89C80087739A604E6B79CB8F6830FA078BB1BC7B05E39176
C68EADF951C9BBD0CFDEC807FB8A3323181AF9315371809B298AF9663BF401B2
B8550002DF570F5B81DB4A969471061BDBA8C7E0896C2F2D6CB92A21DF4A81D6
081B099E816A6CC9D562C067981D2138DB82C7BE6FEB90D61E2959DC6EC6C194
D17E64CA09C69BAA0A6D4F837AF1F91FCB0D11535B2D0656C7F23322F02E8733
C262287F2457BDA329141C82D906F2E9041CE7E35D92BB4016E55AD851F8C93C
DA70C0F39549CB35F599989DFDF1E5453EB872CFBC56DEA081FA95638A78F61C
B7A28E43A9960025C2D3E4237A4810FFB2090A40E908F7BD4AD84C7D9FB0E11F
11265F5251E84C2668B39C2EC75392459CEB04BFF0909F79990961711A65443D
F4EB969FD245B0B19D55FECDD1F58B64BC250A54A59241AD6C949C3EF9616DD2
591CDA486C1E778FAB86788419399B033EAEA91AB2DEF0ACCE887DE4910D1731
94D0883518B92F02856CA47A63ECDD568A4CCF8F5716BD657E71DE93F1EA35BD
A1E3FC6DA28E571E766B82F66D5980EDD0BC600D5909C46A31E67B97EFC91046
7C6600EB471934504578B83F7FC69AB47AF52CBE91BCB318643A67D8CA8C7F79
CEABDF2BCD5E25136EB7AF8C9AF27E6A46A3300A13467C6DE8E5ADAC82E0E0DE
755EE5CD5D973F62EF8E8F890B7AF413345898186AED0776CA52258BE2C56D69
6065C99BB30610BD078D5760BBC422044B61C63C97A5BD1CA3B8D7F5D35DC45F
07566028424F664748FFC18B90822448C37FBF2C3979E6C0AE8C03C361B15289
830651643A25F21353AA5545D218922A82F2559D03EAEE65BFE453EFCFD0472E
B1E07F1420AA116657F1042D1647D42359C405E34E60AED35B39C0FE9A286DA8
65E368AA3F9CE42E4C77ABFD332D88BF50E499C25482FAB33D5C8DB86F20876E
C6F71972247AD3F49F03DD81FA691F6390EBECC8963D929B2862507DF1429116
332BCA7F38A67D686D3F26D2F796C87A15EB3E08C7496930CE64511B448280ED
ED9AE0D1509AEB32574479C340D25E81F5508A7C9E09B266A50F1603FCA925CE
E22C170728677A1CCA5BA19434D13BC5C64BE340228D522A2CC7526F79D789FF
2CFCAD5925DDDDFA6E4FCDB35C830E9736C098E5362EF8C0BF71BFE1713D4915
5723AC5EEB6298F39E1B59D470938A19EE03DE1E0F053AA3E86BBEB04B6EEA4C
803B4862A0115654AA90137D5C9EB24A8B76DD15F11965FF85F916F675B37883
907DE8B1DB7D7E81F2A2CF4DF5A5E97582A71690E6AB57384C059E665C70A061
2C49C07B417B68151B574DDD636B49B12A656991D7902209068FBA2BC563E871
635D63B3A3E6D5FAE9BB95A89DF6DBE409E1666D0F4CA4D8B35B50438AA9ECEF
7C508800262B7FE55A956B9A5A28DB4DE9F8AD18A9297CB4B59DBDA645684AB5
B6CA740BE300E503F96B96F3B52FE469CF5B2C951BC0FDEC17B53C7E2FE86979
B832244C656A1686D7FDE2F329821CCCDDECDDC90F59A865E60481D8F2557F9F
4C4866A452A8C15F3B18F96F768A3CD7DE623F52A53D468179AC6B2724A8351B
61793CB2E68D651FD5FBA5684EEA1B7A09E2042E248A874E81CBE8BB7C61EFD7
1085D0A04140B18BBBA7D6C45C305D4E5EB2494EED01F80AA53B258E61F11611
402EF5BBDBAC1FC39DB9BAE78383486A34CEE3B0E9313749E436516518542AB9
2BC063CB94BEC44FA9CD62FC8EF32FB37D937B48C2515A46A3FCF8F30B8AAC02
EFBF023FB3ACB3EB8D30CE573EBB16CF0B915E39263AA9F03B21C1F45C87C2CC
B12B537CE6665D8C4432AFFCBF37F6900013D0DD0D4B5C845A44FFB46A93CEE3
E8A0263882542F7F103D13C6926F051D0EE5EDD68840C6134EB89984A6F10862
5F2B6BF181A3C0B28B692C972B0EE1F94296FA4B34547F5200221045E99EEDD8
DB7DCEB5EDAE8C3C80A97AC707DEB286234DC459C43B6B50B517EE397F73253D
6196F4B814FBF17115A8214241B658D4F3537717371ADB8A1C83C850C04BC1F7
ADC458CF49289879A9038BC29CAA2E03A290B31503D2FBE78C1B074C677BDA4D
A192B15000F5F8DE1E934EA871DA279218622524DC53E878D3CEA82E8C45C0B9
9E54FCDC471ED6488AA6856FC2484B956F03733E27764A7C665F258D9BF6D5AE
8B59AB4EA1D766418FF8FAA71FC957DD3AC3600753539797586608FF3A231E59
1F5BA697A7020FB11A338EAE865516BA2F6E20AE61CF9BE481E72FCBE6367C80
2A6B6CEF241B660F77404F79DB472BEA19513C9887AD1245D9F97CC3AA147EEF
DC6E420EDC4B55ECE88F8CBCD7DC30C4583F9A0D90D0AB213A14CF450CF67871
F87558599D2BACB2C7F3AAFF80137CEA7B60FAA052E42F2B477E2A6AE11B253E
C0E88DCBF4CF9E0D5C25DA37B6334A461CEEB20BB1E3D338FC1F36537ED7F3FB
2F63F6FB05DD87905BF9DF7581590CE81B476A554C12105936622C1A3752AB09
6F8DB4D03A4CB527B2735F3A08D23EC1B46AC3BE31AAC6B004388334E5A531FF
4F924F3F5A86152AAFAB13E6457EBB32ADB685C54EEA2CBAAD36D35161B3EB6C
408D4788FF7FBD0753E5AF1577AA2F5D6A3689189D0200C3B95A32A3191C99A8
130E417AA21B43238E675A1FFADD6BC941F7A08968B80412A72941174BF85CC7
DBDF06682D68846EAE0BDE0AD0BF90255DC2B4A9E35B6D1C42FD1C9969888F8F
E296ABBEF465B453970E7F051B88156A3D5EAD07E61926FF76DCA811AAD44492
FE724CAE16C70CDD5119951370B9CE7E88DDDA85C6A478147273B82A17EDE029
B8CBC514BB5689F49D8A4111F65C225C3795D32B44911B845617BF26626D4876
375ECBE49C2DFC0ED670C7525C10B2B3323BDF981451CF8E8A42F9FCEFB44FC5
5A8325BFAF32E7D520DC31A0B63A6ED3FC23CAACA832346AEB55550E60B85B32
218E6B25E840A59400C9C07167EDDFAE37327AFA2F1259FAE2EC385DC9541456
B52DEBFCCBA3338A5FC2AC8D0BDFD7B4F95AC46B6ADE38AB4F29ABF2A3D632FD
1BEFDFEF1EE1B5F521EE120EC3C905FC797E77644D18FD3C72762D854BB8787F
34184700FCDCB461D4CF2D24D34C45E7B9EC87F0F748C0738874C301DAA4329F
E83DF7118A8C47997E97239617171BCBB7D6F6D35ECE4CE462F3E3DB34EA10AB
8B660815EFC3FA18E37561BB793AA4E8DA59307DB759257CF1AE4F1BEBBF23BA
D3941690BA7950E7ED41DC90DA7B2F19EF86C77D96F9A87520E63A45FB2FFF3F
EEF7848AFA1F6E4442B3E2925FD0EA40226FB6E3D72A22E42C558CE4DC482F65
6B48A911514330679D49B3DE7079351EC4EE83144093B939E6C8CA5B2F7148F5
7CF8949814E9E1E689F54BD918932E561E0574A962BC75241A96E958E4073A83
854A08D051DF876E919D8EE6D36463A68F1628501F608F9C9CE882D98B2D24C8
56287B84EC74EECB0794FA38AD685D6B618F374E6C0282F4B39C04173D7060CE
901DC703923BF351BA26D585A021718C7C55F2F2AE34D34D580D8B44A7F13257
B9D577662C2E648089881F8FFA18FB34530B543B385EF4BF7DF79992F80F2101
3EB6ADF1B3171D5186609BDF1D9AE8F89C7D520971D845EAD494D875E548C311
3DFA4FC172BECBEA466C37D9BFECEB602DADA04BDA5CDC916F834C868663AB9C
8604738D813EEAAA99BA797CB946933B4C77B0BFDB30061694635E079930BDA2
39BD770BD671B1FEAFCE9A6B63957BA2FAE441FCFDD660C64E19DD5EE33CC449
95778A2E3A07CD3ABB0B03744315E82B2D4250B31CFCA6332B804BA24CD93DD5
D632A46C08253484EBABE5FB6A4EC75BB8DA7B4D9E7C794161604809472F7B1F
CE762778CB0327DB12FC706D1805B96F16BE71903106CC3C6A26E1C76DDBA6A3
0D301C5B039A354C98BDF71EE58A010216C5D0F7A678239BBC8AEA857364E095
1E92823615112C9CB72BF68886C8C665E442FE7774DDE3910CD10F57EA72EC27
445C008374E753967E68202B991F970441D246241A5DF6D7094A37
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMR8
%!PS-AdobeFont-1.0: CMR8 003.002
%%Title: CMR8
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMR8.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMR8 known{/CMR8 findfont dup/UniqueID known{dup
/UniqueID get 5000791 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMR8 def
/FontBBox {-36 -250 1070 750 }readonly def
/UniqueID 5000791 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR8.) readonly def
/FullName (CMR8) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 67 /C put
dup 68 /D put
dup 69 /E put
dup 87 /W put
dup 98 /b put
dup 101 /e put
dup 103 /g put
dup 105 /i put
dup 108 /l put
dup 110 /n put
dup 111 /o put
dup 112 /p put
dup 114 /r put
dup 116 /t put
dup 118 /v put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2DB9928A7C95D3A6E9B
8E92F84CA0AA44461D2F4FA0F8B81C6F5B7BE98C9712BE166610465CF689DFAF
27C875C029C0116DE61C21DA0092D029E7DBEDFDDEE3D67E6936623AB53FA2AF
18BEDDD7AC19A19CADB6ED6CA7A26E6044BE414FFF59C0B98D5819A6B881F9AB
7AD0D03BDD5CD309C67811D5CF0B93F6FDC9AE64F74ED4E81F2E18D880BD842A
DAFD0BDF06300201C6946087FC0B999447BC370200BFB8CA420B668B32EBC242
6DB1546A7164CF55B332FE9D239B65F532B69EF9F4F93828A44C8F5C526126F8
B7A369114CA68D4F98638121F4E17F351723D9F1A902FCF087F94AFD23876517
2D15B482AF2D68C3F31FFA864E031596E597882578AC7FB0DAE2A713B065B374
3E2E72519ED6D50CBCA40A7275A7109A4F3ED8A4566AD8832890D3D1F4899850
9B757442B7EA355175CD5D6D8B4152ED2D7EEB4CE30F174FF672140354046A45
7098EC45B9DF3DF5CF7B417E201DA88308CEF4CED8E8903AF24FB8DD0187352D
25738519ECBC70304F8F620CC45D2586619205DA3955696FAFFE2082402B3502
CB682F410DE5FFE80A4DA3D3BCF02E35BD577D0DE55E7B8A33B7A2FD5136B5DD
A0BCB61F8E7F4363C21F890CF287304DDB8FCE7FE207C0D160B81E7EA662BED2
DFF8C444E19C91E72254257CD87240A70F1A964FA54ED9ECF27E27A57DACC3DE
EABB92C085030870C6CF5C40B6E47F5C0AEB30E84A73ECDABB2D754EF6EA28BB
16EBD6636BC288E62F4A38BFB55F5F4DD20FDD77D767F6CB52F9513E8EB75413
07F1877B2C01278675177499E4E8EB09F2657821613F5C7643FC064293EC6E9E
B519FFAEEA36B19C9D1302CF91FCBF87FCB57C5F995CB6712BB3D8681EB6F05B
B2A4195A3C73CB4ABCCFB958EAC533BD89560D2790CDE1444C0F2E4EF27A529C
F01052964E56F6D76A190E5FF45934BB711A3406284AF130D4DC0D8112BB3752
762CA0200CA262359D4F54C0CCFA9A50DE18C7DB14419E2990ADDC4A54B94978
D9174CA39434022FA77FB30179EF805E2189C35919F5EBE215EE2A00B4407826
CE56329C5586D8B414770BA5D45513C3AF1931D632FCE69B4CA504944E03362C
74A1177C6398A61A12DAA0F156543E2A8E9969C4308B7ACC21A5ECAC8F172541
1B1316A88C0C163E574FFD3CD22FF08488662FCF2F9344BC25D02146F36CA6F9
E2D0130C654B7485EEA9A110A33AA0C769121F81821E9A2BD062FAC158359D44
3F9D9947200EF1EDDD5860F10438B162A69683957300C75AF7546C70C97AB2EE
37EAAF0089E2623F787F252569B06C665FDB45EC9681C0774ACFBA76B98C4E89
7EB12AA5F8798FFC110B49C25E3A483ABE83B0BCC6DF0578403ADC369E013762
C9D08FC94D949BAE636ACA9F36F4E3F02296775A062077B011A705B6F1784D36
A926622CB3847533D7ACB24A4EBABB14593B5D8E1DAE2BFEF8A51835C8D4E76D
7543C126A4271C59A5881A5AF89331694F84489CA66725995DC3070F306EA447
CF30F63CD476A46D528EC1FFBFB8EACFA2BEEDCF54C92CE2BD26DEA5827186BD
3A4D1709415CEE7D51D671357B4A5D11E835F63521B9824EE5282E58F05A8ACC
FD249461181A38C2F47BAC4E79BE368D64F886AA493C61CBCB2ED401C8AFBA61
59CA6F6216D941A92AC52ACB3D7ECC28D6A58EF4CC70BA6DE23E80937AB38E89
6F05FDD15B954C0826636267EDAF9F2BB466BF79D2E10EED9B04297E6BC93069
79581ADD1A9D9FAE9306F46AC95B98C60A2E53D60CF1AA4069BE301E17E25070
F98DD67BD8642B1D07571A32766072E48BF27E1576FFEED300D7313A358A823B
49C8F135961B7E259095C9BB67F996CE0B90E95344F203922F47E11753F70D38
2ECB615403490310CEE6C03AFA97DA2F47ED47125D110FA69725BA0018F6A40B
29A307FDB3E52322A77A0102E6F57654CF1E96A134D13860D83AFA0A41112D3F
2247A09ACF7D06713BE443FA27C7E7220E875965D53030FE7D2D62EFD2F1DB87
5FB091FEAF599BA8C5167525899E578AB341BFE2BC4E53A047093168AE189237
EA55F055514EFA939DAE9E859CB5FBCF37D99484F44FE5AA5FA386B28BB642F5
5DBAF059A50FE96C7C6D834531D64F1F2E99AB2E96EE74D149178B1C0618495E
293973D9A03E1790654B67C0882376ABEC17D74785B3737D81644F28B3BC6FFF
F92FE29126995A07E0BC5EF3A4B93789A103C428943E045B8D1A5063AE71E806
568D48072E53DEA85253B01DF0BB7367A6BE4DD7BE514AD74E3F77C825ABA405
64DAFA25EAFF8F63344B5F6B523629776CEB090B546469F6A6008DE43072DD3C
DEF51F62731037D1FBD0C038A1E9B669849EB3BEBA281624F13D20B61917A109
A0A7871A73F7BAA18077360B38A4625C5DB9AB9E43BDEEB856FD0E2D3AA2E075
267B978B9EB47F2369302E87DBD5D5B422830BEC32411FE75D584C58650EFB1D
136FEB92B94BF8939FD63AFB7349C7511E5E46AA7324F8B1FFCA9C2A9E9720C0
A720918E8E860F137567D386AC29870FD990BD69465B3A3D2A0ECF2753578AD7
80DC87EBB319EB5AFE0B6F6FF8616EA30C51425FE3ECBC5F8D0B0BEFDEF32FA7
D168B4E85C804B7326A0942CFDE732B1171C643452B7099B31649CA2C38B62FB
46EBDF7180004C549B53F88021D029452C2B37D8C565BCDB0B11541039A13C0A
E45D4B68C7907B8BF08C6F41F564B62BB554235D50330E78DD02795516D969C9
66119D718798120442CB7EB9877FF84EC69DAE25F8559DCE3BD8042959F695F8
2F99845B1B5680DDCF181D806CC4903E077D1FF5E60918EB34C0B1E028422B71
CA63EFBF3F4F3CD813CE831EB54265A555BDD35AD7D723F9CFBDAB29C54F8AFF
2D35C6A3299E0A2DB470C7B141B1E3E10DABB7873AE302926BA8743278FAA8C0
DC6174501D6A289CF980A3F55F2DD5C3A514E7E7F13133C35D2697D64C25130C
DB78FC997968D6B3BC929E8A31B6D212C5128E4412632BC52B3A1049F7F2F61B
C74AE9A6AD19B9E2E240617E2882F7D29ED3A4279439107AF9AEBEE47CE85DE5
CE9595A96A118ACF1EB1F5929930321AF7732E351E18C6AD378508E37B4C327B
0E06AAE21278AFA9255AFE5C022034DA2968D260879B4B38E7EE2E11A593DC3F
CE71ABA050C004473324CAB6F3C50E85DEDA3E9A27388D8FD3A8F6E42A79670E
F7549CFAD4CCB337A6E0BAA4846ABCA059F1E1933CF11DC0FFBFF550CC4A1B47
CF7BCE0875FA747AA854534960F757884505A5AEE0330179A9547A4AE3E68479
7A457DE83326DC30B67F27CFD4AB697601CEE352F72F0966B3CEE3EA24683BEF
6D23AD51B8432C3F0DD0D0F80791E1091F38988B7A54E466A9AC7810DE8B7893
6B0AA6356597891D56190A7660BC7F657BC559E0525D41EC228078F2FBF89C6C
72D666DAD838CBF0861FBF0A1D4ECC069AA49DFBAE5C56B781A1D5D79DAAC256
13E3F9B928A2394FC71691E4355642764459714412D6F8EF803FC5F7353822DE
6CCBB8FBE5AA1F2C7F4D384039D85E7728527DF9FE0239E2CF8BCB7411C000B7
1FE660AE6A2A19229E5E8776CC83EFF3C27403935756463EB4721C51FE0B1197
86C2F17842A0FB639F28083DFD4F1E86D7D3BEFA922514ABF489C5CCE93D6F72
D2EAAE14F6CBA2BE4BBE7D7EA8EA19DB3A87350D4A52064137C3D15A5B05B03B
70B1DA7328D10713B83974C390C3270AF5A9A47C0BFBFABB9F31063B0CCFBB10
0F236C74446688198EFF039110F6FF42FA9F82D463AD3958B5FD205BDF85DE20
FE3F0C7AEEF350AEE6DBC1DE2E2DA4F4599956F59D6F121F7086DC120416E180
52DBBC4E56C09746938698860F30007091E1CC0351B43990E47208ED495310F5
7BA9C6AB3CA10A3F1B318FD47C1CE3B9FF1304321F9623E32D315AA9CE64B35B
F841E6C62B5B2488A311C94937879E5E0E170FA77AF0AC75C5E6E9F3E8F825AA
09C1702682E14FDFA72D27901C5BDE009B1E52E8C4511C6F6336251BD45261F7
401CA3DAE7C4B0CAEB91B9954BF4A97C48ECE7FAD401351D59DDAE9DA94E2335
74A2B880E4749D3D7026CB5299F16C204B6E00A20A6619C34922C7D3FB50F127
3157CFC08DCC5164C8023CD1B6C3556C73CB8E4ADA845339CA9BABA1457ECEE6
ECB9849DF1F0FEBC89E5F97C92978A500196520839CEBA6C0FD2E3D27BB4B4F0
93CB2BB565F4627C6DB62DD0E084E627D69B5DEF42EF094381B62C0D67EFD197
301B132420F51A41561E6106870147E0D597078435BE3819ACF0DE28AD779847
F3D2CF667DA06955D53E0204CEA2935E9E984E76963D3079EC092031E2A10E61
1227E5EE6770DD4D745A52655369EBA06A19BD7D95BBA271E488241199D1008E
36EA99F8DFD2A9F87B06B070158B466AA4C6EA3BA77DB0F853F0BF9A304EA291
34069714368E0B94DFCBA3BE5EDB6C8204DFA7EAF5C3406F60A7056407D1BF6C
CB85C1F432F97D821F5518BBA79AF8453A568FB2C2D025A70CEC75F46C545011
ACE3A99B2582793BA1DC655230AE2EFD24DE20A01D4A441AFFAB7771F223FA6B
9169849E727E494247F67D6E1EA9DCA06A082FE2094BD548AD7F08B565145634
E7ED832FEC1378306DDC796303392ADB0CBA130B63B38ED57B7828B47732853A
893E8836FE19CCF27002AE92C2B2CACFDF8A42F1B8066E033B965D2E9157FDF8
E1264B40813C1A4CE424274AA3528A4F09B3B53DD4D23789A68B3D17BC1398AE
0ADA2C2168427A49846DE0216908C2FFFEF4F13C1ECA12AD341E238EE46E6DC2
B71B54C52659632911F901660261E493AE2483D64E119D9924489779B62BC9FB
A052E822FD8D83178E09ADC825DF0DA07FCE7AD68EEB29FAA275A13691B4A5A5
B0BC0499CD6307610CD6209583C1152C559A2760823F8DC0B9B990BFFE7B7E9F
3969B968AFEAADB9FC0F1410EBBAA0DB979CF153F0B8C978405F8E6F2B6406D7
AAFBF4A655A15DD6D1E9A7EAE10EF89264659B09283F50B734236885FC09FBE5
98D780012FA77FCB19F15BDC522CC7312546C0730EF5225DEA8C22A3BC6554EF
4FE73B9AEB5C2F7DBD474221760E5F539A064AC450591BCF3499E3968F2CBD6B
F15BA2B37080A4129B66D4C2188524F025414F14DB3F96049A8B0E5EB2BBE7A1
AD64A988FE875FE4FE5186BB4F5DDA16983CB052D474B7D72F3E8965663EB50E
015C72407C3437142D3D7DBC055FA627139488DBC5A0F98D805C2143D99F491A
167E07AF60EC9F17C36289368D740B632CB919A0E74C412B76CE7A5906D5200F
9E79CEB9C65ADA3A0F23E8947E834AE7A329A9F0AA7A6BF545B1D7B4666C6522
CFF268634EA06DB3A82D91A4C0A9B227E79961212881A54A6762C335DE7E0831
130C45D94394D21C049B9D189ED955438C2151514F17BFC67E431DD9A8349202
2F616AEC1C7B19F63D5000EB4771370924BD4B9053FE78B5E4A244B9A149D66D
A8BF3B398396D2233E92E4A5FDC70FAADEADAFD255193D688842DBA865CF6154
C9348D590F3FEB135D4B7BD4D76A52CB140888247CAFAB25ED51F4D187041CA0
ABD956F83A5661CEC171B52AF92F9ADE27973B560C802E1E0FF51C4003D1289A
CDD09F8EDA8AFDFF666D35418CEADF3B0BE298F0D1E5C8E024D6A2017A7E71F3
3A9FEC9930F1118101E040339F9D41379170928DDF5B5875212B271DC843F612
E0C21C67263186E3D6929160464D4D5C8928E14D0845762C36FFBDE548188E20
3B6BAFE5EECA0385142F01216FB8A90C43A472C1D4447FE5C7C78CC088FC72E7
3FAFA062C338BDE8A430FDF1951B107D8D73FF9376FACDE5900BA362C66F8C1D
947F9545C5C13A53E4479B1C1A50472C05E8F8C266C6D4F4EB08E97B3B1BA972
26973B844545089C5732322BCC9A5A8FC972FA0D7DB8BD85D2F515ADE65DA479
0224F7EA2276CFED0B75B2C23AE7377F86F1F6F205D6FE19377D87E782143697
984E731F83CA888199CEB425643C259D4FB8B58DD69A96085198306494BB497E
FE7C9954EF35B679BBE3847A9C73507874F71FC97665E2A58BA41407A1745247
44A79B588D969D11CE4B863CDA655DAA53CEA5C3C263B345E782006CE9831D49
603D2D95DE9E370D617F5928BA416C362BB2B4DEF16A5D44BD24B34257765F3B
6223B3F9B54DAED69A90C7050AB97B06693D253C6894CBD7B497DA449F1D9B7C
D91B421891EC0724F59C82B9CB288DC42F2D2D7A7F22EE3D910E15953D7766AE
276DABED3820390BAF2700C4653E1C77FE63DB71A66D93ED293E25B8412A1EFF
809554BF04ED0DE83F7F190883ED793803CAD2C34A66524D3A580ACDF3C13B22
08F18905E7A4A16DA9ED2A112462FB9FFE481EC2069E484E8BBFC19D594153B7
3DED4C11762223B7586483B06BC164D824D1A6FCAE80A35DE0DB8B33396771DF
76DC5C05578EF1BE00A70BAF3D951A01C87328DB2B0DAD6E1B4C21F37D1BC0C5
A929BDE5EADF20DA60C4DE2E3C151005814F24824D33B95F700E09A0207EB602
3EF60DEB1622B91DB99A855A8F1DA96358F05CFCEDBDDDFC8446AE3391BEEC41
966E594E28D052DD5ADA49DFF65E79540EBE5329DFD86C23CC800F95221B9C18
CBBF941D2FA47EF1EF59A89DB5DD188E75EE94AD2A79E2221107E5992C00D531
2E00B544895A9204656867E3DE9D4CDB64B920B5CCA9A73E6514B36CABAE01BF
94C15603B86780190595560F792E5EF01650074EA4A9BBC6ED284B9AC2020641
DCBCEE0ED27FE58171DFE104EEE4202759E594159DF45113C00236127A46FB35
9EC705F21C0E456C1F0F924594C09AC64D4377C5FEEF764BA4A09ABA8D09DEB1
FC13B0CD202B2F04CF5D73DEAB65C36C2FA7C0DC236BEEF6D23BFFC9C493DC8E
1831F19EEF81EEDD976E43BAC6B5CED13F901DE59835FC75490EA528A72CEB77
24C38B258EC38B9E6B97F85CA8C10D8809BBE55A6FAA12456FCAC786942E123C
06D1E55F7ED04400088BEC968BC5081DC7A1B1B65166E7821679F76694F235FC
6854C8776AF855B83445D9FF919B1D80E98DE0741D06D6C5EEDB3E3EA6392530
F1BA817737D8162F7B3A36AC2A03190CDEC654383E31934C3E0A012B639532C6
26FEBE9B412F1C92D1943B7C18CEF510729D501349644C97F087F2F840074AE6
D8CD0FB2E620FFC908BFCD938B675A0A4A687F7FBE8F3DD06A62D7B6DE7DF3E2
49D367D60B10061EA86CD512F5A1BE8950D83C62695E130128E0037B62552D17
064319BBB9B1FAB9D79705E5D68AAE9B36EA14BF1A59A863BDB8DAD9AB5D7B8A
E30E2B499F952D65877C8E38EDD7DB29F9579D09E629AC188DB6A6403AB4BA3A
D358B3770D727A2B77D84B6C9EC17E29D88E3421F9B7D2D822EB78BB8BB50692
8C46DD6F9BBEF2E848A2B5669B200019802AD19661537A84D3514AEC5AA47445
2C791E01DCEDF18D9506367241255FFADEEA6183F51A9F42448A7DE413C08359
52DAD2A60FD606AFE14702BD3B0EC448720FE63438D020DEDFCDE3582FC31DF1
17B25FC152789D2F17FD60B8209D292D2152DCF8D28B5ADC04F6659BBB746CDF
145163361823CA343763AA951C640B5D4A99B7787105A1609EDD6A596EFC3F6F
2FC33D0D499DBE56C6668E137715D435D6B683E0113647B2765AB0F3D98AC717
5B33C3EDDE18506E73B4E392B022F30480BD30F59B2E3A59D93017296C3156B4
B5722E1955777716388AA987B2665669716F866FE6BDAD5E74A523CC03915F26
9B7B231F5D9B1F61DF7CB01ED3F27070E36547B263855DF5B2E3ABD2ACC440B9
0826E1DCCADAC76494D0CB3E615A60F12E2DAE50FA129479B4FB63D6BE6A43BD
54B3D4EFBFC63AB3B33CBA73519D30623FDA383845CBF14A0F012805FAA4132A
EC49A58EA7AE95B494AB3211564C37344B50A95C0397002CB97CD997241DFCA6
42082AE808ECB9299893776303164349AD661DE85FEC5B902FA00FFB78730ED5
4C670F809084C70135813448EE60CBB45752B0EED9392996BF649C4A48650AB2
196695A4150DD53EF23A6806842D0FE56ABD4023D1BD8230DA6F44484F36542B
04A485A82DF75768181D6C9B9732C4AF8647D7A7C5970EBE6DC7471AC22C9F5A
46B6AC851BEE0DAFCA0C2B3F359D32F413408282B657A0A3EA624D8C313373BD
7AE7210000A54A1BE44A2A0515A4BC9901D54C3F46AA048A9303F1D27B272EC1
9F7B4F9751B10B96D9255415CFFF6CF63C58B0505C1AE5DFD29176138A213D21
7B253FC0C235A18CF0B13AD0FAA6C95E71761462FE9F1C98E00E4B3C2A010057
640E1F974DE5FDFE29776EEE367AA7C1188B48EDB688BB291B28F6D664D8F3DB
C5F90AB7235B84F9FA8300C56177A78DAB78491810547304FA712F992BAB29B4
EE141B1ED867201099353992212D20661AC8A767C6FEFA14A0DFF2DCA7618CB8
7B30DC1B53EA8D959DC4260506A2287CE41E62E90CCC51F96FBDCF4D5EDD4A9A
2BC49A12087B74FBC072562A98DC366489AF187CC81BF590D1F07F6BABB39E4E
9914EC6F8EAED8C93C544186766E70397DDB2DF7A060BEFB317C5D2618B506D2
67B00D9C2B2E5EFF929A7E143DF100227158C89966CDEEEE941BE92093AB5ADA
9F945E70F12B939467834D4431CD26C4D60FC9600DF7E19E334DA92A0B42DCCF
4677EAAAC9F8E7EC80BC122D490602BCA555833650CB555F34E5E5FC9E8BE2D5
DB1484CC6BFDAD6C956476832D4BCD8E3D8D62776EC56E83B0735013B40B037A
335BC49158CAE3637CED8E91EF66C74EE2834A441498B6B8C53795197CA0CEDE
45F9FE227032AD32E005F551D759E0CDE9AC3E062E15A6C09AF8F3B3A6026A15
E598874F60E5E40CA9F844F04A6F1DEBC8C6C5CE489EEE32755F501635EDE5CF
378DEDC5919407169AF2905F9540FA6CB88FF1974C728710374BB921CAC1B40E
5277AC8A38712D66ADAA1540330C2B95CA1469A77928EC9DA19A6E51F614F43B
7E5F90FBD533FC7AC20E5528ACADA20D0853242BB716D75184A20E282E99227D
196A254DE3917554226A053572CF68B05405FFE02FE8D131431CE9BBB6A43F2C
0666DDC0C831FB308E8F3B48838E9E00231777BC08FFBDB22D55E720C959E516
86E4271A28EEC5826049D6EBBAEBD238EC5462E53C7D079350C0BAD849FA7F64
2EEF539DE9AAE9325F5003569E108CC0DF8165985DF5A5AE2129E665034EB716
B1B8FA3B294A521EED9CAFD481F8A8691770F6BC96C67C327534094564F23817
023FA72C3C69D59D0C3FC111D1306FF96F0EEAB08CD8FD5B71B06ED628BAE0CB
7C725A7180DC2EED77C33030E05FD864BC918D7B60F9C2C179A03A3D1129C120
4E3723C50D154F0F8AE0279806CB781B46F53B57BB2AD2144D74F31F01B10B66
583FA1C1B405187B913A38E4C19906377A9C2D275E56359390262FCF508CBACF
4271E3120B089B2CCE30B45119332A302B1235B6C954670425FA8FEA3E5653CB
D7B55D78B248FA59D186377829D18958462F066E994C6A01614BD254148FBF4E
496277456BA2FDB26D25B8E223C5E57E5A3DACD66E54D81A74615110F4509C52
F2FBDD15C2FDAAA40C608A996B44B16E3F3C3CC36DD61F20700CD3ABE3F3ED18
52DAAB854A35897583437FCB535A39BFD4A2480D91D5FDA7FB7D46323258C392
1A8D70D42BC47C0CE8BB759BF3CD11013FC7AB9E7E673DBB2C18824B763FDE96
14BDB25398C3669B8FB0B835AE3C18EF4CE08FD74024C9E0AD3D7DA8E097EB20
311DA01B21DFD78037492A29C663D8D91136D5223988B89611858110E7AE6981
0C91DD5C26F1F54F91A00969B168484F0CEA96FA31FBA7DBD4BBC04D127C842B
8ED13F469603228757D2A31F808D16E5DE08977C52E9A60B918B53EE1839DC8D
120AE70504A97859EF5F44F78CFF4C3B409375E7589B2F4F8937303DAF7E28F4
0D1F88EB10B9F9E71F0D66C563AF61B3E7A59FED34A7EE45151B31E66D691259
978444DD2E300FCD5C4EB337D42D29EDD3A9CA9C6209A568339042976CB66867
5A03072DA2207A2E2822932D957EC9987E8704872840F50361F289B380E4A103
9CB793FD21FDB5B0CD25E3CB4C8A75D25A9F61A60ADD96E3218DB041F04DAEB1
23BCC3F235331A070FC23764BC5F2EB272B3FA5E04F81A97D9A7F80BDD1F79AD
42CEA24CCD8B0F9930EB5B43BF127A64EAE68EE2E3DDD9D36A9248F0DFB7EC65
C523CE76A51FC1AC4A3B453C0DC0C7711F684CE56D6257D6CA5D9618AFA2425F
CDE66D8E5445632BB2939A756830286864C8B99FECA7E89AB6133B1DEF5A5373
B812C228E98E675C01FD4C2F84B68BCE9FD36321389353752CA805CBDBA09512
1F0646EABA66F52BFD1154A3156C5557B365F614D58C39FE189003669B89021D
03910AC871D45F3B2275A15AE4FFEBEECD04C604A759846FC53970453D5D82D0
4133F2EF799BD27CF1AB470BBBCC4B56C9A3198ACC99216C1D79EDA92EB1333F
F0851B6835ABD187828E78C310790C231DD179D483BF7CB7E5E20053ADBB99BB
2D25B2A63D719924806BF0729A5A1D1EB41A1E984A56D51A9F548EF8132DD78A
36F4E8E90B1AEA497834104F208547F97666E6286FA4969844EC54AF78495B6F
8BC0582FEA2529EEBF3964B137067959F4F779AD4A88F946D02A5A625924E1F4
6E0423A5A9C6081C3B38036CED994461B973C9320E5B3CF3E24BFAB2A8B890A4
1C66FB96946983D07878717A56AC77EE3CFF73F08CFD183785DC10EDB936BD66
83E7AA7503CAEC5DE549BE06D3E87D0BCCBA3AA9B42E818E52B66505626C3A62
0E1B07C8DB63BA488A3906733A92966C8AA445E9C8F82E297BB6DA3AB901DBD1
2F129D633BB9ACC8A4E68A74A62B08F8912F811E399AE3B89C21FF29846B8AEF
25DFD906EB2175B893408EFCB38D047E87717A439B17886EF9689678C8F4DE84
6F04666672A2AB1724069A57E4E530D1515807E8C213BF006DFB8AAC60EB9626
F470DAF8614684A7A1D4AFC0DF78E4FD060D315EF5CAD5FDFD274EE056F604EC
29112AE578B0078199492AF5DF41A457A13F42EAEB300AA772DF6604496CDEB4
72A062085298CA16119C50D13385963C2BF5CB7D7FEA91BEF2412953D4B4EF5E
BC36C788A38A1B2E252C189937CBC2CB52B5341BB4091A90D166FD76DF54ADB3
3899038C9A4EAF00B6BACC39EADC00F42AADD12032E26E0BEFF67AD622F2C4E8
501C4C347AAC09967AE4B3D4AA44CC347F6803E6524D80C1244FC3BB51EDE743
0C287C69782CB4A6DAA7BC8C6F887CDD75C16EFEE0C1E841C473BCBA7CFCBCC4
C1BF541746CD240CB90AA9A73ED9810761AC89E9782D81F3535731E0A41F8CA6
5EC7C0CE84D98A8CF1DA1A90ABA4AEDF36F262D60C926282EDC4DD0D98C52BB1
96E51C355240B9776ADCF444CD4CE82C8E542C58154E370FE43830FB2BA6EDAD
2A848DD650C3BB5532F868DC7B59BDE4326BD86E733860F3B9C6CC6C9CEAC575
F450B83178AD9543A3A2E87B8B1982267E80AF0CC0B9DAF54C68A279C043D2CB
B34857FB2371D86841E769F4B5BE1285805D7236B1A044B62139CA52E7B2C8D7
AD571DEB2E94
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMBX8
%!PS-AdobeFont-1.0: CMBX8 003.002
%%Title: CMBX8
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMBX8.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMBX8 known{/CMBX8 findfont dup/UniqueID known{dup
/UniqueID get 5000766 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMBX8 def
/FontBBox {-59 -250 1235 750 }readonly def
/UniqueID 5000766 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMBX8.) readonly def
/FullName (CMBX8) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 69 /E put
dup 83 /S put
dup 97 /a put
dup 101 /e put
dup 102 /f put
dup 111 /o put
dup 112 /p put
dup 114 /r put
dup 116 /t put
dup 119 /w put
dup 120 /x put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2D4350D67F24B396427
8808B79FF5CAF896E4A8A31E46499CEE35E6A5AF0CFD175C2DD628620C681947
A02A01D3C2B715AB79D7FDAB638D887B77DFFEC5C3A9484104D84FCECC7296CE
2A3488AE246E233A8D5B40ED5DCC44558B77422BDE47E0435F960EEC3A26DA9C
E137555F0638511AAA14992C8DDA9A4A11B3F90BD4DAAD1883BBEC357DBD8389
16EBE2AA8F93C2AD44F383ABE13B8C95B240563FAB987EA98794D301785E1E9F
03DD545E51A6D58B3618E0750208D3AB913F9CE8C3B865D4CB83B90FB24962D6
142B0204A1E271854F903A2FF600E087EE2FC222326051F155BE709B3E7A808A
487B8AC3CD7D2EAB52C2ED68285F962D06677C2A5015A16B3D12D15D658D89E5
18513C020222D1A995EA14D7D9CCAC4A552172146B53AA4DCF6DD217B61CFE98
1E14709295D97DC8B168AFBBA9990F0BFB9F72A5305570A1848A9E2CCA702C77
DF4F414CDDA4FD7DA25D9B09F05A77F37F1496F2601AA5FBE9B52C1C16FBE860
A3FCA20DCAA3BBADDA16304242A306400D2BEC9BA12788A5AE0E0CABDCF565BF
474A615DB6A14695E6C7288DE0B852EB91153F8A337E66DB5CB43E8234589F00
4868530A5216CFCFA0DCDB92D6BDB092855E9BA80682D5679EF88F3152E8C2B9
E38D0D6F26276BC74B8664E13D4B388124C88D19FFD2448E2743BC02AEB14694
1AC48CB776F8526FA416549A3C35616E8FA5632AA0D557B90C5CF40BE1B62325
97E45F7EC4F04CBC178B72A195912CD18498098C901CD35834FD6EEF765CB292
5A753BAACA557BEA0AF989BDEE0F0C5DF8177084AFC20E7A78BFA536DC28E9DA
FEBFF50E908CA6B5DA15D3CC28A00DBFF8A1D7FF0D82F2A397C0B8B23F959C99
63BFBA5FC83D7F51CD0EA2E2C925F7F4AAEEC8A0483F50E02E4C0373FA4D7891
3EDAB498C44A259B6A2E3E176143C12E25C7B880E2E6B96592BE77AEE1190C74
35F4BA28952C002AB6B3A4B0BD9054855CBDC143CA9D20D20EB111A030D1C979
86BDE77F3BB47918F4A456513EDCB90B7CF72E97296FE07F51D0DF8C9E666024
69C209E6A4A5343F3DEDB6F09B06297505F8F8AC2AA857DC545E030DC9337FBC
E48DC186C5DB047D0FF564B444054F7664AC72B7C39F39959BD574C099562FAF
9832B2260D4F1E9FE64F6BE5243308B57499B6220EB4431A53E8D9A3C6BDF5F3
8D7EA0754D363E897EC68D7E45DB4635D3E7D7176C8C364082D1D6B00D9A7AEE
5E978FC3AC4D9D73E8FAE3086930DA11497F8867E01CAE42CD9D7D1558DA4694
48501C4729614948B9DD2065E5F13275325302C24E28A22AC2F33304EAE0A317
FE51288D91EFB7AF68B8B9C3BE1294CBC390862BC28463FBBD62A32E0AE3344C
5F96E2343E5E1662E5626C6014E1F0E661126A00E1E24A4F7A2546C37B701BA8
F18F93372B48893E3C0449CEA14D228BDB8FD17256DF2FE0767661F6A3972DA9
33C746E2AFF1EFF2B44159CFF6A570C10260751299D8A30A3BC19239C9FE0DC6
BAD2AD2558223FF4CA1B672426EBC422A12514F67D9152099848B13E131C0E90
9037A6DBEC1CB183720F78C37D5EE5BFE81FCB2F615A9595791C6F56210C84FE
62FF6F5F15B866C686D8881212D7B3F4342FD09FC1E4874D35DCDFDB9D506D5A
06E5DB61F496E70C8E8B145B9BB951B2160B6FE86EA7AC1671BC40CDD866A9DB
3103E91EB483E5BE3C037F2D2388A44D8154B216C433FB85231DA4F55D3D4A8E
7FDA4387923679067F13454B02D9F2E2B030FD62C0750576F32F090E9A054DBF
4BBB729B94162C080ECD81F2DB2BD1D65C1D50CE414D0FFB4C7E994B65177F04
E786CACF71A5690F62AE3AE57F43247B8392D2BBD4E61262EA0CAD3868F33296
BC7002271448E865DED4324FCD923313969D1355A579F918E6225955A2BD5B7E
C2A0E02809102F295895722930FCCCE6E8DB301635221B57FA589533C2C3BEC4
9B1958680BE6102180C667E4984C7B9250C5BB231F8E443B98EF07FAE3AC29F0
B4CC4BE8A3DC0058FB2CCEB90262FC959D5ECC3A887E10E1E43FAE7DFBDE4882
BA9035B38BB0F69F8659C0094EA643DEBCACFC8EB5C73AA25A1B83B2DA2D1D47
29A27B554BB9A762D020EC05001DC8559E096F82581B248AF95D6F12FB73E4E9
58BFF246EB803809F561F8E17E6B1B7B1472FC342761EF29FA2C3890FEEB96FF
6B1A173A74A2A61837BE90AD9574EFD8D65602C63C560DEFBE5F0C1F8250E66B
E7A8C1A68E8445CF67F672E2F11583F70E77F479916339FA7E5672DFD1907CAE
45A5DBD35C535D903442EECF453495A6B256DC635941A6781C426A2E12BAF3BB
73C147A74DDE4925D642BB73D9F2608554D967A0944D38CB29F984379073F6B2
77301EA7AD503121EAA1AF349D72677869515D0E537AD762304A6A5CF31E8431
D053D4A1B6C03A4DBE6BDAE2312FBC65F18FC8F4AA546FA69D09DCC722CEE1DA
E02B6F69B69F675AE544ACAEFCDE959350E1EB6C45C162E08E153D1F3151AFF7
B539D0834CA4B87B06732D5EC077B37373348A5CD7B39811286092ADBDD86931
3F6867AC5D53E565234847205FEDC23BC1E1166CA113787DEB72AC251FE7FD1E
250557284E533F3B2DA3BB22AFF13428D2537BBAFB70734A7FDDC68AF58A9D3F
DD456ED2E4A0A89C6E22080101412164A955748ED5E689308C96FA5D23D63513
5B8890A57983C9DAE333B38ADFE356C6CD6BB865C493151B24B9A1FC4D66C491
12E8637906EBCBD60E76227E8847112135CE4FFB00B396FE3DC237292B8D2EA3
03B263C1B6CDA2719C0D99B6CEEE6C86CB397C4D0C058BC2EE9D6298612D01BD
31531819BFC228868453DB8EB836AF2394D45A222A21EBDE795E558E84A277F7
D8591ADCD9E16C34201CB0D0FC1FE62FB107D53DA0D95F61A9A55585A3D106B5
48B258A35D3AF66995A9DEE4312C0DA4C91CD3AA7FFBB7A5278FACBA05E5BBA0
F936BC210EA4E107EB883DEBC83BBA0798B665F2DAF2BCFC00D524930B394187
4712AC73DC2F901BDA21589E9132A50B6F16FE8C6153209BDEEC9025C3C24035
F8623B3CDF420E064D2D3F1BEDA64E39C8482972C96B38BF7D25C1025A9DC57C
40BE36086161C419BE1B0CB4B653DB07FA28934C41AFE90152A14AF2688FB6A0
71AEB8175EEA7775C13F2B7C598C30E91EA8DB07ECDDAD64E40A8C8FAA3ACCAE
ECD1296AB2075DE150F10502847E970256A70B7329834B1D80D40AC5C8DF55DD
E3922D85820114F898F87E644EB8F460BFCFF752B635B6D08F46AEF2123A2E86
913CF1B45DD2D01B8E560EC04230CC8DE7C78EA2970C224B371777430ED41B02
63C87C9B29161341DAC785F547C2E6256370BF3BD8D7AEC72F6F9A4BDDFB6EFD
45AF0A366B9387A4CD9164326B997BCDCFFE0D25D88E22888889D8E47C5709F7
CAD17E0DD435B20E767B31521E9E14ADE57C7C9CDC2FD7D09DAF912F6C5CDC34
6362133B50B8E5954814EFAE6AB8D004AF3CBE097BB0F61FDF1E10170F4EA28D
CD93B802BE124A435403D3BAEBE8C1131718579194420AD650A3986AF9220363
75155975B60093A9A6CD171834B2E39629041BEDA7CFAC7BA6411A206B09DD78
CFF14E36304B7FAC838FEC6E4AC6847C6CEC1559B41D81383017668DD230C98B
C317B08B199C270FEAF50868DFE6AD4243EAEB67590855074A248CEF8F64DB80
D5CCAE6445AE92150058660E861467D0CECF61DCD5D4062CE9DF07CB098B90FB
6CB59553A0956BD6339CAC2FA9C519C46AE9775672DD69D33C0E6D7F626EC2D5
85070A68A450227CD535911F9E0CCD1BA379C750CD10C4190EC8B979C1E4ECBD
DE2836E85616406FC2DFDA7E27A411276AD1B3900453DC3AD85C7A9BE51CCAEE
315E3E5C31F8E6962721DA166B9660C8087C1F1ABD77950E061A2D924FBF4A89
3FF5C570ABAC5EED011D2BF94BC1268EE4F2A2CCBCBA29FBCC4B186A3FCDDDD3
B462305EABECBFD279C9860D5E490EA63D9231638E06EE8D58EE6E926C4A3D3A
C5E957A20F1F99FA05C43BC4D1918DA051656EEF0C498748879BA4258DD73CAB
0F32F20B98014C2B14A77186E43470F0182828955730F440493D34B0877065A7
6E7B704B27F93DAD747DA77109C541A15F08A694A703E6E7C62BD0A86331EE79
6C18A6C38923B88BF83BF212C76BA6EAC620CC859F0365F5511821261CE29DC2
BFEBDE0CD36F0052692C9945077CD606E4841CB991D3C3DE9BE28EC7CBEC2FA6
75984071CFDFA8857CCDF9005AA8FC549EF295DC701260CB4A5CE8FA0F439B22
BC2C19D3C14E7B2B6B41AAA158659C307D9C91C2B12331BE152D3EF8FD324B9F
8C3B74D553AADE2B0E89805F47FA2DF36766B8DF01CC2B6B44344BF4B11C7FD3
186662A11137448ACE7D3F4CA515E0BEC21859D2BB5A25F67C48817404DFA0CA
7B3D11495250150C6A1E32B80334E8F5C52D4769C8BDF3E6E3DA4FF1BC97E009
A1AFD195205FC741837F21CC2942CC8322F3D6AAB6D330E6CE120E1A15E91987
AD98FC12019A945B215BC72768F32A7635AB0F0E6E185AC7099F1A0EAEEC5FA0
341EBECA077B25102310331CA87B74345506156CA5E853728217608416EC8173
2D24CEE766E2B3B0BE183CF2A8B794E0E0E91C11D59B98DF5F4E5EA119F197B5
D8800744F9FD45015FCF5E740105ECE72AB5AB7E1CFEB15807A0D1CDE00A44AD
E94EF57AB546990A691FB2E24CB55477B7FAB6F12A28676DB7ECCC014AC70C80
9199E921F449C232EEB88268A48DD86FCFA2E29FB450FEC618E9E317F4AACC68
C51EBDB1B9E43F7574B40C0EB05E769D30F1C172645006D799E8C3D7C79DACD4
FD269ABF9B24B215B534365D79535AE3578D714606D22AAA5A2039FE7A5DD52E
506D293824BEF78F5E1C7228FF9097FF5AE8CB7B46E69C72FB43EEA7110A9EAA
546E9975C54CFD56022EB1B21E00CEC393DFA488C49C90E73D57CAB0324E36CD
0D2F0F0641DC3785CA9BFD680D609392CC2F852056E90276DA93043B14F30BDB
C32808FCF16CD13E4A13B727BEB4FD42B29D6C215AF4811B965822960F6D7CDE
92BBB8FB84B59075FC14075C30CEFD9D095ADD8043FD12452D3C5E4EFABC9671
6E929D5932C337969F3F5448A2BC8001ACDDA043EE975F35E64D7436FB73B197
697E87860E071F326C7080E9C2930CBA600C6875ECFA85DD4C3741945004B3C3
298F2B741302E0FD39D990F20D68542B2FD0D71F52DE1ADF30FFA332306360C7
C6BE3E6D510A691029D503FBFE96831D332831C69B590025C831281881968B86
42817BFDCE322355F994FA9C8BE68A9222CC09AF9AB2AAE8BCFDEB69B8481CB5
75E66873B08A4E8265F369448F0E3BC0C82D82F65216D0C93DE88322EE7D0FD4
1089A1D6CC3B52F681BAEADB1C82EC3B82949C27C6C340BE7E27020015CF142C
37DC3BA8E4EC2A4FA81E50EE6854C23B3EE301E43D83CF6B82E80ABAA01EC82A
36CFE930297EE3A45783871EC4E77DCCC0923A9FB1654406FC8070BDADBD27D6
0BA8837A459481ECB63F03DC3007700D360643864AFB3728C5573A20870E5D55
4F698DB4B5610C30876DE56786D84C71AA9FDD5198B4F3F8918AF319B7FCD04C
F06C90B2CD0CF2241C2055DB68F1CA5CD57990E68F6F832A5820A481B0823F98
0F4BAE4D7E92F4F2BC118E01ADDB7D527E6BB49E85D37D7E0BE7BEFBD1BF9E1B
9ECE91D28E664284D190010D1578C1F61F02610A9AA6E9527872276E59A25362
68F74B88959CE84F497D8D89735413981FE4EF573E4E0C02D3F0EED5FC100A4A
563949D21A3E29D86A84C9F945602D9EDA860C6C44492EF219DFEBCC016FA7A4
AA12A727D4E218D22805E5EC878AEA7D8B5D79E84E74E78FD9E017FEC4220A7F
9ABCD125BA6E9D378BDC19D0B267A323FDD0831C5E7EB7D4A5CE7047F272D3AD
1E25F7C5327127A058C287FEC98BD81144447D5BF73C56472E552C7B1AAF6705
05286122B612BF5A2AA8C4A6CD64088BAB59B008A43121FBF5692418FFCFAF05
260D6EB20C680BB73F3988C3E4E3CEFC65BA637FDFBA60E6D9D63E6C7FE196F4
412367C1F43343EC6FEE8F97FA0E95BF1BC2C15F14CB6C8E8B28248B5EBB6478
FDDA9D183AFF6A63145824E518377F384740984DC6095FCF3F8B777DD23A221B
AB1ED5EE27C19941184967846B8800E489E1B86F23ABC34237502ABCAF092C77
38A1720A851E8EED24BFEC9AB4C8D4D7FFC3ED0C1CF4FC73B962EB53725DB67D
983A8C2B9E30F4F85AFAA17D86EEFD57CB17BACFB8BB2204E7CDAC446C679226
F21D1A5CF2EA719888BC727725346D58479B69213F9EC3520B9C3A1778061AB0
3B330514114833525D40B3F7F45EE401534732803B807953EE20C9660FB790C2
71513A220EBE1731295B205324F275FE110D60A77CBB43441472193570E67BD0
E97D51AEDD94B4DA0D71DE66E18F22F1E6CCB81D1DAD113125743D82DD4BBC8C
190BF7073078FB1235E8A329EC3C69E3D25B37B1BCBDFA50D0C34BA486AB50CE
0F411AE5DDD05BF3ABA16151A06D566860A08B2C634786C823D615BE622BC8DC
36FADBEE389BA4F7A5A32BBAC6403282F02E92ADF11C14F45B51D579631F067E
09C17ACC247837A8B6F66C66574F91317CC12C73D09A75B80CFD11993FEFCED9
859D36B55033A149ECF0A845F611FAC0A8DEE32B407091C0233808C79857C2C1
540A530EBFAE98C5D51C955D02FE62C8F207C97D614636AF826A7F2247E56B54
3B496509DEDA8A277F0100A94376F5FF85586C6721F65F3F6BCF8B19CAAF8E4A
EB16AC97AB71C32FD3DC9E7F1CF02D29ED516BE9F8F0BA027C68A5467A91338C
CB52C099EC4FB72775138197BFF472B4FB75B84D5D45824A705412F13EC5A2DF
363D37E7ED7DEBD14AB754B8F7C829998351F76E0660BBBFAE6DE96BEA394965
F14D65CD28C593B5056D41FBE0780AE9AFE5F697D3F41FD750D327F5DC23FE02
1DC31AC1DC74721C939D38710BB1BE55E895C2181365CD2BF61E8B59023253B9
7694B2215942A702B855A0102029229F2CFB8EBDED2BA9B723CD915E0CF54FD2
D8B4CA2A0BD43DEB478AC342F292FF590B2FDCFEB7195BA687A7C7D4E17D5E06
EDA0D7F0195D255CEA7288396CB53A961DC4EC29F949EA8AA48DBFD6BD2BC7C5
7019E26D342B8BBD0AD9D48E689550DC1FD581EB0D6E4156D107E116D9326BF7
E29F3479790283C8FA5AD1BF8562D11A26F81783E7B9CB3C74EDB9A2BCEE56F0
0A6FF68026B320FAA86EF294C07F310B832941D400337C0A1C8DD466F2AEA9C9
7284F09CF01CB6D17E333AFEAB84DB7E5451829DEE0B97F8D4037877EB32BE6C
871C9B477865AFA9BECE34891B81B4416BF1C82CEBFBBB6757B7032E04E2ED10
38DC59E06E65379DF10372264804733507A929783916D02CF3158E4AEC0531EB
95502E07ECAAAE6EF0E70EE934263D6C8404739F468228484BC5BF2EDF9BF06C
D5CABBE2E28975711AD2F485846A92D22DB307ED63FDF99120684837B21AE421
751B4681AF90A153AE3B977850AF1B7FADFB4A0D074AEE539DD1B553D99CF869
0D589B7C27086CD89458E78A94E33C2610617A56771E56B146D9143488B01742
017A7EE0444948173C783DB8643039B61CAE1D863047ED474E47A1CB49DC43DA
0099D2BE926D5C8CE61D98B0DF3B532AAB90EE57BC17191EF4119FCDB991ACE4
B124110BEAD7BC80EC8A205638E2727D8464AFE44C65F47D33F454316DD87FAF
A1C93E7C6C1E357F3E111E41706635476A360F789F0153DD8DBBFD19826BDB1C
AD807F7DC8E7FF5C53E5E4DA3BD02F4C22D7F4F0AC70A4EF70BCA3776AEE7F19
B729858F65E937CDE39DB5B0251E88A7F175A32C071E65E7948F77146199CC80
392E35264F5F3E49572665D0C0EF03CDBE9B8278AD83D3EEA6C47D3EB2E9E6CA
9A584BC33306854F50011F25EB87426E63AE8D0539090D1DD81077310D68CED2
91AD97E398E7679446FCDFC9C0C2819A94E3CAFB5DBF7228623271C6F996A636
EBAC372DE1BF36982A05B155C5D5B414F9D1663C95323EA98F5ADA485A644AF0
B256A41F5CFA5659C0ECDFBE060BE1A13056FC6CFBE7FD5EAA415239091848C1
0C48E7FE9B3A1C0F8355EA00F0F28ADD43CAEE4CC8D579FDFB4A20760B411B45
493B04D244792647135766ADA55DC4042748238F6BBEA1E17A4DD4F8FA3E16A0
147EE25255040226A50CC3833C2D3115B47180C4240A31BAF8B202B2C8AD73D3
436E5712854BDAF9A2EAFD383E78A166D880AD473C8C0770D42B5C751B0BB925
15194B5D12FEEFA0D68DD3E0D7FF2C0CE693D6437D90910B86431C23195D02F2
32E95B0E2B69E96553287FAA1AE38EB683F1FE12226D7A76E479F9B84CDA1FCC
3E8D234293F17033925DE8971F5B089413B455B14150ED16480FB7D33E34F25D
724216706EB8BEB5871C896BBB1C8881A564CCA0CF51C7AB047BDC15EE3E8AB4
3F2F8EB4F8E18CCE23D5B030E6D262E87B0ECC9285CE66EDA69D5F914F8E0010
67DEE6D0D500E2A9C71348C4B0B8B9EACEC73BA0A8B05BB57C36E3BE2DF4AF91
6B41EABFC7D04EE555DE2C383BB4B4EFDCCB033365011FDBA6B1196D6A73B411
02788BAF90D73BF0169AF5221AAA861A4E85F2E71D24762EFF679F7E7EF790C8
2435704D68760EB247EA948A2B056F7FECAD79BD1465D2807BEF927F93C13ACD
CA4511A5CA85DF4BBE02F10A6DF41FC65AE5266B842DA242991802B0FFCC1855
FD8C233A57181514ED7588BC1D3507A44CB1CA3148475002412C3B00F85AF948
7D7258CA064C4CCEC5C587D0052154B4E7650FBB9028EB7A0332B2F8CFA94199
D72056F27AB9F4AA2561EEC8AFC1C72F254B9EAF0FFB3C3064A9ECC2F3AA14E9
F11F06D857237650D61EB299571E3F20566D0ADAB39FDC4FB417F873540BD756
0183C54AFE7E9BB0ADA5287676B5A0A734BEBC7245B2466F9E778C7A7CFB0348
79F8A0087EBF2175D14C8B9124B39C684CAF133387EC4AE2CE7E4EF7605B8285
2DF933C2CEDBDDD6FB2B50658BF308974BB66A48BB60F4EBB64BBF31D756317E
59A4A2DF00E0118B6804F6621409C171287D1B2AE67AEB876A3502B8876E8A7C
F64AB12A740B390E8964892B70876BE76CA9B61E4CE995225E331E485BF4990D
780B0EB9DD2FFEF8C6B373F034E4A148AA672FE44D600E566E3AA9581B0B6C6C
5A977855CEC5811F88B0E04F9657816BF19EE4DA34713228AF24838CB8AEE562
9A8664CB4F31496CA4C6DEB5F00ED645A1F0991779D6A37E610448A571C09C37
982A3643D31D219775D7E339F2C6780CBEBB97CAB68B510622F506F15EAA9A72
A18E9AEF22C49ACE3FC9D95B765702AEBC03090CFDED85EEA4D1EBBF951BE8FE
CF7FBC01BE361C98E20ADE1BF00E6D48353095C75B2781181C90D855DC8B7D56
04DED821AE4C212EB9467A475109C8968DD3B5FB454C5BB919143557D0E9AE1C
A2A4D01EB1A1D00891DB791DC5A3C2F6D1D8D6A861CA06276D40C95606548636
56276F5F0E3CEBB8DC834DA1DC74464C2FA325BA781290536FAB30BFE75C6DF2
8CBB83A9848E6608870582E08E920F371630C90C1543A391F5F920B9D31F6F85
C03D472447F46540A9E6C3B6A38A3790F941D18C014AB9452DF2ECC9744C9CF9
B25612DFF0730BD98030386F9D07342FDBACF0A51A75084BD448764E90965CCD
DD2C0698ABFAFE2685D086C04FF9F7A80AFBCD754942B76082818E5335B2D59C
5D8DC8880919E929BB25AA256820BC36FFC2E88FB974A49C998F5AB68BD06CD6
58AB4AF2D7B9BD0BA7D24901BEE334D78FD1AE57B26BD22775E68A8894974D88
58DE1989338196EF0EE54F626EEB40ACABD301A7543DF9F34829DF594F6ED5D2
8574BFE3E385B0F62B3FF0A5719CAACB1D52BA38F2FBD30B46937D96FE798D4B
0732F8031CDC28547E39C60E8772F9AE3B902CEC6E7DF9AEAB55F638573DEA8B
37AF92155E93040292733FEB590146A7234047F1E09C0D7A00D207ADC2EF0FAC
BA5E4B840365B949E5B76E8DA745F248EDB3A0625C1F5FFEAC65621E6A7DFF2F
2B8A4BA13A56005988B0CF008D8EAB3170A8D3ACDEB4F6ADD9CB39F0DCF7608C
5951FB59472B513DD21C1208F46AC8B65D97CF2A33C46AD3D6496BC5BF06A96F
C2CD376D01196BC6A9E8EAA6D93D61A124B4E84DE0ED5B6E09393B77C555D4AF
6D371F1D11EFB416C9D282D87DB8D6925592A8C156F5245C30E7A4B5CB1D1F87
3FF5D5B1889034EB67A07BC07076A3A1DF22FAE5AFE809D217AA81E54D6CB5B4
B161E5F5A094C6CC9D874B03B6D641A8B3A7F3B6E9856C1357C90A9020D0B848
58614E27B69507CC56DB6D3A2549291D190F2B0F960313660FFA1EAB058E6C9C
B649D5B9272AAD6173030218404935A170A91485DA0A732B79C74591205D4CFC
7FB884405C1EB063A0F87BD3CF8733377CC50DF7AA4DEEE2F76EA27DD2958FCB
165AC07D468E385FBBDA9ACB0FDA2E0A9FE2E4B1B270CF2E34E9517172B19911
52B84284FD1E5B1C4148E8D3F20149495792CB1E5B6636DBF8E0A6659470AB86
3AF3D9934184B97CD4C112FF42DB305DB977B2CB05D03BB122270053E1B222BF
FCEE7E7EAF49F204A9891D9AAFA9AF754E43F56C4D2576E30C7EBE0D2FB3E492
3A6302929FC96DDEB5744B582EDC9558EAF355C76A4DA9EA6679262FBDEBA6F3
8E8E8EA27FB723E87EC1065A3D52A6CB3DAB43F7CC654AF9C4ED
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMBX10
%!PS-AdobeFont-1.0: CMBX10 003.002
%%Title: CMBX10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMBX10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMBX10 known{/CMBX10 findfont dup/UniqueID known{dup
/UniqueID get 5000768 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMBX10 def
/FontBBox {-56 -250 1164 750 }readonly def
/UniqueID 5000768 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMBX10.) readonly def
/FullName (CMBX10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 67 /C put
dup 70 /F put
dup 97 /a put
dup 98 /b put
dup 101 /e put
dup 104 /h put
dup 105 /i put
dup 114 /r put
dup 115 /s put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2D43B233BABF23DF8DB
B6C2BD2F04672F9A3B7FE430263E962F16A948319C51B8ADE6E8A80D3D88023A
6DEA4D271676C2C8615C4A0EA7DC8F6601610F398673A4D4B905F49EA868FEF6
39BE073001A36DEA6C08ED51452F062B971740019692E221F4455EDE46AF24B8
407A98B791F6AD525C72C09776247E194043281D04FE1CD1D8AD8DCEEC3045B4
F95B3B41CD3300768D8A049815348BD7AC1004F5500817E3A267D694AE108BAF
285B288FC5F28A03E9D34FE5D9B2F9A9BB26ADE66B1CF8EB5BE606E83D213C33
DE083C20D636EF780E761944FCE3B8A950B1E6E7568F33B557C6D59E0CEAF185
53E609A4F58AC4D5269116F958C4D115C44B5A6DABAB79D3BB6E60BDFCECE108
74CFBE258779F32C80CD7D9A7CEBA50A0966BD9961F71560119668C4A0C30A5D
ED91ACB30940502B24F33906D6E0F16F81DA87EB6D7FC8B7853BE388C40D75C2
2CA8F94713AAA1561F5321CE97997CB4AF0E37F44E25B0F73CF4986422B1CD89
8F861CA623004ADB1C28268D7F8C484AA10C9519B6AEADC95AFAA3304D60E85D
718B2F67D2B734095E5A92C90785252C98067DC05137BE735220BBCB7C341D61
C4B98BFB1EAF883D38D7A93195A059EF82B42027F23B6CD633231D704B891A9B
03D11A646F13898F20321D7BC150C63FD6DC6BF9CAFD8DA759E95384B729A0B2
767B9F3E55C682F7A248BC1184F7D294CFFAE0B246DFCC8F215625DDD4F49F09
FA8D41CBF4A06152FEB152C61539ADF7E70A4D23AF8267D25CE3B12D39D62377
547E2528D18DC4134FA3BE0437EE0B3509223D71F06D44C6227D62BD01AC0A2A
3EDA975E894371C07CA1027B102549A7D552FFD25ED2DCC68E29E71BBAB43C62
57B0BFC6A953ABC2EF703F35D112F6B5460018CDCEAD17F149DBE5B52C2B9E10
9818EA6D97C8AC884F6841C9B600A7D868F59C1D80E98DE0741D06D69858EC84
1B33C6C9938B7E8A6FF6C12AD456EECBD3EBAF0D7331536B9F6422019FAFFFA4
822E79D6D89D6366DA636CB708894FEF904F366E295F1CB808E78E883913C4FB
1631248ED6A7CF1095C0C61C4F05E4B9DFC47533A5FD24540AD71A0E2907B98B
28085EB88ABFC3478C9644594C7DC4244ED5A7C1CA8D960B65497D56D174645A
B88F12C2CF0A807DA314017984CF3C4FB7F47392A651EB9CFA961B28E2989893
9FC4D97171BD5338673F5D1CE2C3C08D48A1B77769F01D5058236C655FFD864B
80E28F900191D4EB349AA5E400A7B0A0FCA0F3E79D7A7C69775BF754329397B7
D18B20B2683CBC4A19729BA878B3C17EBA0A7E9EE297A5B67E915CAD92C8F356
582B8299DE6A58E73408F525F7EA895C48A8F0D626A06A96A50348DFBE479D89
4272576FBB0CD332193D28A8F11503BAE98F8E1D73CF5BCADF23DCD4E6586ABB
323568F5A34E359661074D50CD8D9DF27191FCE24F10225A5D721EFDE2547E1D
CA998077D2340B1A4ADFFF570AA677CDF3305D5E3A394BB1626EB35074D4EEAC
2F037CA2EA389F7683FD17A8E07C12B4CB3BA8C249C9B12D297C618009F76717
0EBF5F2DD39A6BDA10A2E5A811D4E190660F5FDDBA29201B6F8042620397AB2C
E59267A7247B0463891831A6F40582BC3F614E5167B646A8F53D8A31717DD9A1
9034034E705BA7884F0E0738307AF69D3517147C282747F2788462FDC4336A4F
9CD222908401A25F0A1F7B13B8DAE622DC965AD0BE62497420B70C04AF432237
E0FDD043456187658ED93B0F9822A3998511DF05E59CC85B7B9992CA0CE3B814
9723BAE70D2631F32B4BF93511F67179FFAD2075E1591CA5907A4C67701B56CF
A5E5B02EB4A842BA1F18D6864E5677359C2FB4AF5BCBABAFB053F230CC129B45
8D15413F736EB07C571521C7DE2A13F2AC1C133D491B0A607197BE9AA1231D96
BED7968788246B2E4D2BD330F802810F5BDA3760FEA5210CFC6F54748FB1D921
5CC3624BBA5B8962AA7D94159651589540B17CF7A785F297264F9C1006D36928
6E2756D3B623A6087E4B106FBA76255903C624C07E18A1AF4E185A533C640711
86BB477A906ADD36EB6C8F4A12BC2F01B2B98412E4E105977640930CD998D990
0254A1E5E9843B7A8ADE0AF6D5871E6D3D666465AE69813A2E26333213FF6713
6F08D55A90C079A56E1B9AC655F720FC22B5AD8550FFF26DA7B0C5A0B60DDB05
64E8FAF684F3A455BA9BC9278043D79537D201D520E38750335A4C8FEA887377
879331B68DAD6B253F4FF9981D0F9B9550ED5179B15EEEB00E560A3DB6E5973B
63403E4E2F40A3D0B937246E9652000B917B1369741E0F913C14C2D2D6D1FCBE
2CEC4422177C58523715BD070002EC2E13D383A1DC8C84228862B6C5D3B65667
9FA97E175239BB7FE7E37E14B96DD7960A8AD49DF428CFC13B5D3CC22E245317
47B5244DA97F1DF954CED2D552477237CB23D037C0DE728E26C82738954EEA1F
F34FE497DA005AF03746DD2ACF77F6E6F2C224862A1D18AF6F7A5DAF34564387
9E01DBFF49F8621C058C04C2B3F4F3033FF3E8A977B2CD6B2A3CA4A6C569B19F
C5AC457AE9AF334DA66A730960C7565E93A2D373C0E3DE14646FFDA05DF4C6EB
6D4CA8ACCA3C3115764F77B842581760BFB9E5C0EBE55308B0577A8F4D968CE2
BA3361D79378D451DD150C34D7E901397AC63B33BD7DB13C50D678F5DE999238
4B4EA15BD449C46F262D931478F5685CDEEC4C4201FC3EFA607AFB8F27AF6751
125DE42D2FE2D31DE769B7E7FD8CC8C5D91343B537139A822A5BC4160BB5314E
37501F65B4FC35475FE9E03E34CBF6795AE86CE409500BD0799DE39FA69978B6
EC74D2197C03632D3F59B85F404DB31240968FA75059B2581B101E028CDECC2E
7E5E25DFA106E9B8ADB81E82BE9ED3BAA9D03EEB22B7B67AB1262DF6AF5F5EFD
A5627EFEB84F3A5F92EF2557EDA2843D7D18C592635623CEAB14CC3620F33986
410D6DBAEF9F86E4E6682054540E2B01D8FF2161F10E66851A188BC15BD6666E
8D3F21709F196A31EE676D28A2D12639CC2E7020A52910F052E61A0710DF09B0
064171D05611451BD24FAD64716F141E1C41D3218A8115A3D73CA041D02B46D9
28C3D07DF0FB668E8E91409C8D0A26A65CD737C075E026AC0A974C9BE658199B
3B9D82ED95E4646977D8F60717DA4C68767DBD7E8320D5AA1D5DEB2E6B009759
8282F27D64F1F904830AAB501CDA4D9233FC2F12F77F0FBCC46E6B729C71F6D5
E6F3EA02EC35D1048394F4EF2177FC5EB726DE5EF2DE7997166B8BE5B5105D08
EAAC3481FC612665CA112D3F889A0E5B7843EFFCEFACA24A01B6AC2B7DDE02F4
A9295AA2409A3756BAAB44608DACBB56840060037869455BEBA46F10AFC68DD0
0563843DF111C6D34911CF13AA6023E5E899060B5EC60D0F78FDEF3E981151A9
24903EB13ED1A67EA1977449716D1A5A7EDE1A2E9465C9C2B20A58AF02D9F373
73E627CBF296B3A6A4670C39F3B5EA30D76F0362C81020A1777F0ADDBC6B52F7
213FEE1718214087837049CF2AF00407639657428B9E8B532F68B631611A3501
3D9DCA38090E227BD0D6D0FB4130EE866DB6B195C873AFD18DDB3B1E40F740C6
B3B375ADCBBF628A07A5FACED539FEDA3379D3B60216C2EA6629BE2F65199D82
FE3AE627D7C67270F3497AE75F7A9514968B5950E2D63C38DA240AF4E6CAE88E
E25167D179108679876E7C80C85FE1D2BCC2EC9B88BE76A8F5736E8E6B3A9CF9
42E58A4ECB7914865E67C1468CF66D658206830B9380FE346DC2DC4BB56A92CE
4B5E4EA9036C177869315A2D9E6CFE97E3BFD7CBE0747D40CE5E8A3A0988576B
8AD2B1E4314C0D8A0CBCA08844A49F7E054D31BA7543730C0A7390BC4A288D10
CE29E389A4791305D3AC1BB6F77C805F1032787306F78FF76A20A9E629899F6D
13356768D33D7B9E294E8CD50CBFB9CA02A193922BD9B4372C912D1689B6644D
52CAA30F7421E8114D077288119AD9514EF21E5B9989CCE2ABA0C12549FDF493
FFB39736AC9EB72DAF45E4EA6057527FA9F5AA0A1A3F03C12F7482E465C766D3
760DA7714D56C91BDAED507A5572BEB51A895F8DD3BD5AAB042650154FC7E4E5
5EEA6194DF73AC5EE2CBD4EE26E29B1D2D0C458B4850BFE842DDF2EBB4E2A25D
C6A11CA2D8F346E2B736DF88A3D57BC0380B52396A6C039212699F5D3342EB58
0C3DD5D01D5078479BD9FD10C07925556C0AB0F03606F33796BA72074549EDA6
E33644F62CA35207D7421D2727AD8419AD1772789D33405FCDDC9286BC34C974
A52297F5BBD2E541E8BB473F733AE5097BBC9D5FACF18DE4173B4711E28B23ED
16E0A6746A60F6FF903026A3900169EDA87D98396E762C2EC963D89197B8CD0C
25244806BE7CBF46BE60A8F9171731EADFC969C28679B025371E5572E52A0EF8
B3FD9B4638D03E20BFDEC9345E70B8166D38846DCA68E0D0B4B53629C7E7620B
45E0A610BCD07FEF8814CF915CFB11119F42407D1C6DC1E6353451D40A382C2E
C74DF2A4889ED5A3495C3E973565F7178CA190D22C9693C10EB12C1E7A8679CE
4AFECFC964CC98111BA4ED2BA9B10292A71D5B11870EB08EB483922CE8628A06
05E7CF6DF93E112B60EF888AA8DB52994EC33DC7277D7B7A4F913AD30257261A
D6EE80476A9A8D316D190BE6CE0046CBBCED365AB305495284FA921BE0638E00
63DB2AA4C5F163340BCCD1061B469504DEE350B82FBE1689C1B65D095405614B
35997D6F0DACA7190D64ABA351705B17B23FE2EE5996FCD607F49F54392463EC
DD5B944A4B82FA2BE3E75E2946D483060DF99277340B0AB65A2042AD088E2B75
BBDAB869D1940F64B50D25078519D18748AD64AC5615EFAAF4F3105B0111AD40
70EE173ABE6A4ACE486B4E5999158A4377FDA6922FAA6E9305F48570D14BC81F
BFF4C663E1EA9D1E050534F9315A663C4C5DA52CB02EA6408AA473C32CB0CD71
169BB43C0508A842F400240F0063243B4C459A1FCB3312C41C32ED0EE87F591A
BCB6D5D3830AE4645CB4D40336DB4AB6540B52E70E1EA415CC6D886827EBC5B3
EC35CC5C136243B0C20B3C603B648B132B99D05F9B48263ACFA59A856BE74441
FECF5C6D1FE9D1F4F9942F460961901E16017144C37E83C6822177B2A6C47ECC
6C47A1104460665E5BCFCF08874008302750EB991CD98D0D8D22B921F90B99B9
05EE7C39F2BC2A7798157503743C9F2F267BDBE2E8A4CDA7317F81DBF8962E1C
EC02822CC7F770FD4D08D335904375BF0C6DAA0510771627ECB9EE69C0F47D30
69A87052989DF80D9F4F19F75B070C3689AB3BE0966453F9D56CED6C1745B50D
813AE6D7E44B73423AB3778ABE4CD2C4DF40E14C5A426043F7057E2DFA2DAA70
EA6723F1C7967FECB1E7C1C0CA283334163FBE31C32254490170C3513580A552
19A5DD75E6C4ADCB12D33517A03318A6BBC7E4214266E125140D8C40F78A0340
1F95D9FBEC4DCC55B71E89375AA94B0D55646F6C069561480407D0A3AC127024
D7D1E9ED6B599A2A8766B8792F46D35508B66F302D289405B101A3C6BADA680D
8C56E2A00B766A4CB155446F862FCF17537A2BE85418E20CD77C4F1F69F70BC6
17BB5DA8FAA876D0E8BABE273A19C04A8697B3E3CF4725E2C77C8761A9243F24
96F8AE96399996001A57FD75106745AB4646FB9C6421F1D4EBF3BE533BD11AE8
14BFBD6D308376B26E08E4ADA490DDCCA94BE8240403D5EB0FE3549061DFB668
4105B4FE77189546619B6BCF3F9723E278E98D50A17DB8A4C46744FA21760635
5B332689316BD17C966D466AE737FE3ED7ABC443ADD88D4823A10BC9747ABDEE
027515AC353A420523F85298029475D8BFD83A2CD00C02CA07974BAA581D2215
A850E6E4C0A5E17E0EDF91C63FAC18C70093F40FEEAF0350B403E2806F4EAE96
BF616A805616EE55C4657418C26CAF54187A6684821B86A76F15088AC4D5B551
66C3CA8DC61E9810858D1204F899C7E3A1754F483134609F6EEE6364B1CC04FD
92C86EF194FA3249601AD722D75D1D395CD15A93C768EC60A486AE885683364F
93DA00A865C1035F913FDA69E7D9A0422880FB81EC23C00427F07A5EA3CCB613
83C859958AC53FAEA26A6BB39ABA068863CCE3D447720BC31A5136E08EE58963
093AF587A72112D55853A1048A2B1695DB2D7F13CC924F2F0902071260C33ED6
30893A04577C0ACF0681C0FEC23E5404F844A83BB5A2F8DE1F0792196139993C
1152094BC36A6AE5BAB4B8281E506F485F0BAEEBBE71E174B7CED1E52A8242F9
DBDF3E0FBA296538D964EB5B7A4E23B1BB0F59872C9D4FE8498203E3AC08B71E
D2B965AA6CD5D20DA6C83FDC86F4A5D68A58A72C5BB9BFE9BC755C56B24025CE
6F24443D3CF32CD711D3D94C7C1DC275DDAE3341D840090F97CB6CAEF274C94F
9F3BD3AAB3F98BA8A7B5CE5E48D1462DAAB37BEB1C10B410E8D33FA42D898183
BD4F807112D78AA94509E33C179BF7C9E82E55AA7D09E128A0DA06A330CF4AF8
5DC861498CE029CE8C1BD15C923A708F2E7AF98E4F7B34212A0CB417553C86EB
6DD46B0466F1A21D29FC5111226794ECFCA5DD4240C0B8D106CCD7EA6F03E133
BB7733F055D6FFA04EF5C6F872B4FDA3E42F0F036C4825543D75682ACF71B548
DED160ACD05625274799D0AE201305DA526E01A3D2A719B1B15C05CC09467F3A
5627860C0F36C503EE392E1786620F3F2287AFE56634E03566B9B1F537FD92A2
913166228791871A8F8CBA1A1DA634E8224058052A10FE1E67CBD3FD21A6C07E
243CBF58BDC78577847664EEA5225EB8D6679AB17C563848A9D4D58995EA3609
51C1443B752A070D9872FE1643F0677019235AC25DC2B29169D38308F2170A1A
A0FDCC59E6602197D2815B914041FFC7106DAAAF30CD97400C6D0826A40385A4
C8520119A065CF32CF2FC5FBD8DFD29222528A7F96FDA533145846B3428F8239
E50277C366418D713F84B12A5FD4F904DC13DB1844A391FDAEB97643A6FD2945
942FD4FC5A4A35E184F23304B8B4D93D0C37EFCC4E106D4FCD0DA3E5D2117589
3FFC2BD1D121026562C55C455C3585050B9460891B006F62D9D9B66695C3D348
A467C14C0256FA9621CB056E7CD389505194FF463BCC4010897F9A690EA87D9D
BB3ED4C174FBADB8A4744C6E4A44D773967FD703EC37672F9993DC48BCC8A060
6CEFE8E6B8F10886E15BA0466AF410B90DF0020FAB88BE493606B6A734EA85BB
926950EB10D2F2CFDBD182B0F133809612CCF6ACCAD049C8005A42FAF78368B9
E7684F98DE421BE0A3BC0FAEE024A7BE67E15C8394F17FE84DFD8156C2A3E94D
08259E15CC657E8CE3088395BF6B5F825764E141AE15EBD186DC049261623D26
8636705E06C6E4A1F8ACAEA59F91B042DF5DB9C2AB986A784384706A43E5F18E
42C29CC1CA86D4F247B3BBBC89F3633EE074DCA4AC15B1E33EE4822812A62E88
C32B0AA57249980EE17AFC1346074800FA529445D18649A0475246A25CF325A0
BDA06AAF392FD455218B13D9ED577D51A9500B9FB7860716A8E2FB3A8C4BE3B3
6656C6A5653AEF00184020ACA0BCCBF48BE3BF91E11C8658686C89848E714E6D
DC158DC5E995A1F755D8EFF023267461393B4E2FED0E63F90B8DF6D5549A4219
5899FD38FAE55FCE8DDE9CD3808E92A626C3089F2C51AFB51A3A2CCD2FAE030D
8E884D315F56540ABDC69E42A69D64B62F8E29FD0FAFFAA3903870ABF407DA8F
6897511B2022AE9612796DEB9138059A4C12D3EE5E32319E2C674C07B0C8F907
072F883223DBBA85281C413245BAC81219563BADF2CCA50EBB691FE3A66334F8
5FAFB2F92DC495B23EAB87B339CD87B09F18BB72913814426B798433263E6D36
537E726577CE1483052A004F8DBA708AAA2C2D73ED562231D19C05287689EFA7
7F8263FF6E201C09E3AD2368AB66C4424D96007007F900A608358F08112221AF
8F6F4A4954501CBECB9DE05A3217938C17FCC2A7EF4A404D94DFCE0A768B1473
8D19260E8053E9729ACBA338A3580225CE00CC16D35E96FA40AA847DA5E22F00
136F21273615D78D4113B5988AE71B8CB269364E8216D5A4DD597644CF1C1C86
B8FD8EF3FC186A8EA4C9BE51D592FCDED18E131E105AD89529EBBCBA731385F8
462D0CDA1D4C5D6E8298B2DAA8B794E35F00BC8B61D90C52DA56A19A874B9887
FD76E6303E404F673D424112ED9EC7351385FB5F85BC040258DB2E044A6DBC09
75EA6AD0CBA134AA5D1237AD7982B3366A4CC57E49880BF61BA0CF5660A12C17
4AF75DF1CDE0A18C94817F54639AB8490D4976695D2851ADFE75F0E8AAEAF174
FD8B2D5260B03391C9CFBD716B2401FF59ED886E3FDD7941DCEDA856CB690E4D
9D6B4452C138A84B53712BD7B6396682A49CB88706982B6687B8E51E12F0AD37
8B8589956E1D14974A6F4FB99C874E748FD10B214773D46C6DE4DAD8923EE27F
4E0680D685845826BFB35CDB2F80797FB00B7026D3CAE5BCD397BA1FDCA43DFE
85DC7A21A0080D2E917EC3E48A45B3380636F06F3DF2CEF7714E57C8F6AA9362
E8A8C69E14731135956DDDCBDED3DCAA1172A04E445A281AF2607DBFFDFABDFC
E1F8859F2B46DF97AE05915E791F1CE849154C53C441EE42C0DB0FF95359E700
BE2DC30F248D1BEFA38DFC7C96E8D5460074555ACA3D34D93B16163FFBE3370D
84FE65AA30EF505F246F21D3AD1E663AF5FA6F4C6F922CB497E519444446F0E2
F2A2CFF9963C615AAD63EE5813CB2D7A47FFE389777C340C370CB8C93B08A7DC
6A10F3E75C36E9CAA4AD5418193E66786659050CB42070C60DF4B6A87B879E66
D5E87D245B9BCB889646DC642E12E3AC1F8D85467B5146B72FD47EC0C3B9A4C6
12CA44A7392D8E791DDE1DE818BBF26CE3BCC744064447AC6D1A15CF1D1A3797
CFE85FB55B56AC03569F1C105B41F92F125E3BEB0D110399CB8EADEC0A1AA9A7
4CDEE023FEA051AEFEE5DCB52CF065EE27CF88C6BE93FAA4D990B61CBA9199A8
FA809CF94AFA2F5E416AF8C5C5D1F58D60E519AAD9DC63574D9980BE7D234FC2
E34143D2C1D5EBFC031D9DAA06ADBE7FA0742865CE66370F16927135F55194B9
F6A1679797BD0144D87097839CBA65F0FEE40BC80E05BFB45CDE88D33E577013
6A2AC0183E49B0E2104BD93B1A101D50A62732C636173D5D9EF4C45B881BF169
61348335EB7EB3B4755170BD34A1BB68418C1C686CAD65DDE0CCAE5ADD7F52E0
58415778334CFBC80ACD6EB2450AB54D4D2EDB6AF43DAB2E11C720D24E2C9976
490B46BA11F66572C16BE5309CF91E7B14B9316740D50E95B23EC680E3980E1D
835B111F8686705851DD2BF0B2A814232ABA2C25389A4A428994D5C331158785
4120D8690A406A42F1E04082032A219CDE6B7972F4C158F799A7DDD0BA909EC9
9E655A0385F2CBDEE99868A3CFAF347896DE4EDB781EC82EA0697653DFA39190
67E0C8A907F17A4C84ED0BF61A99266AFE0BC2925DEC660C9435C6A7ED4B69E2
3BE70408309B77FDA513DFAD1F6E7FFA275C7B24275AAE27F062688ED2A266AB
BF305D5529F99140052260DC93D7AC1107B43BB77A3CB0B8EB1F74EF96BF13E3
AB14C766100C302E922A6406CECB13FB217E372888F11E00A75602ADFF175C1E
D1EAADEC439EE105C467F05ADF4F2F881EA0D64F3BF02C625B92D884416C53CB
94E3D995373CB0F8C088F35F2CB696C51679100212026BAB45EFBF339018ABFE
4B14AE88CF0CD0246E250D2E1E09CC4CF8879A65088C7381B9029B67CE902909
3A94DA1B1B82FD8797EEEB29846B6DB84DEFD0C7F2FA1DD51EE1D8B35EC2E6B2
BB0314FD0E2835FB97FF4CFBC52BE2AE157BA062086CAF2EA14B0C75E8E5D87A
C6465393A7DEB7DA08B3012A99FB2FC7F6FF7AE574F8A863B3F62A4266E23A13
459056C077EAE6F2F7D5190BB20606E56D3FF6111A50915C1022A1148AB823B2
2C0423FFFDB4D4C67ECEFA041D118A85F5BC86E628761D164A984395DB5FC5E2
B14AE55DFC5B666547926B633FC827DF3F4F721BB714954A4A7DD1A6DA78FB92
37FE0F23584996CE8F503E36D79F07CB7F8DA6F6CB294CC29F9AE0223FBF4C0D
D215C4961B4BF555C2F31B9752E9C1E53A75C9A7BAFDDA2EA2EE5BA19AC9092D
97DD21734FB6CF0E76FE0A93377678C61F7393E3A8F91561508D4F286F58CF22
32CC5DE35248DE1C251F41C74CAECABF8616AD95FD9ED3B11C918BB38D10B60E
C484A1892E79A94AF0B3C21C166DEAFC24FFCD56814B13ED96902B67BCDC6A0E
5E1AB32EAEF3E40008AB12E29187FA0C50423181BE5AF85A60F467659ADAA9A6
50B440F1D351D6D1C4FBAA794AD2B99B73E3A29D9453D507887AAAA02EBA69A6
FF275F5E7DB7333BF7F92C19543751C53D837F867A58129F39F3991E007F205D
3EC11FAFB24BC1BC7856F6361C5B77A362ABFEA1F3CF0CB4DF082A5392E03264
AE22D89E448F37C20E97D8A8B3FC13E8A98C8EB349CDBE1919CCF723519660C2
D9DB4EB31A932587A1159F9DE4A70B4A574B381F6D5B1033C17F75B1EE6832BA
1B15318450CAD7D3E0BB3A595BE477526C1131AA10F343D8A5B82E1ED4CBE30B
4A17EE51BC58D2F0732A2438C49D3E36FFC93E64FD2C962B4837762BC6375084
C704A2CC9E50638357A0D5B21E2FDFB32623CE4BD6A17EFFD3D67901F0A318D9
98C7D41828DB825610BF6E83C037C2948DCE684AA43D632EDE4C96C7D317549B
8347E8005F023EF050531689E2A493E8CCEEDA7B2DE2D218D957F37AEFD6DEFD
F3F91CED403281C251092995DDDD245BC8BEB97AF01F6CEA5AD548C28F7A07A8
EA48BD8E899EDDC35D38A9EB5F67823E7556108A635FEBB1E1503F9627F16887
CD6FF2ECA00B7AA3641CD1366EF0FED88DDF914A3E16DD377C89087ADB06C299
91661D1F99DD43D0848F147F6FA54AB3FCF415BD3B6508B824A16D67D19A330E
773D1AA45264589235F89211D8579D9FB6A74C88F4C50C5E72119BEA4D2E5839
93EB13F962448145BE4AC689B00E26C85367F1AFE871736DA5932DE326078DC9
5803B91F70344C956B6404A18AC58DED47CAB1DF90FCCFFC072E91019D779E17
587AB39814583B19454D9856A37517BF6A87B216625E011E1557336B1844118F
00153C2848BEEC2366A237C220DF45EEAE9F54081804F5FD98DA0C335A85C263
1BFB69D63CC2014BFD55F27BF3EB56FA82D9FD46442CBDD70D4CA0CDA555DF8D
CBB1F9DC443A63E6C747F996CE87C2F1D2E5D390ED46E26C5DBC97922DC5B2CD
1833B124E855216D187B35B8AAC26F0C95214A7BAB057F54A3D8F523C45002F4
6296E41FB5892FF56B85126F181F748012981623D26A76333D3B376B4C5B31F9
300A2166A7CC14503A2D00D47C0C72DCFFEF32DE69EED1C5FF7CFEA9DF1AE620
73E25BFF935AEE9623E02258F412B3D681F35C04EE018152A31ECA248EBFFC93
1C14EEF2F3AF2FA4AABD1C388953CD79BA35C4DA99D0057AB04A4A8DA48301FA
B8DAC78E48013541E8F920A2A660290FEB72A165635A6EE6A9DE7CF7218B21B3
D90F48DA5BDB8D010EA219B550326EEAD4D07BA46C524C9A0A2EAEC3EDB58C3C
18720894F0EE429E07D4FDC58644A2EBC377931CFA591C2D25927054860CF203
33642C9FEDAB28D203E3C24D5CBE8A9772EF5E75BC9325006D850D1F542C91AC
E603C8151818EE4D9C2E068F8036FCFCF27EBAE1028ABB09C23CAED35DB96CB1
E3624EF201DB12E0E74FFA9716CB2CB1BC67F220EDEEE25EDF311B1C08D2674C
1BB6F483EFEC90BD4F59EFA697A3D9BC116E7F045A9CE4A0C94CDD29B4ED1025
D5781F860105B28113B5B51EB7595886A621E916D8467D02BF2BB34B0CE4DC87
FCCF9AD6596AD79DCABA292025EA996D6A43062A90B01393F357E77B548153DD
968EDBF84BC2F29B7E75051C98EBCC86BAE61F4C0CF63498F45D59F514CBA8AA
A9FE5FB18093C750D194BF0BD3846CB1202EA7D7E2B9EF28F4B2659E5E13E47E
36C6B864D4006EE39CC2C84F1951156FC68EF4B8D900594F0EDF2F3D3938A862
0D987D546128D9D8F70FC32D4D4DC979B50CF52B08AB3DCF36F6DA8D36BFC901
3500D58635145125B2D85AD5737EF4F617BB6F88C2E08549559A5ECCB200EB04
FAAC45BC911CD691818D6DE9EA01045DC57DDFF7C5E0971A2F9C5A3A72709FD9
AEFCC12DDE99C73DFAFCB365E77E05C6E1F769A98DE961F7EC4D3FB065C33B11
2169B8803DB9DD546FC79EA43ACF571F484980EE67C3B94FA7D7690E35F28FC5
4DE4A487982A2932D89EB364D6A18D2B0A16886B87C19AA463A6DED1F6D94F9D
C47DA94152289BA4375F1E87E5B390682B11A645023F92EBFA8F7AF24A08E0FB
D6A1F059B5C5C92A77CB993A794B62E92A3C85893133179A6E2CB724D6278B46
13DF845A502BD71B396DB10AC097100C2AA28C4062F1446B4D2F57EFD29031C7
8D45E922F920353CF2147827DC27D92C749298CC4DF8E7D954D392C3BDD69532
A98D3FAFE4
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 15849777 10255735 1000 600 600 (businesscard.dvi)
@start /Fa 134[35 3[37 26 26 26 1[37 33 1[55 19 35 1[19
37 1[21 30 37 30 37 33 38[19 10[33 19 46[{}21 58.1154
/CMR7 rf /Fb 136[54 9[62 21 2[21 3[34 2[42 37 38[21 58[{}8
58.1154 /CMBX7 rf /Fc 137[37 1[27 1[28 1[39 35 39 1[20
2[20 1[35 1[31 2[39 10[72 17[48 54 51 67[{}15 66.4176
/CMR8 rf /Fd 135[43 59 2[32 1[34 1[45 41 8[25 37 3[40
13[45 13[53 69[{}11 66.4176 /CMBX8 rf /Fe 140[41 43 8[29
58 2[48 2[58 51 26[66 2[76 67[{}9 90.9091 /CMBX10 rf
end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
% dvips-unknown
statusdict /setpageparams known { hsize vsize 0 1 statusdict begin {
setpageparams } stopped end } { true } ifelse { statusdict /setpage known
{ hsize vsize 1 statusdict begin { setpage } stopped pop end } if } if
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
-482 -391 a Fe(F)-9 b(aris)36 b(Chebib)p -482 -306 1772
24 v -482 464 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray   gsave 0.  1 1 0.0
 0.0  translate scale rotate 0 0 moveto (MECARD:N:Chebib,Faris;EMAIL:faris\spacefactor \@m theluckybead.com;URL:http://theluckybead.com;;)
(eclevel=L width=1.181 height=1.181) qrcode grestore  end
 
@endspecial
0 TeXcolorgray 0 TeXcolorgray 706 -199 a Fd(Soft)n(w)n(are)26
b(Exp)r(ert)698 -80 y Fc(Cognitiv)n(e)e(Engineer)819
38 y(W)-6 b(eb)25 b(Dev)n(elop)r(er)417 371 y Fb(email:)30
b Fa(faristheluc)n(kyb)r(ead.com)348 434 y Fb(w)n(eb:)g
Fa(h)n(ttp://theluc)n(kyb)r(ead.com/)p -482 528 V 0 TeXcolorgray
0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
